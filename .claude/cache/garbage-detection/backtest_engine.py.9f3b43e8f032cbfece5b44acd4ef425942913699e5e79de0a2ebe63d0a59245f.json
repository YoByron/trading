{
  "dead_imports": [],
  "commented_blocks": [],
  "empty_functions": [],
  "unused_variables": [],
  "all_functions": [
    {
      "name": "__init__",
      "line": 54,
      "code": "def __init__(self, strategy: Any, start_date: str, end_date: str, initial_capital: float=100000.0):\n    \"\"\"\n        Initialize the backtest engine.\n\n        Args:\n            strategy: Trading strategy instance (e.g., CoreStrategy)\n            start_date: Start date in YYYY-MM-DD format\n            end_date: End date in YYYY-MM-DD format\n            initial_capital: Starting capital amount (default: $100,000)\n\n        Raises:\n            ValueError: If dates are invalid or strategy is None\n        \"\"\"\n    if strategy is None:\n        raise ValueError('Strategy cannot be None')\n    try:\n        self.start_date = datetime.strptime(start_date, '%Y-%m-%d')\n        self.end_date = datetime.strptime(end_date, '%Y-%m-%d')\n    except ValueError as e:\n        raise ValueError(f'Invalid date format. Use YYYY-MM-DD: {e}')\n    if self.start_date >= self.end_date:\n        raise ValueError('Start date must be before end date')\n    if initial_capital <= 0:\n        raise ValueError('Initial capital must be positive')\n    self.strategy = strategy\n    self.initial_capital = initial_capital\n    self.current_capital = initial_capital\n    self.portfolio_value = initial_capital\n    self.positions: Dict[str, float] = {}\n    self.position_costs: Dict[str, float] = {}\n    self.trades: List[Dict[str, Any]] = []\n    self.equity_curve: List[float] = [initial_capital]\n    self.dates: List[str] = [start_date]\n    self.price_cache: Dict[str, pd.DataFrame] = {}\n    logger.info(f'Backtest engine initialized: {start_date} to {end_date}')\n    logger.info(f'Initial capital: ${initial_capital:,.2f}')\n    logger.info(f'Strategy: {type(strategy).__name__}')"
    },
    {
      "name": "run",
      "line": 109,
      "code": "def run(self) -> BacktestResults:\n    \"\"\"\n        Execute the backtest and return comprehensive results.\n\n        This method:\n        1. Iterates through each trading day in the date range\n        2. Simulates strategy execution for each day\n        3. Tracks portfolio performance\n        4. Calculates final metrics\n        5. Returns BacktestResults object\n\n        Returns:\n            BacktestResults object containing all performance data and metrics\n\n        Raises:\n            Exception: If backtest execution fails\n        \"\"\"\n    logger.info('=' * 80)\n    logger.info('STARTING BACKTEST EXECUTION')\n    logger.info('=' * 80)\n    try:\n        self._preload_price_data()\n        trading_dates = self._get_trading_dates()\n        logger.info(f'Total trading days: {len(trading_dates)}')\n        for i, date in enumerate(trading_dates):\n            self._simulate_trading_day(date)\n            if (i + 1) % 10 == 0 or i == len(trading_dates) - 1:\n                logger.info(f'Progress: {i + 1}/{len(trading_dates)} days ({(i + 1) / len(trading_dates) * 100:.1f}%) - Portfolio: ${self.portfolio_value:,.2f}')\n        results = self._calculate_results()\n        logger.info('=' * 80)\n        logger.info('BACKTEST COMPLETE')\n        logger.info('=' * 80)\n        logger.info(f'Total Trades: {results.total_trades}')\n        logger.info(f'Final Capital: ${results.final_capital:,.2f} ({results.total_return:+.2f}%)')\n        logger.info(f'Sharpe Ratio: {results.sharpe_ratio:.2f}')\n        logger.info(f'Max Drawdown: {results.max_drawdown:.2f}%')\n        logger.info(f'Win Rate: {results.win_rate:.1f}%')\n        return results\n    except Exception as e:\n        logger.error(f'Backtest execution failed: {e}', exc_info=True)\n        raise"
    },
    {
      "name": "_preload_price_data",
      "line": 172,
      "code": "def _preload_price_data(self) -> None:\n    \"\"\"\n        Pre-load historical price data for all ETFs using Alpaca API.\n        More reliable than yfinance free tier.\n        \"\"\"\n    logger.info('Pre-loading historical price data from Alpaca...')\n    alpaca_key = os.getenv('ALPACA_API_KEY')\n    alpaca_secret = os.getenv('ALPACA_SECRET_KEY')\n    if not alpaca_key or not alpaca_secret:\n        logger.error('Alpaca API credentials not found. Set ALPACA_API_KEY and ALPACA_SECRET_KEY')\n        return\n    api = tradeapi.REST(alpaca_key, alpaca_secret, 'https://paper-api.alpaca.markets')\n    etf_universe = getattr(self.strategy, 'etf_universe', ['SPY', 'QQQ', 'VOO'])\n    for symbol in etf_universe:\n        try:\n            start_with_buffer = (self.start_date - timedelta(days=200)).strftime('%Y-%m-%d')\n            end_with_buffer = (self.end_date + timedelta(days=1)).strftime('%Y-%m-%d')\n            bars = api.get_bars(symbol, tradeapi.TimeFrame.Day, start=start_with_buffer, end=end_with_buffer, adjustment='all').df\n            if bars is not None and (not bars.empty):\n                bars = bars.rename(columns={'open': 'Open', 'high': 'High', 'low': 'Low', 'close': 'Close', 'volume': 'Volume'})\n                self.price_cache[symbol] = bars\n                logger.info(f'Loaded {len(bars)} bars for {symbol} from Alpaca')\n            else:\n                logger.warning(f'No data returned for {symbol}')\n        except Exception as e:\n            logger.warning(f'Failed to load data for {symbol}: {e}')"
    },
    {
      "name": "_get_trading_dates",
      "line": 234,
      "code": "def _get_trading_dates(self) -> List[datetime]:\n    \"\"\"\n        Generate list of trading dates (weekdays only) in the backtest period.\n\n        Returns:\n            List of datetime objects representing trading days\n        \"\"\"\n    dates = []\n    current_date = self.start_date\n    while current_date <= self.end_date:\n        if current_date.weekday() < 5:\n            dates.append(current_date)\n        current_date += timedelta(days=1)\n    return dates"
    },
    {
      "name": "_simulate_trading_day",
      "line": 252,
      "code": "def _simulate_trading_day(self, date: datetime) -> None:\n    \"\"\"\n        Simulate strategy execution for a single trading day.\n\n        Args:\n            date: Trading date to simulate\n        \"\"\"\n    date_str = date.strftime('%Y-%m-%d')\n    self._update_portfolio_value(date)\n    try:\n        momentum_scores = []\n        for symbol in self.strategy.etf_universe:\n            try:\n                hist = self._get_historical_data(symbol, date)\n                if hist is None:\n                    logger.warning(f'{date_str}: No historical data for {symbol}')\n                    continue\n                if len(hist) < 50:\n                    logger.warning(f'{date_str}: Insufficient data for {symbol}: {len(hist)} bars (need 50)')\n                    continue\n                score = self._calculate_momentum_for_date(symbol, date)\n                if score is not None:\n                    momentum_scores.append({'symbol': symbol, 'score': score})\n                    logger.info(f'{date_str}: {symbol} momentum={score:.2f}')\n                else:\n                    logger.warning(f'{date_str}: Momentum calculation returned None for {symbol}')\n            except Exception as e:\n                logger.warning(f'Failed to calculate momentum for {symbol}: {e}')\n                continue\n        if not momentum_scores:\n            logger.warning(f'{date_str}: No valid momentum scores')\n            return\n        momentum_scores.sort(key=lambda x: x['score'], reverse=True)\n        best_etf = momentum_scores[0]['symbol']\n        price = self._get_price(best_etf, date)\n        if price is None:\n            logger.debug(f'{date_str}: No price available for {best_etf}')\n            return\n        daily_allocation = self.strategy.daily_allocation\n        if self.current_capital >= daily_allocation:\n            quantity = daily_allocation / price\n            trade = {'date': date_str, 'symbol': best_etf, 'action': 'buy', 'quantity': quantity, 'price': price, 'amount': daily_allocation, 'reason': 'Daily DCA purchase'}\n            self.trades.append(trade)\n            self.positions[best_etf] = self.positions.get(best_etf, 0.0) + quantity\n            self.position_costs[best_etf] = self.position_costs.get(best_etf, 0.0) + daily_allocation\n            self.current_capital -= daily_allocation\n            logger.debug(f'{date_str}: BUY {quantity:.4f} {best_etf} @ ${price:.2f}')\n    except Exception as e:\n        logger.debug(f'Error simulating {date_str}: {e}')\n    self._update_portfolio_value(date)\n    self.equity_curve.append(self.portfolio_value)\n    self.dates.append(date_str)"
    },
    {
      "name": "_get_historical_data",
      "line": 348,
      "code": "def _get_historical_data(self, symbol: str, date: datetime) -> Optional[pd.DataFrame]:\n    \"\"\"\n        Get historical data for a symbol up to a specific date.\n\n        Args:\n            symbol: ETF symbol\n            date: Date to get data up to\n\n        Returns:\n            DataFrame with historical data or None if unavailable\n        \"\"\"\n    if symbol not in self.price_cache:\n        return None\n    hist = self.price_cache[symbol]\n    if date.tzinfo is None:\n        import pytz\n        date = pytz.UTC.localize(date)\n    hist_filtered = hist[hist.index <= date]\n    return hist_filtered if len(hist_filtered) > 0 else None"
    },
    {
      "name": "_calculate_momentum_for_date",
      "line": 377,
      "code": "def _calculate_momentum_for_date(self, symbol: str, date: datetime) -> Optional[float]:\n    \"\"\"\n        Calculate momentum score for a symbol at a specific date.\n\n        Args:\n            symbol: ETF symbol\n            date: Date to calculate momentum for\n\n        Returns:\n            Momentum score or None if calculation fails\n        \"\"\"\n    try:\n        hist = self._get_historical_data(symbol, date)\n        if hist is None or len(hist) < 126:\n            return None\n        returns_1m = self._calculate_period_return(hist, 21)\n        returns_3m = self._calculate_period_return(hist, 63)\n        returns_6m = self._calculate_period_return(hist, 126)\n        momentum = (returns_1m * 0.5 + returns_3m * 0.3 + returns_6m * 0.2) * 100\n        return momentum\n    except Exception as e:\n        logger.debug(f'Momentum calculation failed for {symbol}: {e}')\n        return None"
    },
    {
      "name": "_calculate_period_return",
      "line": 409,
      "code": "def _calculate_period_return(self, hist: pd.DataFrame, periods: int) -> float:\n    \"\"\"\n        Calculate return over specified number of periods.\n\n        Args:\n            hist: Historical price DataFrame\n            periods: Number of periods to look back\n\n        Returns:\n            Period return as decimal\n        \"\"\"\n    if len(hist) < periods:\n        periods = len(hist) - 1\n    if periods <= 0:\n        return 0.0\n    end_price = hist['Close'].iloc[-1]\n    start_price = hist['Close'].iloc[-periods]\n    return (end_price - start_price) / start_price"
    },
    {
      "name": "_get_price",
      "line": 431,
      "code": "def _get_price(self, symbol: str, date: datetime) -> Optional[float]:\n    \"\"\"\n        Get the closing price for a symbol on a specific date.\n\n        Args:\n            symbol: ETF symbol\n            date: Date to get price for\n\n        Returns:\n            Closing price or None if unavailable\n        \"\"\"\n    hist = self._get_historical_data(symbol, date)\n    if hist is None or len(hist) == 0:\n        return None\n    return float(hist['Close'].iloc[-1])"
    },
    {
      "name": "_update_portfolio_value",
      "line": 448,
      "code": "def _update_portfolio_value(self, date: datetime) -> None:\n    \"\"\"\n        Update total portfolio value based on current positions and prices.\n\n        Args:\n            date: Current date for price lookup\n        \"\"\"\n    positions_value = 0.0\n    for symbol, quantity in self.positions.items():\n        price = self._get_price(symbol, date)\n        if price:\n            positions_value += quantity * price\n    self.portfolio_value = self.current_capital + positions_value"
    },
    {
      "name": "_calculate_results",
      "line": 464,
      "code": "def _calculate_results(self) -> BacktestResults:\n    \"\"\"\n        Calculate comprehensive backtest results and metrics.\n\n        Returns:\n            BacktestResults object with all performance data\n        \"\"\"\n    final_capital = self.portfolio_value\n    total_return = (final_capital - self.initial_capital) / self.initial_capital * 100\n    daily_returns = np.diff(self.equity_curve) / self.equity_curve[:-1]\n    if len(daily_returns) > 1:\n        mean_return = np.mean(daily_returns)\n        std_return = np.std(daily_returns)\n        risk_free_rate_daily = 0.04 / 252\n        sharpe_ratio = (mean_return - risk_free_rate_daily) / std_return * np.sqrt(252) if std_return > 0 else 0.0\n    else:\n        sharpe_ratio = 0.0\n    cumulative_returns = np.array(self.equity_curve)\n    running_max = np.maximum.accumulate(cumulative_returns)\n    drawdown = (cumulative_returns - running_max) / running_max\n    max_drawdown = abs(np.min(drawdown)) * 100\n    positive_days = np.sum(daily_returns > 0)\n    win_rate = positive_days / len(daily_returns) * 100 if len(daily_returns) > 0 else 0.0\n    total_trades = len(self.trades)\n    profitable_trades = 0\n    for trade in self.trades:\n        symbol = trade['symbol']\n        buy_price = trade['price']\n        final_price = self._get_price(symbol, self.end_date)\n        if final_price and final_price > buy_price:\n            profitable_trades += 1\n    average_trade_return = total_return / total_trades if total_trades > 0 else 0.0\n    results = BacktestResults(trades=self.trades, equity_curve=self.equity_curve, dates=self.dates, total_return=total_return, sharpe_ratio=sharpe_ratio, max_drawdown=max_drawdown, win_rate=win_rate, total_trades=total_trades, profitable_trades=profitable_trades, average_trade_return=average_trade_return, initial_capital=self.initial_capital, final_capital=final_capital, start_date=self.start_date.strftime('%Y-%m-%d'), end_date=self.end_date.strftime('%Y-%m-%d'), trading_days=len(self.dates) - 1)\n    return results"
    }
  ]
}
