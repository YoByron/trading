{
  "dead_imports": [
    {
      "line": 14,
      "module": "Optional",
      "statement": "from typing import Tuple, Optional"
    }
  ],
  "commented_blocks": [],
  "empty_functions": [],
  "unused_variables": [],
  "all_functions": [
    {
      "name": "calculate_macd",
      "line": 21,
      "code": "def calculate_macd(prices: pd.Series, fast_period: int=12, slow_period: int=26, signal_period: int=9) -> Tuple[float, float, float]:\n    \"\"\"\n    Calculate MACD (Moving Average Convergence Divergence).\n\n    MACD is a trend-following momentum indicator that shows the relationship between\n    two exponential moving averages (EMAs) of a security's price.\n\n    Formula:\n    - MACD Line = 12-day EMA - 26-day EMA\n    - Signal Line = 9-day EMA of MACD Line\n    - Histogram = MACD Line - Signal Line\n\n    Trading Signals:\n    - Bullish: MACD crosses above signal line (histogram > 0)\n    - Bearish: MACD crosses below signal line (histogram < 0)\n    - Momentum strength: Larger histogram = stronger momentum\n\n    Args:\n        prices: Price series (typically Close prices)\n        fast_period: Fast EMA period (default: 12)\n        slow_period: Slow EMA period (default: 26)\n        signal_period: Signal line EMA period (default: 9)\n\n    Returns:\n        Tuple of (macd_value, signal_line, histogram)\n    \"\"\"\n    if len(prices) < slow_period + signal_period:\n        logger.warning(f'Insufficient data for MACD calculation: {len(prices)} bars, need at least {slow_period + signal_period}')\n        return (0.0, 0.0, 0.0)\n    ema_fast = prices.ewm(span=fast_period, adjust=False).mean()\n    ema_slow = prices.ewm(span=slow_period, adjust=False).mean()\n    macd_line = ema_fast - ema_slow\n    signal_line = macd_line.ewm(span=signal_period, adjust=False).mean()\n    histogram = macd_line - signal_line\n    return (float(macd_line.iloc[-1]) if not pd.isna(macd_line.iloc[-1]) else 0.0, float(signal_line.iloc[-1]) if not pd.isna(signal_line.iloc[-1]) else 0.0, float(histogram.iloc[-1]) if not pd.isna(histogram.iloc[-1]) else 0.0)"
    },
    {
      "name": "calculate_rsi",
      "line": 80,
      "code": "def calculate_rsi(prices: pd.Series, period: int=14) -> float:\n    \"\"\"\n    Calculate RSI (Relative Strength Index).\n\n    RSI is a momentum oscillator that measures the speed and magnitude of price changes.\n    Values range from 0 to 100.\n\n    Trading Signals:\n    - Overbought: RSI > 70 (potential sell signal)\n    - Oversold: RSI < 30 (potential buy signal)\n    - Neutral: 30 < RSI < 70\n\n    Args:\n        prices: Price series (typically Close prices)\n        period: RSI period (default: 14)\n\n    Returns:\n        RSI value (0-100)\n    \"\"\"\n    if len(prices) < period + 1:\n        logger.warning(f'Insufficient data for RSI calculation: {len(prices)} bars, need at least {period + 1}')\n        return 50.0\n    delta = prices.diff()\n    gain = delta.where(delta > 0, 0.0)\n    loss = -delta.where(delta < 0, 0.0)\n    avg_gain = gain.rolling(window=period).mean()\n    avg_loss = loss.rolling(window=period).mean()\n    rs = avg_gain / avg_loss.replace(0, np.nan)\n    rsi = 100 - 100 / (1 + rs)\n    rsi_value = rsi.iloc[-1]\n    if pd.isna(rsi_value):\n        return 50.0\n    return float(rsi_value)"
    },
    {
      "name": "calculate_volume_ratio",
      "line": 131,
      "code": "def calculate_volume_ratio(hist: pd.DataFrame, window: int=20) -> float:\n    \"\"\"\n    Calculate volume ratio (current vs N-day average).\n\n    Volume ratio helps confirm price movements:\n    - High volume (>1.5x average) = Strong conviction\n    - Low volume (<0.8x average) = Weak conviction\n\n    Args:\n        hist: Historical price DataFrame with 'Volume' column\n        window: Window size for average volume calculation (default: 20)\n\n    Returns:\n        Volume ratio (current / average)\n    \"\"\"\n    if len(hist) < window:\n        logger.warning(f'Insufficient data for volume ratio: {len(hist)} bars, need at least {window}')\n        return 1.0\n    if 'Volume' not in hist.columns:\n        logger.warning('Volume column not found in DataFrame')\n        return 1.0\n    current_volume = hist['Volume'].iloc[-1]\n    avg_volume = hist['Volume'].iloc[-window:].mean()\n    if avg_volume == 0 or pd.isna(avg_volume):\n        return 1.0\n    return float(current_volume / avg_volume)"
    },
    {
      "name": "calculate_technical_score",
      "line": 166,
      "code": "def calculate_technical_score(hist: pd.DataFrame, symbol: str, macd_threshold: float=0.0, rsi_overbought: float=70.0, volume_min: float=0.8) -> Tuple[float, dict]:\n    \"\"\"\n    Calculate composite technical score for a symbol.\n\n    This function implements the same logic as autonomous_trader.py but\n    uses the shared indicator functions.\n\n    Args:\n        hist: Historical price DataFrame with 'Close' and 'Volume' columns\n        symbol: Symbol name (for logging)\n        macd_threshold: Minimum MACD histogram value (default: 0.0)\n        rsi_overbought: Maximum RSI value (default: 70.0)\n        volume_min: Minimum volume ratio (default: 0.8)\n\n    Returns:\n        Tuple of (technical_score, indicators_dict)\n        Returns (0, {}) if symbol is rejected by filters\n    \"\"\"\n    if hist.empty or len(hist) < 26:\n        logger.warning(f'{symbol}: Insufficient data ({len(hist)} bars)')\n        return (0.0, {})\n    macd_value, macd_signal, macd_histogram = calculate_macd(hist['Close'])\n    rsi_val = calculate_rsi(hist['Close'])\n    volume_ratio = calculate_volume_ratio(hist)\n    indicators = {'macd_value': macd_value, 'macd_signal': macd_signal, 'macd_histogram': macd_histogram, 'rsi': rsi_val, 'volume_ratio': volume_ratio, 'current_price': float(hist['Close'].iloc[-1])}\n    if macd_histogram < macd_threshold:\n        logger.info(f'{symbol}: REJECTED - Bearish MACD histogram ({macd_histogram:.3f})')\n        return (0.0, indicators)\n    if rsi_val > rsi_overbought:\n        logger.info(f'{symbol}: REJECTED - Overbought RSI ({rsi_val:.1f})')\n        return (0.0, indicators)\n    if volume_ratio < volume_min:\n        logger.info(f'{symbol}: REJECTED - Low volume ({volume_ratio:.2f}x)')\n        return (0.0, indicators)\n    price = hist['Close'].iloc[-1]\n    technical_score = price * (1 + macd_histogram / 10) * (1 + (70 - rsi_val) / 100) * volume_ratio\n    logger.info(f'{symbol}: Score {technical_score:.2f} | MACD: {macd_histogram:.3f} | RSI: {rsi_val:.1f} | Vol: {volume_ratio:.2f}x')\n    return (technical_score, indicators)"
    },
    {
      "name": "calculate_atr",
      "line": 237,
      "code": "def calculate_atr(hist: pd.DataFrame, period: int=14) -> float:\n    \"\"\"\n    Calculate Average True Range (ATR) for dynamic stop-loss placement.\n\n    ATR measures market volatility by calculating the average of true ranges\n    over a specified period. True Range is the maximum of:\n    1. Current High - Current Low\n    2. |Current High - Previous Close|\n    3. |Current Low - Previous Close|\n\n    ATR-based stop-losses adapt to volatility:\n    - High volatility = wider stops (less likely to be stopped out by noise)\n    - Low volatility = tighter stops (protect profits better)\n\n    Args:\n        hist: Historical price DataFrame with 'High', 'Low', 'Close' columns\n        period: ATR period (default: 14)\n\n    Returns:\n        ATR value (in price units)\n    \"\"\"\n    if len(hist) < period + 1:\n        logger.warning(f'Insufficient data for ATR calculation: {len(hist)} bars, need at least {period + 1}')\n        return 0.0\n    if not all((col in hist.columns for col in ['High', 'Low', 'Close'])):\n        logger.warning('Missing required columns for ATR: High, Low, Close')\n        return 0.0\n    high = hist['High']\n    low = hist['Low']\n    close = hist['Close']\n    tr1 = high - low\n    tr2 = abs(high - close.shift(1))\n    tr3 = abs(low - close.shift(1))\n    true_range = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)\n    atr = true_range.rolling(window=period).mean()\n    atr_value = atr.iloc[-1]\n    if pd.isna(atr_value) or atr_value <= 0:\n        return 0.0\n    return float(atr_value)"
    },
    {
      "name": "calculate_atr_stop_loss",
      "line": 295,
      "code": "def calculate_atr_stop_loss(entry_price: float, atr: float, multiplier: float=2.0, direction: str='long') -> float:\n    \"\"\"\n    Calculate ATR-based stop-loss price.\n\n    Stop-loss is placed at entry_price \u00b1 (multiplier \u00d7 ATR)\n    - Long positions: entry_price - (multiplier \u00d7 ATR)\n    - Short positions: entry_price + (multiplier \u00d7 ATR)\n\n    Common multipliers:\n    - 1.5x ATR: Tighter stop (more sensitive)\n    - 2.0x ATR: Balanced (default)\n    - 2.5x ATR: Wider stop (less sensitive, good for volatile stocks)\n\n    Args:\n        entry_price: Entry price of the position\n        atr: Average True Range value\n        multiplier: ATR multiplier (default: 2.0)\n        direction: 'long' or 'short' (default: 'long')\n\n    Returns:\n        Stop-loss price\n    \"\"\"\n    if atr <= 0:\n        if direction == 'long':\n            return entry_price * 0.97\n        else:\n            return entry_price * 1.03\n    stop_distance = multiplier * atr\n    if direction == 'long':\n        stop_price = entry_price - stop_distance\n    else:\n        stop_price = entry_price + stop_distance\n    return max(0.0, stop_price)"
    }
  ]
}
