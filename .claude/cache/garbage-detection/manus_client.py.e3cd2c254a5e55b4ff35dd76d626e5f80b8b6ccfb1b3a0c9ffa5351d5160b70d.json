{
  "dead_imports": [],
  "commented_blocks": [],
  "empty_functions": [],
  "unused_variables": [],
  "all_functions": [
    {
      "name": "get_manus_client",
      "line": 439,
      "code": "def get_manus_client(api_key: Optional[str]=None) -> ManusClient:\n    \"\"\"\n    Get a Manus client instance.\n    \n    Args:\n        api_key: Optional API key (defaults to MANUS_API_KEY env var)\n        \n    Returns:\n        ManusClient instance\n    \"\"\"\n    return ManusClient(api_key=api_key)"
    },
    {
      "name": "__init__",
      "line": 37,
      "code": "def __init__(self, api_key: Optional[str]=None):\n    \"\"\"\n        Initialize Manus API client.\n        \n        Args:\n            api_key: Manus API key (defaults to MANUS_API_KEY env var)\n        \"\"\"\n    self.api_key = api_key or os.getenv('MANUS_API_KEY')\n    if not self.api_key:\n        raise ValueError('Manus API key required. Set MANUS_API_KEY environment variable or pass api_key parameter.')\n    self.base_url = 'https://api.manus.ai/v1'\n    self.headers = {'Authorization': f'Bearer {self.api_key}', 'Content-Type': 'application/json'}\n    logger.info('Manus API client initialized')"
    },
    {
      "name": "create_research_task",
      "line": 58,
      "code": "def create_research_task(self, symbol: str, research_type: str='comprehensive', include_competitors: bool=False) -> Dict[str, Any]:\n    \"\"\"\n        Create an autonomous research task for a stock.\n        \n        Args:\n            symbol: Stock ticker symbol (e.g., \"AAPL\")\n            research_type: Type of research (\"comprehensive\", \"quick\", \"deep\")\n            include_competitors: Whether to include competitor analysis\n            \n        Returns:\n            Task creation response with task_id\n        \"\"\"\n    prompt = self._build_research_prompt(symbol, research_type, include_competitors)\n    payload = {'prompt': prompt, 'task_type': 'stock_research', 'metadata': {'symbol': symbol, 'research_type': research_type, 'timestamp': datetime.now().isoformat()}}\n    try:\n        response = requests.post(f'{self.base_url}/tasks', headers=self.headers, json=payload, timeout=30)\n        response.raise_for_status()\n        result = response.json()\n        logger.info(f\"Created Manus research task for {symbol}: {result.get('task_id')}\")\n        return result\n    except requests.exceptions.RequestException as e:\n        logger.error(f'Failed to create Manus research task: {e}')\n        raise"
    },
    {
      "name": "get_task_status",
      "line": 104,
      "code": "def get_task_status(self, task_id: str) -> Dict[str, Any]:\n    \"\"\"\n        Get the status of a research task.\n        \n        Args:\n            task_id: Task ID from create_research_task\n            \n        Returns:\n            Task status and results if available\n        \"\"\"\n    try:\n        response = requests.get(f'{self.base_url}/tasks/{task_id}', headers=self.headers, timeout=30)\n        response.raise_for_status()\n        return response.json()\n    except requests.exceptions.RequestException as e:\n        logger.error(f'Failed to get Manus task status: {e}')\n        raise"
    },
    {
      "name": "wait_for_task_completion",
      "line": 127,
      "code": "def wait_for_task_completion(self, task_id: str, timeout_seconds: int=300, poll_interval: int=5) -> Dict[str, Any]:\n    \"\"\"\n        Wait for a task to complete and return results.\n        \n        Args:\n            task_id: Task ID to wait for\n            timeout_seconds: Maximum time to wait\n            poll_interval: Seconds between status checks\n            \n        Returns:\n            Completed task results\n        \"\"\"\n    start_time = time.time()\n    while time.time() - start_time < timeout_seconds:\n        status = self.get_task_status(task_id)\n        task_status = status.get('status', 'unknown')\n        if task_status == 'completed':\n            logger.info(f'Manus task {task_id} completed successfully')\n            return status\n        elif task_status == 'failed':\n            error = status.get('error', 'Unknown error')\n            logger.error(f'Manus task {task_id} failed: {error}')\n            raise Exception(f'Manus task failed: {error}')\n        logger.debug(f'Manus task {task_id} status: {task_status}, waiting...')\n        time.sleep(poll_interval)\n    raise TimeoutError(f'Manus task {task_id} timed out after {timeout_seconds} seconds')"
    },
    {
      "name": "research_stock",
      "line": 165,
      "code": "def research_stock(self, symbol: str, research_type: str='comprehensive', include_competitors: bool=False, wait_for_completion: bool=True) -> Dict[str, Any]:\n    \"\"\"\n        Research a stock using Manus autonomous agents.\n        \n        This is the main entry point for stock research.\n        \n        Args:\n            symbol: Stock ticker symbol\n            research_type: \"comprehensive\", \"quick\", or \"deep\"\n            include_competitors: Include competitor analysis\n            wait_for_completion: Whether to wait for task completion\n            \n        Returns:\n            Research results with analysis, data, and recommendations\n        \"\"\"\n    logger.info(f'Starting Manus research for {symbol} ({research_type})')\n    task = self.create_research_task(symbol, research_type, include_competitors)\n    task_id = task.get('task_id')\n    if not task_id:\n        raise ValueError('Failed to get task_id from Manus API')\n    if wait_for_completion:\n        result = self.wait_for_task_completion(task_id)\n        return self._parse_research_results(result, symbol)\n    else:\n        return {'task_id': task_id, 'status': 'pending', 'symbol': symbol, 'message': 'Task created, use get_task_status() to check progress'}"
    },
    {
      "name": "compare_stocks",
      "line": 208,
      "code": "def compare_stocks(self, symbols: List[str], metrics: Optional[List[str]]=None) -> Dict[str, Any]:\n    \"\"\"\n        Compare multiple stocks using Manus.\n        \n        Args:\n            symbols: List of stock ticker symbols\n            metrics: Optional list of specific metrics to compare\n            \n        Returns:\n            Comparison analysis\n        \"\"\"\n    if len(symbols) < 2:\n        raise ValueError('Need at least 2 symbols to compare')\n    metrics = metrics or ['price', 'pe_ratio', 'growth_rate', 'profit_margin', 'market_cap', 'revenue', 'sentiment']\n    prompt = f\"Compare these stocks: {', '.join(symbols)}\\n\\nAnalyze and compare on these metrics:\\n{', '.join(metrics)}\\n\\nProvide:\\n1. Side-by-side comparison table\\n2. Key differences and similarities\\n3. Relative strengths and weaknesses\\n4. Investment recommendation ranking\\n5. Risk assessment for each\\n\"\n    payload = {'prompt': prompt, 'task_type': 'stock_comparison', 'metadata': {'symbols': symbols, 'metrics': metrics, 'timestamp': datetime.now().isoformat()}}\n    try:\n        response = requests.post(f'{self.base_url}/tasks', headers=self.headers, json=payload, timeout=30)\n        response.raise_for_status()\n        task = response.json()\n        task_id = task.get('task_id')\n        if task_id:\n            result = self.wait_for_task_completion(task_id)\n            return self._parse_comparison_results(result, symbols)\n        else:\n            raise ValueError('Failed to get task_id from Manus API')\n    except requests.exceptions.RequestException as e:\n        logger.error(f'Failed to compare stocks: {e}')\n        raise"
    },
    {
      "name": "monitor_watchlist",
      "line": 281,
      "code": "def monitor_watchlist(self, symbols: List[str], alert_conditions: Optional[Dict[str, Any]]=None) -> Dict[str, Any]:\n    \"\"\"\n        Set up autonomous monitoring for a watchlist.\n        \n        Args:\n            symbols: List of stocks to monitor\n            alert_conditions: Conditions that trigger alerts (price changes, news, etc.)\n            \n        Returns:\n            Monitoring task information\n        \"\"\"\n    alert_conditions = alert_conditions or {'price_change_percent': 5.0, 'news_sentiment_shift': True, 'earnings_announcement': True}\n    prompt = f\"Set up continuous monitoring for these stocks: {', '.join(symbols)}\\n\\nMonitor for:\\n- Price movements exceeding {alert_conditions.get('price_change_percent', 5)}%\\n- Significant news or sentiment changes\\n- Earnings announcements\\n- Analyst rating changes\\n- Volume spikes\\n\\nProvide daily summary reports and immediate alerts for significant events.\\n\"\n    payload = {'prompt': prompt, 'task_type': 'watchlist_monitoring', 'metadata': {'symbols': symbols, 'alert_conditions': alert_conditions, 'timestamp': datetime.now().isoformat()}}\n    try:\n        response = requests.post(f'{self.base_url}/tasks', headers=self.headers, json=payload, timeout=30)\n        response.raise_for_status()\n        result = response.json()\n        logger.info(f'Created watchlist monitoring for {len(symbols)} stocks')\n        return result\n    except requests.exceptions.RequestException as e:\n        logger.error(f'Failed to create watchlist monitoring: {e}')\n        raise"
    },
    {
      "name": "_build_research_prompt",
      "line": 341,
      "code": "def _build_research_prompt(self, symbol: str, research_type: str, include_competitors: bool) -> str:\n    \"\"\"Build research prompt for Manus.\"\"\"\n    base_prompt = f'Research {symbol} stock comprehensively.\\n\\nGather data from multiple sources:\\n1. Current price and market data (Yahoo Finance, Alpha Vantage, Alpaca)\\n2. Financial statements (SEC filings, company reports)\\n3. Recent news and sentiment (NewsAPI, Google News, Reddit)\\n4. Analyst ratings and price targets\\n5. Technical indicators and charts\\n6. Industry trends and market context\\n\\n'\n    if include_competitors:\n        base_prompt += '\\n6. Identify and analyze main competitors\\n7. Compare competitive positioning\\n'\n    if research_type == 'comprehensive':\n        base_prompt += '\\nProvide comprehensive analysis including:\\n- Executive summary\\n- Financial health assessment\\n- Growth prospects\\n- Risk factors\\n- Investment thesis\\n- Recommendation (BUY/SELL/HOLD) with confidence level\\n- Price target (if available)\\n'\n    elif research_type == 'deep':\n        base_prompt += '\\nProvide deep dive analysis including:\\n- Detailed financial analysis (DCF, ratios, trends)\\n- Competitive landscape analysis\\n- Management quality assessment\\n- Industry positioning\\n- Regulatory risks\\n- Long-term outlook (1-5 years)\\n- Detailed investment thesis with multiple scenarios\\n'\n    else:\n        base_prompt += '\\nProvide quick analysis:\\n- Current status and key metrics\\n- Recent news impact\\n- Quick recommendation\\n'\n    return base_prompt"
    },
    {
      "name": "_parse_research_results",
      "line": 399,
      "code": "def _parse_research_results(self, result: Dict[str, Any], symbol: str) -> Dict[str, Any]:\n    \"\"\"Parse Manus research results into structured format.\"\"\"\n    output = result.get('output', {})\n    content = output.get('content', '') if isinstance(output, dict) else str(output)\n    return {'symbol': symbol, 'status': 'completed', 'analysis': content, 'raw_result': result, 'timestamp': datetime.now().isoformat()}"
    },
    {
      "name": "_parse_comparison_results",
      "line": 419,
      "code": "def _parse_comparison_results(self, result: Dict[str, Any], symbols: List[str]) -> Dict[str, Any]:\n    \"\"\"Parse stock comparison results.\"\"\"\n    output = result.get('output', {})\n    content = output.get('content', '') if isinstance(output, dict) else str(output)\n    return {'symbols': symbols, 'status': 'completed', 'comparison': content, 'raw_result': result, 'timestamp': datetime.now().isoformat()}"
    }
  ]
}
