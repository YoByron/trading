{
  "dead_imports": [
    {
      "line": 15,
      "module": "timedelta",
      "statement": "from datetime import datetime, timedelta"
    },
    {
      "line": 17,
      "module": "GrahamBuffettSafety",
      "statement": "from src.safety.graham_buffett_safety import ("
    }
  ],
  "commented_blocks": [],
  "empty_functions": [],
  "unused_variables": [
    {
      "line": 56,
      "variable": "portfolio_value"
    }
  ],
  "all_functions": [
    {
      "name": "__init__",
      "line": 37,
      "code": "def __init__(self):\n    super().__init__(name='QualityMonitorAgent', role='Portfolio quality monitoring and deterioration detection')\n    self.safety_analyzer = get_global_safety_analyzer()\n    self.quality_history: Dict[str, List[Dict[str, Any]]] = {}"
    },
    {
      "name": "analyze",
      "line": 45,
      "code": "def analyze(self, data: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"\n        Monitor portfolio quality and detect issues.\n        \n        Args:\n            data: Contains portfolio positions (list of {symbol, quantity, price})\n            \n        Returns:\n            Quality monitoring report with alerts and recommendations\n        \"\"\"\n    positions = data.get('positions', [])\n    portfolio_value = data.get('portfolio_value', 0.0)\n    if not positions:\n        return {'action': 'NO_ACTION', 'message': 'No positions to monitor', 'alerts': [], 'recommendations': []}\n    alerts = []\n    recommendations = []\n    quality_scores = {}\n    for position in positions:\n        symbol = position.get('symbol', '')\n        quantity = position.get('quantity', 0.0)\n        current_price = position.get('current_price', 0.0)\n        if not symbol or quantity <= 0:\n            continue\n        try:\n            safety_analysis = self.safety_analyzer.analyze_safety(symbol=symbol, market_price=current_price, force_refresh=False)\n            quality = safety_analysis.quality\n            if quality:\n                quality_scores[symbol] = quality.quality_score\n                deterioration = self._check_quality_deterioration(symbol, quality)\n                if deterioration:\n                    alerts.append(deterioration)\n                    recommendations.append(self._generate_recommendation(symbol, deterioration))\n                self._store_quality_history(symbol, quality)\n        except Exception as e:\n            logger.warning(f'Error monitoring quality for {symbol}: {e}')\n            continue\n    memory_context = self.get_memory_context(limit=5)\n    prompt = self._build_monitoring_prompt(positions, quality_scores, alerts, memory_context)\n    llm_response = self.reason_with_llm(prompt)\n    analysis = self._combine_monitoring_analysis(quality_scores, alerts, recommendations, llm_response)\n    self.log_decision(analysis)\n    return analysis"
    },
    {
      "name": "_check_quality_deterioration",
      "line": 125,
      "code": "def _check_quality_deterioration(self, symbol: str, current_quality: CompanyQuality) -> Optional[Dict[str, Any]]:\n    \"\"\"Check if quality has deteriorated compared to history.\"\"\"\n    if symbol not in self.quality_history:\n        return None\n    history = self.quality_history[symbol]\n    if len(history) < 2:\n        return None\n    previous_score = history[-1].get('quality_score', current_quality.quality_score)\n    current_score = current_quality.quality_score\n    if current_score < previous_score - 10:\n        return {'symbol': symbol, 'severity': 'HIGH' if current_score < 40 else 'MEDIUM', 'previous_score': previous_score, 'current_score': current_score, 'deterioration': previous_score - current_score, 'message': f'{symbol} quality deteriorated from {previous_score:.1f} to {current_score:.1f} (drop of {previous_score - current_score:.1f} points)'}\n    if current_score < 40 and previous_score >= 40:\n        return {'symbol': symbol, 'severity': 'HIGH', 'previous_score': previous_score, 'current_score': current_score, 'deterioration': previous_score - current_score, 'message': f'{symbol} quality dropped below threshold ({current_score:.1f} < 40)'}\n    return None"
    },
    {
      "name": "_store_quality_history",
      "line": 171,
      "code": "def _store_quality_history(self, symbol: str, quality: CompanyQuality) -> None:\n    \"\"\"Store quality metrics in history.\"\"\"\n    if symbol not in self.quality_history:\n        self.quality_history[symbol] = []\n    entry = {'timestamp': quality.timestamp.isoformat(), 'quality_score': quality.quality_score, 'debt_to_equity': quality.debt_to_equity, 'current_ratio': quality.current_ratio, 'roe': quality.roe, 'roa': quality.roa, 'profit_margin': quality.profit_margin, 'earnings_growth_3y': quality.earnings_growth_3y, 'earnings_consistency': quality.earnings_consistency}\n    self.quality_history[symbol].append(entry)\n    if len(self.quality_history[symbol]) > 30:\n        self.quality_history[symbol] = self.quality_history[symbol][-30:]"
    },
    {
      "name": "_generate_recommendation",
      "line": 194,
      "code": "def _generate_recommendation(self, symbol: str, deterioration: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Generate recommendation based on quality deterioration.\"\"\"\n    severity = deterioration['severity']\n    current_score = deterioration['current_score']\n    if severity == 'HIGH' and current_score < 40:\n        return {'symbol': symbol, 'action': 'CONSIDER_REDUCE', 'reason': f'Quality score {current_score:.1f} below threshold (40)', 'priority': 'HIGH'}\n    elif severity == 'MEDIUM':\n        return {'symbol': symbol, 'action': 'MONITOR_CLOSELY', 'reason': f'Quality deteriorating (current: {current_score:.1f})', 'priority': 'MEDIUM'}\n    else:\n        return {'symbol': symbol, 'action': 'CONTINUE_HOLDING', 'reason': 'Quality acceptable but declining', 'priority': 'LOW'}"
    },
    {
      "name": "_build_monitoring_prompt",
      "line": 224,
      "code": "def _build_monitoring_prompt(self, positions: List[Dict], quality_scores: Dict[str, float], alerts: List[Dict], memory_context: str) -> str:\n    \"\"\"Build LLM prompt for quality monitoring.\"\"\"\n    positions_summary = ''\n    for pos in positions:\n        symbol = pos.get('symbol', '')\n        qty = pos.get('quantity', 0.0)\n        price = pos.get('current_price', 0.0)\n        value = qty * price\n        quality = quality_scores.get(symbol, 0.0)\n        positions_summary += f'- {symbol}: {qty:.2f} shares @ ${price:.2f} = ${value:,.2f} (Quality: {quality:.1f}/100)\\n'\n    alerts_summary = ''\n    if alerts:\n        for alert in alerts:\n            alerts_summary += f\"- {alert['message']} (Severity: {alert['severity']})\\n\"\n    else:\n        alerts_summary = 'No quality alerts'\n    prompt = f'You are a Quality Monitor Agent reviewing portfolio quality.\\n\\nPORTFOLIO POSITIONS:\\n{positions_summary}\\n\\nQUALITY ALERTS:\\n{alerts_summary}\\n\\n{memory_context}\\n\\nTASK: Provide quality monitoring assessment:\\n1. Overall Portfolio Quality (1-10, where 10 is highest quality)\\n2. Quality Trend (IMPROVING / STABLE / DECLINING)\\n3. Risk Assessment (LOW / MEDIUM / HIGH)\\n4. Recommendations (what actions to take)\\n5. Priority Actions (most important actions first)\\n\\nFormat your response as:\\nPORTFOLIO_QUALITY: [1-10]\\nQUALITY_TREND: [IMPROVING/STABLE/DECLINING]\\nRISK_LEVEL: [LOW/MEDIUM/HIGH]\\nRECOMMENDATIONS: [your recommendations]\\nPRIORITY_ACTIONS: [priority actions]'\n    return prompt"
    },
    {
      "name": "_combine_monitoring_analysis",
      "line": 279,
      "code": "def _combine_monitoring_analysis(self, quality_scores: Dict[str, float], alerts: List[Dict], recommendations: List[Dict], llm_response: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Combine monitoring data with LLM insights.\"\"\"\n    llm_analysis = self._parse_llm_response(llm_response.get('reasoning', ''))\n    avg_quality = sum(quality_scores.values()) / len(quality_scores) if quality_scores else 0.0\n    analysis = {'action': 'MONITOR' if not alerts else 'ALERT', 'portfolio_quality': avg_quality, 'quality_scores': quality_scores, 'alerts': alerts, 'recommendations': recommendations, 'quality_trend': llm_analysis.get('quality_trend', 'STABLE'), 'risk_level': llm_analysis.get('risk_level', 'MEDIUM'), 'llm_recommendations': llm_analysis.get('recommendations', ''), 'priority_actions': llm_analysis.get('priority_actions', ''), 'full_reasoning': llm_response.get('reasoning', ''), 'timestamp': datetime.now().isoformat()}\n    return analysis"
    },
    {
      "name": "_parse_llm_response",
      "line": 313,
      "code": "def _parse_llm_response(self, reasoning: str) -> Dict[str, Any]:\n    \"\"\"Parse LLM response.\"\"\"\n    lines = reasoning.split('\\n')\n    analysis = {'portfolio_quality': 5, 'quality_trend': 'STABLE', 'risk_level': 'MEDIUM', 'recommendations': '', 'priority_actions': ''}\n    for line in lines:\n        line = line.strip()\n        if line.startswith('PORTFOLIO_QUALITY:'):\n            try:\n                analysis['portfolio_quality'] = int(line.split(':')[1].strip())\n            except:\n                pass\n        elif line.startswith('QUALITY_TREND:'):\n            trend = line.split(':')[1].strip().upper()\n            if trend in ['IMPROVING', 'STABLE', 'DECLINING']:\n                analysis['quality_trend'] = trend\n        elif line.startswith('RISK_LEVEL:'):\n            risk = line.split(':')[1].strip().upper()\n            if risk in ['LOW', 'MEDIUM', 'HIGH']:\n                analysis['risk_level'] = risk\n        elif line.startswith('RECOMMENDATIONS:'):\n            analysis['recommendations'] = line.split(':', 1)[1].strip()\n        elif line.startswith('PRIORITY_ACTIONS:'):\n            analysis['priority_actions'] = line.split(':', 1)[1].strip()\n    return analysis"
    }
  ]
}
