{
  "dead_imports": [],
  "commented_blocks": [],
  "empty_functions": [],
  "unused_variables": [],
  "all_functions": [
    {
      "name": "retry_with_backoff",
      "line": 15,
      "code": "def retry_with_backoff(max_retries: int=3, initial_delay: float=1.0, backoff_factor: float=2.0, exceptions: Tuple[Type[Exception], ...]=(Exception,)):\n    \"\"\"\n    Decorator for retrying functions with exponential backoff.\n\n    Args:\n        max_retries: Maximum number of retry attempts\n        initial_delay: Initial delay in seconds\n        backoff_factor: Multiplier for delay after each retry\n        exceptions: Tuple of exception types to catch and retry\n\n    Returns:\n        Decorated function with retry logic\n\n    Example:\n        @retry_with_backoff(max_retries=3, initial_delay=1.0)\n        def fetch_data():\n            return api.get_data()\n    \"\"\"\n\n    def decorator(func: Callable) -> Callable:\n\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            delay = initial_delay\n            for attempt in range(max_retries):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    if attempt == max_retries - 1:\n                        logger.error(f'{func.__name__} failed after {max_retries} attempts: {e}')\n                        raise\n                    logger.warning(f'{func.__name__} attempt {attempt + 1}/{max_retries} failed: {e}. Retrying in {delay:.1f}s...')\n                    time.sleep(delay)\n                    delay *= backoff_factor\n            return func(*args, **kwargs)\n        return wrapper\n    return decorator"
    },
    {
      "name": "decorator",
      "line": 39,
      "code": "def decorator(func: Callable) -> Callable:\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        delay = initial_delay\n        for attempt in range(max_retries):\n            try:\n                return func(*args, **kwargs)\n            except exceptions as e:\n                if attempt == max_retries - 1:\n                    logger.error(f'{func.__name__} failed after {max_retries} attempts: {e}')\n                    raise\n                logger.warning(f'{func.__name__} attempt {attempt + 1}/{max_retries} failed: {e}. Retrying in {delay:.1f}s...')\n                time.sleep(delay)\n                delay *= backoff_factor\n        return func(*args, **kwargs)\n    return wrapper"
    },
    {
      "name": "wrapper",
      "line": 41,
      "code": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    delay = initial_delay\n    for attempt in range(max_retries):\n        try:\n            return func(*args, **kwargs)\n        except exceptions as e:\n            if attempt == max_retries - 1:\n                logger.error(f'{func.__name__} failed after {max_retries} attempts: {e}')\n                raise\n            logger.warning(f'{func.__name__} attempt {attempt + 1}/{max_retries} failed: {e}. Retrying in {delay:.1f}s...')\n            time.sleep(delay)\n            delay *= backoff_factor\n    return func(*args, **kwargs)"
    }
  ]
}
