{
  "dead_imports": [
    {
      "line": 12,
      "module": "timedelta",
      "statement": "from datetime import datetime, timedelta"
    },
    {
      "line": 14,
      "module": "field",
      "statement": "from dataclasses import dataclass, field"
    }
  ],
  "commented_blocks": [],
  "empty_functions": [],
  "unused_variables": [
    {
      "line": 22,
      "variable": "HEALTHY"
    },
    {
      "line": 23,
      "variable": "DEGRADED"
    },
    {
      "line": 24,
      "variable": "FAILING"
    },
    {
      "line": 25,
      "variable": "UNKNOWN"
    }
  ],
  "all_functions": [
    {
      "name": "success_rate",
      "line": 45,
      "code": "@property\ndef success_rate(self) -> float:\n    \"\"\"Calculate success rate percentage.\"\"\"\n    if self.total_checks == 0:\n        return 0.0\n    return self.successful_checks / self.total_checks * 100.0"
    },
    {
      "name": "is_healthy",
      "line": 52,
      "code": "@property\ndef is_healthy(self) -> bool:\n    \"\"\"Determine if broker is healthy.\"\"\"\n    if self.status == BrokerStatus.HEALTHY:\n        return True\n    if self.status == BrokerStatus.DEGRADED and self.consecutive_failures < 3:\n        return True\n    return False"
    },
    {
      "name": "__init__",
      "line": 68,
      "code": "def __init__(self, broker_name: str='alpaca'):\n    self.broker_name = broker_name.lower()\n    self.metrics = BrokerHealthMetrics(broker_name=self.broker_name, status=BrokerStatus.UNKNOWN)\n    self._health_log_file = os.path.join(os.getenv('MARKET_DATA_CACHE_DIR', 'data/cache'), f'{self.broker_name}_health.jsonl')"
    },
    {
      "name": "check_health",
      "line": 76,
      "code": "def check_health(self) -> BrokerHealthMetrics:\n    \"\"\"\n        Perform comprehensive health check.\n        \n        Returns:\n            BrokerHealthMetrics with current status\n        \"\"\"\n    import time\n    start_time = time.time()\n    try:\n        from src.core.alpaca_trader import AlpacaTrader\n        trader = AlpacaTrader(paper=True)\n        account_info = trader.get_account_info()\n        elapsed_ms = (time.time() - start_time) * 1000\n        self.metrics.last_successful_connection = datetime.now()\n        self.metrics.total_checks += 1\n        self.metrics.successful_checks += 1\n        self.metrics.avg_response_time_ms = (self.metrics.avg_response_time_ms * (self.metrics.total_checks - 1) + elapsed_ms) / self.metrics.total_checks\n        self.metrics.consecutive_failures = 0\n        self.metrics.account_status = account_info.get('status', 'UNKNOWN')\n        self.metrics.buying_power = account_info.get('buying_power', 0.0)\n        self.metrics.last_error = None\n        if account_info.get('status') == 'ACTIVE' and (not account_info.get('trading_blocked', False)):\n            self.metrics.status = BrokerStatus.HEALTHY\n        elif account_info.get('trading_blocked', False):\n            self.metrics.status = BrokerStatus.DEGRADED\n            self.metrics.last_error = 'Trading blocked'\n        else:\n            self.metrics.status = BrokerStatus.DEGRADED\n            self.metrics.last_error = f\"Account status: {account_info.get('status')}\"\n        self._log_health_check(success=True, response_time_ms=elapsed_ms)\n        logger.info(f'\u2705 Broker health check passed: {self.broker_name} (status: {self.metrics.status.value}, response: {elapsed_ms:.2f}ms)')\n    except Exception as e:\n        elapsed_ms = (time.time() - start_time) * 1000\n        self.metrics.last_failed_connection = datetime.now()\n        self.metrics.total_checks += 1\n        self.metrics.failed_checks += 1\n        self.metrics.consecutive_failures += 1\n        self.metrics.last_error = str(e)\n        self.metrics.status = BrokerStatus.FAILING\n        self._log_health_check(success=False, response_time_ms=elapsed_ms, error=str(e))\n        logger.error(f'\u274c Broker health check failed: {self.broker_name} (consecutive failures: {self.metrics.consecutive_failures}, error: {str(e)})')\n    return self.metrics"
    },
    {
      "name": "_log_health_check",
      "line": 148,
      "code": "def _log_health_check(self, success: bool, response_time_ms: float, error: Optional[str]=None):\n    \"\"\"Log health check result to file.\"\"\"\n    import json\n    from pathlib import Path\n    log_entry = {'timestamp': datetime.now().isoformat(), 'broker': self.broker_name, 'success': success, 'response_time_ms': round(response_time_ms, 2), 'status': self.metrics.status.value, 'consecutive_failures': self.metrics.consecutive_failures, 'error': error, 'account_status': self.metrics.account_status, 'buying_power': self.metrics.buying_power}\n    log_file = Path(self._health_log_file)\n    log_file.parent.mkdir(parents=True, exist_ok=True)\n    with open(log_file, 'a') as f:\n        f.write(json.dumps(log_entry) + '\\n')"
    },
    {
      "name": "get_health_summary",
      "line": 171,
      "code": "def get_health_summary(self) -> Dict[str, Any]:\n    \"\"\"Get formatted health summary.\"\"\"\n    return {'broker': self.broker_name, 'status': self.metrics.status.value, 'is_healthy': self.metrics.is_healthy, 'success_rate': round(self.metrics.success_rate, 2), 'total_checks': self.metrics.total_checks, 'successful_checks': self.metrics.successful_checks, 'failed_checks': self.metrics.failed_checks, 'consecutive_failures': self.metrics.consecutive_failures, 'avg_response_time_ms': round(self.metrics.avg_response_time_ms, 2), 'last_successful_connection': self.metrics.last_successful_connection.isoformat() if self.metrics.last_successful_connection else None, 'last_failed_connection': self.metrics.last_failed_connection.isoformat() if self.metrics.last_failed_connection else None, 'last_error': self.metrics.last_error, 'account_status': self.metrics.account_status, 'buying_power': self.metrics.buying_power}"
    },
    {
      "name": "should_alert",
      "line": 196,
      "code": "def should_alert(self) -> bool:\n    \"\"\"Determine if alert should be sent.\"\"\"\n    if self.metrics.consecutive_failures >= 3:\n        return True\n    if self.metrics.status == BrokerStatus.FAILING:\n        return True\n    if self.metrics.total_checks >= 10 and self.metrics.success_rate < 50.0:\n        return True\n    return False"
    },
    {
      "name": "get_alert_message",
      "line": 212,
      "code": "def get_alert_message(self) -> Optional[str]:\n    \"\"\"Generate alert message if needed.\"\"\"\n    if not self.should_alert():\n        return None\n    if self.metrics.consecutive_failures >= 3:\n        return f'\ud83d\udea8 CRITICAL: Broker {self.broker_name} has failed {self.metrics.consecutive_failures} consecutive health checks.\\nLast error: {self.metrics.last_error}\\nTrading execution may be blocked.'\n    if self.metrics.status == BrokerStatus.FAILING:\n        return f'\u26a0\ufe0f WARNING: Broker {self.broker_name} is in FAILING status.\\nSuccess rate: {self.metrics.success_rate:.1f}%\\nLast error: {self.metrics.last_error}'\n    return None"
    }
  ]
}
