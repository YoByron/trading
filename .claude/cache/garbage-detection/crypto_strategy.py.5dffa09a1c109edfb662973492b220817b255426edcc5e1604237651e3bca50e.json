{
  "dead_imports": [],
  "commented_blocks": [],
  "empty_functions": [],
  "unused_variables": [
    {
      "line": 52,
      "variable": "VERY_BULLISH"
    },
    {
      "line": 53,
      "variable": "BULLISH"
    },
    {
      "line": 54,
      "variable": "NEUTRAL"
    },
    {
      "line": 55,
      "variable": "BEARISH"
    },
    {
      "line": 56,
      "variable": "VERY_BEARISH"
    },
    {
      "line": 115,
      "variable": "DEFAULT_CRYPTO_UNIVERSE"
    },
    {
      "line": 118,
      "variable": "RSI_PERIOD"
    },
    {
      "line": 119,
      "variable": "RSI_OVERSOLD"
    },
    {
      "line": 120,
      "variable": "RSI_OVERBOUGHT"
    },
    {
      "line": 123,
      "variable": "MACD_FAST_PERIOD"
    },
    {
      "line": 124,
      "variable": "MACD_SLOW_PERIOD"
    },
    {
      "line": 125,
      "variable": "MACD_SIGNAL_PERIOD"
    },
    {
      "line": 129,
      "variable": "MAX_POSITION_PCT"
    },
    {
      "line": 132,
      "variable": "LOOKBACK_1WEEK"
    },
    {
      "line": 133,
      "variable": "LOOKBACK_1MONTH"
    },
    {
      "line": 134,
      "variable": "LOOKBACK_3MONTH"
    },
    {
      "line": 137,
      "variable": "MOMENTUM_WEIGHTS"
    }
  ],
  "all_functions": [
    {
      "name": "__init__",
      "line": 143,
      "code": "def __init__(self, trader=None, risk_manager=None, daily_amount: Optional[float]=None, crypto_universe: Optional[List[str]]=None, stop_loss_pct: float=DEFAULT_STOP_LOSS_PCT):\n    \"\"\"\n        Initialize the Crypto Strategy.\n\n        Args:\n            trader: AlpacaTrader instance (optional, will create if None)\n            risk_manager: RiskManager instance (optional, will create if None)\n            daily_amount: Daily investment amount in dollars (default: from env or $0.50)\n            crypto_universe: List of crypto symbols (default: BTCUSD, ETHUSD)\n            stop_loss_pct: Stop-loss percentage (default: 7%)\n\n        Raises:\n            ValueError: If daily_amount is non-positive\n        \"\"\"\n    if daily_amount is None:\n        daily_amount = float(os.getenv('CRYPTO_DAILY_AMOUNT', '0.50'))\n    if daily_amount <= 0:\n        raise ValueError(f'daily_amount must be positive, got {daily_amount}')\n    self.daily_amount = daily_amount\n    self.crypto_universe = crypto_universe or self.DEFAULT_CRYPTO_UNIVERSE\n    self.stop_loss_pct = stop_loss_pct\n    self.current_holdings: Dict[str, float] = {}\n    self.total_invested: float = 0.0\n    self.total_value: float = 0.0\n    self.daily_returns: List[float] = []\n    self.trades_executed: List[CryptoOrder] = []\n    self.score_history: List[CryptoScore] = []\n    try:\n        self.trader = trader or AlpacaTrader(paper=True)\n        self.risk_manager = risk_manager or RiskManager(max_daily_loss_pct=2.0, max_position_size_pct=self.MAX_POSITION_PCT * 100, max_drawdown_pct=15.0, max_consecutive_losses=3)\n        logger.info('Successfully initialized crypto dependencies')\n    except Exception as e:\n        logger.warning(f'Failed to initialize some dependencies: {e}')\n        self.trader = None\n        self.risk_manager = None\n    self.newsletter = None\n    if NEWSLETTER_AVAILABLE:\n        try:\n            self.newsletter = NewsletterAnalyzer()\n            logger.info('NewsletterAnalyzer initialized - will validate trades against CoinSnacks')\n        except Exception as e:\n            logger.warning(f'Failed to initialize NewsletterAnalyzer: {e}')\n            self.newsletter = None\n    logger.info(f'CryptoStrategy initialized: daily_amount=${daily_amount}, crypto_universe={self.crypto_universe}, stop_loss={stop_loss_pct * 100}%')"
    },
    {
      "name": "execute",
      "line": 218,
      "code": "def execute(self) -> Dict:\n    \"\"\"\n        Execute the crypto trading routine (compatible with autonomous_trader.py interface).\n\n        Returns:\n            Dict with execution results\n        \"\"\"\n    logger.info('=' * 70)\n    logger.info('CRYPTO STRATEGY - Daily Execution')\n    logger.info('=' * 70)\n    try:\n        order = self.execute_daily()\n        if order:\n            return {'success': True, 'symbol': order.symbol, 'amount': order.amount, 'quantity': order.quantity, 'price': order.price, 'reason': order.reason}\n        else:\n            return {'success': False, 'reason': 'no_valid_trades', 'message': 'No valid crypto opportunities today'}\n    except Exception as e:\n        logger.error(f'Crypto strategy execution failed: {e}')\n        import traceback\n        traceback.print_exc()\n        return {'success': False, 'reason': 'error', 'error': str(e)}"
    },
    {
      "name": "execute_daily",
      "line": 256,
      "code": "def execute_daily(self) -> Optional[CryptoOrder]:\n    \"\"\"\n        Execute the daily crypto trading routine.\n\n        This is the main entry point that orchestrates:\n        1. Analyze all coins in universe\n        2. Calculate momentum scores\n        3. Select best coin\n        4. Execute order if valid\n        5. Risk management\n\n        Returns:\n            CryptoOrder if an order was placed, None otherwise\n\n        Raises:\n            Exception: If critical trading error occurs\n        \"\"\"\n    logger.info('=' * 80)\n    logger.info('Starting daily crypto strategy execution')\n    logger.info(f'Timestamp: {datetime.now().isoformat()}')\n    logger.info(f'Daily allocation: ${self.daily_amount}')\n    try:\n        scores = self._calculate_all_scores()\n        if not scores:\n            logger.warning('No valid crypto opportunities today')\n            return None\n        best_coin = self.select_crypto()\n        if not best_coin:\n            logger.warning('No crypto selected - all failed filters')\n            return None\n        logger.info(f'Selected crypto (algorithm): {best_coin}')\n        validation = self.get_newsletter_validation(best_coin)\n        if validation['available']:\n            logger.info(f\"Newsletter Validation: Our pick={best_coin}, CoinSnacks pick={validation['newsletter_pick']}, Agreement={validation['agreement']}\")\n            if not validation['agreement']:\n                logger.warning(f\"CONFLICT: Our algorithm picked {best_coin} but CoinSnacks recommends {validation['newsletter_pick']}. Reasoning: {validation['reasoning']}\")\n            else:\n                logger.info(f\"AGREEMENT: CoinSnacks also recommends {best_coin}. Confidence boost: +{validation['confidence_boost']}\")\n        else:\n            logger.info(f\"Newsletter validation not available: {validation['reasoning']}\")\n        current_price = self._get_current_price(best_coin)\n        if current_price is None:\n            logger.error(f'Failed to get price for {best_coin}')\n            return None\n        quantity = self.daily_amount / current_price\n        if not self._validate_trade(best_coin, quantity, current_price):\n            logger.warning('Trade failed risk validation')\n            return None\n        order = self._create_buy_order(symbol=best_coin, quantity=quantity, price=current_price)\n        if self.trader:\n            try:\n                executed_order = self.trader.execute_order(symbol=best_coin, amount_usd=self.daily_amount, side='buy', tier='CRYPTO')\n                logger.info(f\"Alpaca order executed: {executed_order['id']}\")\n                if order.stop_loss:\n                    self.trader.set_stop_loss(symbol=best_coin, qty=quantity, stop_price=order.stop_loss)\n                    logger.info(f'Stop-loss set at ${order.stop_loss:.2f}')\n            except Exception as e:\n                logger.error(f'Failed to execute order via Alpaca: {e}')\n                return None\n        self._update_holdings(best_coin, quantity)\n        self.total_invested += self.daily_amount\n        self.trades_executed.append(order)\n        logger.info(f'Order executed successfully: {order}')\n        logger.info(f'Total invested to date: ${self.total_invested:.2f}')\n        return order\n    except Exception as e:\n        logger.error(f'Error in daily execution: {str(e)}', exc_info=True)\n        raise"
    },
    {
      "name": "get_newsletter_validation",
      "line": 377,
      "code": "def get_newsletter_validation(self, our_pick: str) -> Dict:\n    \"\"\"\n        Fetch CoinSnacks recommendation and compare to our pick.\n\n        Args:\n            our_pick: The crypto symbol our algorithm selected (e.g., \"BTCUSD\")\n\n        Returns:\n            Dictionary with:\n            - newsletter_pick: str or None (CoinSnacks recommendation)\n            - agreement: bool (whether picks match)\n            - confidence_boost: int (+10 or -10 points)\n            - reasoning: str (CoinSnacks reasoning if available)\n            - available: bool (whether newsletter data was available)\n        \"\"\"\n    if not self.newsletter:\n        return {'newsletter_pick': None, 'agreement': None, 'confidence_boost': 0, 'reasoning': 'Newsletter analyzer not available', 'available': False}\n    try:\n        signals = self.newsletter.get_latest_signals()\n        if not signals or 'recommended_coin' not in signals:\n            logger.warning('No CoinSnacks signals available')\n            return {'newsletter_pick': None, 'agreement': None, 'confidence_boost': 0, 'reasoning': 'No CoinSnacks data available', 'available': False}\n        newsletter_pick = signals.get('recommended_coin')\n        our_coin = our_pick.replace('USD', '')\n        newsletter_coin = newsletter_pick.replace('USD', '') if newsletter_pick else None\n        agreement = our_coin == newsletter_coin if newsletter_coin else False\n        boost = 10 if agreement else -10\n        return {'newsletter_pick': newsletter_pick, 'agreement': agreement, 'confidence_boost': boost, 'reasoning': signals.get('reasoning', 'No reasoning provided'), 'available': True}\n    except Exception as e:\n        logger.error(f'Error validating against newsletter: {e}')\n        return {'newsletter_pick': None, 'agreement': None, 'confidence_boost': 0, 'reasoning': f'Error: {str(e)}', 'available': False}"
    },
    {
      "name": "select_crypto",
      "line": 444,
      "code": "def select_crypto(self) -> Optional[str]:\n    \"\"\"\n        Select the crypto with the highest momentum score.\n\n        Returns:\n            Symbol of the best crypto to purchase, or None if none qualify\n\n        Raises:\n            ValueError: If no valid crypto can be selected\n        \"\"\"\n    logger.info('Selecting best crypto from universe')\n    scores = self._calculate_all_scores()\n    if not scores:\n        logger.warning('No valid crypto opportunities - all failed hard filters')\n        return None\n    scores.sort(key=lambda x: x.score, reverse=True)\n    logger.info('Crypto Rankings:')\n    for i, score in enumerate(scores, 1):\n        logger.info(f'  {i}. {score.symbol}: {score.score:.2f} (RSI: {score.rsi:.1f}, MACD: {score.macd_histogram:.4f})')\n    best_crypto = scores[0].symbol\n    logger.info(f'Best crypto selected: {best_crypto} with score {scores[0].score:.2f}')\n    return best_crypto"
    },
    {
      "name": "analyze_coin",
      "line": 481,
      "code": "def analyze_coin(self, symbol: str) -> Dict:\n    \"\"\"\n        Analyze a single crypto coin and return scoring metrics.\n\n        Args:\n            symbol: Crypto symbol (e.g., \"BTCUSD\", \"ETHUSD\")\n\n        Returns:\n            Dictionary containing:\n            - score: Composite momentum score (0-100)\n            - signals: Technical indicator signals\n            - metrics: Raw technical metrics\n\n        Raises:\n            ValueError: If unable to analyze symbol\n        \"\"\"\n    logger.info(f'Analyzing {symbol}')\n    try:\n        hist = self._get_historical_data(symbol)\n        if hist is None or hist.empty:\n            raise ValueError(f'Unable to fetch data for {symbol}')\n        returns_1w = self._calculate_period_return(hist, self.LOOKBACK_1WEEK)\n        returns_1m = self._calculate_period_return(hist, self.LOOKBACK_1MONTH)\n        returns_3m = self._calculate_period_return(hist, self.LOOKBACK_3MONTH)\n        daily_returns = hist['Close'].pct_change().dropna()\n        volatility = daily_returns.std() * np.sqrt(252)\n        risk_free_rate = 0.04\n        excess_return = returns_3m - risk_free_rate\n        sharpe_ratio = excess_return / volatility if volatility > 0 else 0\n        rsi = self._calculate_rsi(hist['Close'], self.RSI_PERIOD)\n        macd_value, macd_signal, macd_histogram = self._calculate_macd(hist['Close'])\n        volume_ratio = self._calculate_volume_ratio(hist)\n        score = self._calculate_score(returns_1w=returns_1w, returns_1m=returns_1m, returns_3m=returns_3m, volatility=volatility, sharpe_ratio=sharpe_ratio, rsi=rsi, macd_histogram=macd_histogram, volume_ratio=volume_ratio)\n        signals = {'momentum': 'bullish' if returns_1m > 0 else 'bearish', 'rsi': self._classify_rsi(rsi), 'macd': 'bullish' if macd_histogram > 0 else 'bearish', 'volume': 'high' if volume_ratio > 1.2 else 'normal' if volume_ratio > 0.8 else 'low'}\n        metrics = {'returns_1w': returns_1w, 'returns_1m': returns_1m, 'returns_3m': returns_3m, 'volatility': volatility, 'sharpe_ratio': sharpe_ratio, 'rsi': rsi, 'macd_value': macd_value, 'macd_signal': macd_signal, 'macd_histogram': macd_histogram, 'volume_ratio': volume_ratio}\n        result = {'score': score, 'signals': signals, 'metrics': metrics}\n        logger.info(f'{symbol} analysis: score={score:.2f}, RSI={rsi:.1f}, MACD={macd_histogram:.4f}, volume_ratio={volume_ratio:.2f}')\n        return result\n    except Exception as e:\n        logger.error(f'Error analyzing {symbol}: {e}')\n        raise ValueError(f'Failed to analyze {symbol}') from e"
    },
    {
      "name": "get_performance_metrics",
      "line": 579,
      "code": "def get_performance_metrics(self) -> Dict:\n    \"\"\"\n        Calculate comprehensive performance metrics for the strategy.\n\n        Returns:\n            Dictionary containing performance statistics\n        \"\"\"\n    logger.info('Calculating crypto performance metrics')\n    current_value = self._calculate_total_portfolio_value()\n    total_return = current_value - self.total_invested\n    total_return_pct = total_return / self.total_invested * 100 if self.total_invested > 0 else 0.0\n    if len(self.daily_returns) > 1:\n        mean_return = np.mean(self.daily_returns)\n        std_return = np.std(self.daily_returns)\n        risk_free_rate_daily = 0.04 / 252\n        sharpe_ratio = (mean_return - risk_free_rate_daily) / std_return * np.sqrt(252) if std_return > 0 else 0.0\n    else:\n        sharpe_ratio = 0.0\n    positive_days = sum((1 for r in self.daily_returns if r > 0))\n    win_rate = positive_days / len(self.daily_returns) * 100 if self.daily_returns else 0.0\n    num_trades = len(self.trades_executed)\n    average_trade_size = sum((trade.amount for trade in self.trades_executed)) / num_trades if num_trades > 0 else 0.0\n    metrics = {'total_invested': self.total_invested, 'current_value': current_value, 'total_return': total_return, 'total_return_pct': total_return_pct, 'sharpe_ratio': sharpe_ratio, 'win_rate': win_rate, 'num_trades': num_trades, 'average_trade_size': average_trade_size, 'current_holdings': self.current_holdings.copy()}\n    logger.info('Crypto Performance Summary:')\n    logger.info(f\"  Total Invested: ${metrics['total_invested']:.2f}\")\n    logger.info(f\"  Current Value: ${metrics['current_value']:.2f}\")\n    logger.info(f\"  Total Return: ${metrics['total_return']:.2f} ({metrics['total_return_pct']:.2f}%)\")\n    logger.info(f\"  Sharpe Ratio: {metrics['sharpe_ratio']:.2f}\")\n    logger.info(f\"  Win Rate: {metrics['win_rate']:.1f}%\")\n    logger.info(f\"  Number of Trades: {metrics['num_trades']}\")\n    return metrics"
    },
    {
      "name": "_calculate_all_scores",
      "line": 655,
      "code": "def _calculate_all_scores(self) -> List[CryptoScore]:\n    \"\"\"Calculate scores for all coins in universe.\"\"\"\n    scores = []\n    for symbol in self.crypto_universe:\n        try:\n            hist = self._get_historical_data(symbol)\n            if hist is None or hist.empty:\n                logger.warning(f'{symbol}: Unable to fetch data')\n                continue\n            returns_1w = self._calculate_period_return(hist, self.LOOKBACK_1WEEK)\n            returns_1m = self._calculate_period_return(hist, self.LOOKBACK_1MONTH)\n            returns_3m = self._calculate_period_return(hist, self.LOOKBACK_3MONTH)\n            daily_returns = hist['Close'].pct_change().dropna()\n            volatility = daily_returns.std() * np.sqrt(252)\n            risk_free_rate = 0.04\n            excess_return = returns_3m - risk_free_rate\n            sharpe_ratio = excess_return / volatility if volatility > 0 else 0\n            rsi = self._calculate_rsi(hist['Close'], self.RSI_PERIOD)\n            macd_value, macd_signal, macd_histogram = self._calculate_macd(hist['Close'])\n            volume_ratio = self._calculate_volume_ratio(hist)\n            if macd_histogram < 0:\n                logger.warning(f'{symbol} REJECTED - Bearish MACD histogram ({macd_histogram:.4f})')\n                continue\n            if rsi > self.RSI_OVERBOUGHT:\n                logger.warning(f'{symbol} REJECTED - Overbought RSI ({rsi:.2f} > {self.RSI_OVERBOUGHT})')\n                continue\n            if volume_ratio < 1.0:\n                logger.warning(f'{symbol} REJECTED - Low volume ({volume_ratio:.2f} < 1.0)')\n                continue\n            score = self._calculate_score(returns_1w=returns_1w, returns_1m=returns_1m, returns_3m=returns_3m, volatility=volatility, sharpe_ratio=sharpe_ratio, rsi=rsi, macd_histogram=macd_histogram, volume_ratio=volume_ratio)\n            score_obj = CryptoScore(symbol=symbol, score=score, returns_1w=returns_1w, returns_1m=returns_1m, returns_3m=returns_3m, volatility=volatility, sharpe_ratio=sharpe_ratio, rsi=rsi, macd_value=macd_value, macd_signal=macd_signal, macd_histogram=macd_histogram, volume_ratio=volume_ratio, timestamp=datetime.now())\n            scores.append(score_obj)\n            self.score_history.append(score_obj)\n        except Exception as e:\n            logger.error(f'Failed to calculate score for {symbol}: {e}')\n            continue\n    return scores"
    },
    {
      "name": "_calculate_score",
      "line": 744,
      "code": "def _calculate_score(self, returns_1w: float, returns_1m: float, returns_3m: float, volatility: float, sharpe_ratio: float, rsi: float, macd_histogram: float, volume_ratio: float) -> float:\n    \"\"\"Calculate composite momentum score (0-100).\"\"\"\n    momentum_score = returns_1w * self.MOMENTUM_WEIGHTS['1week'] * 100 + returns_1m * self.MOMENTUM_WEIGHTS['1month'] * 100 + returns_3m * self.MOMENTUM_WEIGHTS['3month'] * 100\n    volatility_penalty = volatility * 5\n    momentum_score -= volatility_penalty\n    sharpe_bonus = sharpe_ratio * 3\n    momentum_score += sharpe_bonus\n    if self.RSI_OVERSOLD < rsi < self.RSI_OVERBOUGHT:\n        momentum_score += 5\n    if macd_histogram > 0:\n        momentum_score += 10\n    if volume_ratio > 1.5:\n        momentum_score += 12\n    elif volume_ratio > 1.2:\n        momentum_score += 8\n    return max(0, min(100, momentum_score))"
    },
    {
      "name": "_get_historical_data",
      "line": 790,
      "code": "def _get_historical_data(self, symbol: str) -> Optional[pd.DataFrame]:\n    \"\"\"Fetch historical data for crypto symbol.\"\"\"\n    try:\n        yf_symbol = symbol.replace('USD', '-USD')\n        lookback_days = self.LOOKBACK_3MONTH + 30\n        end_date = datetime.now()\n        start_date = end_date - timedelta(days=lookback_days)\n        ticker = yf.Ticker(yf_symbol)\n        hist = ticker.history(start=start_date, end=end_date)\n        if hist.empty or len(hist) < self.LOOKBACK_3MONTH * 0.7:\n            logger.warning(f'Insufficient data for {symbol} (got {len(hist)} bars)')\n            return None\n        return hist\n    except Exception as e:\n        logger.error(f'Error fetching data for {symbol}: {e}')\n        return None"
    },
    {
      "name": "_get_current_price",
      "line": 814,
      "code": "def _get_current_price(self, symbol: str) -> Optional[float]:\n    \"\"\"Get current market price for crypto symbol.\"\"\"\n    try:\n        yf_symbol = symbol.replace('USD', '-USD')\n        ticker = yf.Ticker(yf_symbol)\n        data = ticker.history(period='1d')\n        if not data.empty:\n            return float(data['Close'].iloc[-1])\n        return None\n    except Exception as e:\n        logger.error(f'Error fetching price for {symbol}: {e}')\n        return None"
    },
    {
      "name": "_calculate_period_return",
      "line": 827,
      "code": "def _calculate_period_return(self, hist: pd.DataFrame, periods: int) -> float:\n    \"\"\"Calculate return over specified number of periods.\"\"\"\n    if len(hist) < periods:\n        periods = len(hist) - 1\n    if periods <= 0:\n        return 0.0\n    end_price = hist['Close'].iloc[-1]\n    start_price = hist['Close'].iloc[-periods]\n    return (end_price - start_price) / start_price"
    },
    {
      "name": "_calculate_rsi",
      "line": 840,
      "code": "def _calculate_rsi(self, prices: pd.Series, period: int=14) -> float:\n    \"\"\"Calculate Relative Strength Index (RSI).\"\"\"\n    delta = prices.diff()\n    gain = delta.where(delta > 0, 0).rolling(window=period).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()\n    rs = gain / loss\n    rsi = 100 - 100 / (1 + rs)\n    return float(rsi.iloc[-1]) if not pd.isna(rsi.iloc[-1]) else 50.0"
    },
    {
      "name": "_calculate_macd",
      "line": 851,
      "code": "def _calculate_macd(self, prices: pd.Series) -> Tuple[float, float, float]:\n    \"\"\"Calculate MACD (Moving Average Convergence Divergence).\"\"\"\n    from src.utils.technical_indicators import calculate_macd\n    return calculate_macd(prices, fast_period=self.MACD_FAST_PERIOD, slow_period=self.MACD_SLOW_PERIOD, signal_period=self.MACD_SIGNAL_PERIOD)"
    },
    {
      "name": "_calculate_volume_ratio",
      "line": 862,
      "code": "def _calculate_volume_ratio(self, hist: pd.DataFrame) -> float:\n    \"\"\"Calculate volume ratio (current vs 20-day average).\"\"\"\n    from src.utils.technical_indicators import calculate_volume_ratio\n    return calculate_volume_ratio(hist, window=20)"
    },
    {
      "name": "_classify_rsi",
      "line": 868,
      "code": "def _classify_rsi(self, rsi: float) -> str:\n    \"\"\"Classify RSI value.\"\"\"\n    if rsi < self.RSI_OVERSOLD:\n        return 'oversold'\n    elif rsi > self.RSI_OVERBOUGHT:\n        return 'overbought'\n    else:\n        return 'neutral'"
    },
    {
      "name": "_validate_trade",
      "line": 877,
      "code": "def _validate_trade(self, symbol: str, quantity: float, price: float) -> bool:\n    \"\"\"Validate trade against risk management rules.\"\"\"\n    trade_value = quantity * price\n    if trade_value > self.daily_amount * 1.1:\n        logger.warning(f'Trade value ${trade_value:.2f} exceeds daily allocation')\n        return False\n    if self.risk_manager:\n        try:\n            account_value = self._calculate_total_portfolio_value() + self.total_invested\n            if account_value == 0:\n                account_value = 10000.0\n            validation = self.risk_manager.validate_trade(symbol=symbol, amount=trade_value, sentiment_score=0.0, account_value=account_value, trade_type='BUY')\n            if not validation['valid']:\n                logger.warning(f\"Risk manager rejected trade: {validation['reason']}\")\n                return False\n            if validation['warnings']:\n                for warning in validation['warnings']:\n                    logger.warning(f'Risk manager warning: {warning}')\n            return True\n        except Exception as e:\n            logger.error(f'Error in risk validation: {e}')\n    return True"
    },
    {
      "name": "_create_buy_order",
      "line": 921,
      "code": "def _create_buy_order(self, symbol: str, quantity: float, price: float) -> CryptoOrder:\n    \"\"\"Create a buy order with stop-loss.\"\"\"\n    amount = quantity * price\n    stop_loss_price = price * (1 - self.stop_loss_pct)\n    return CryptoOrder(symbol=symbol, action='buy', quantity=quantity, amount=amount, price=price, order_type='market', stop_loss=stop_loss_price, timestamp=datetime.now(), reason=f'Daily crypto purchase - best momentum coin')"
    },
    {
      "name": "_update_holdings",
      "line": 943,
      "code": "def _update_holdings(self, symbol: str, quantity: float) -> None:\n    \"\"\"Update current holdings after trade.\"\"\"\n    self.current_holdings[symbol] = self.current_holdings.get(symbol, 0.0) + quantity\n    if self.current_holdings[symbol] <= 0:\n        self.current_holdings.pop(symbol, None)"
    },
    {
      "name": "_calculate_total_portfolio_value",
      "line": 953,
      "code": "def _calculate_total_portfolio_value(self) -> float:\n    \"\"\"Calculate total current value of all holdings.\"\"\"\n    total = 0.0\n    for symbol, quantity in self.current_holdings.items():\n        price = self._get_current_price(symbol)\n        if price:\n            total += quantity * price\n    return total"
    }
  ]
}
