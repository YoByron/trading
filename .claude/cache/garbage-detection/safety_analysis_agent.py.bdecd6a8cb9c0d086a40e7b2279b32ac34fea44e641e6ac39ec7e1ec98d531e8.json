{
  "dead_imports": [
    {
      "line": 15,
      "module": "Optional",
      "statement": "from typing import Dict, Any, Optional"
    },
    {
      "line": 17,
      "module": "GrahamBuffettSafety",
      "statement": "from src.safety.graham_buffett_safety import ("
    }
  ],
  "commented_blocks": [],
  "empty_functions": [],
  "unused_variables": [
    {
      "line": 106,
      "variable": "margin_info"
    }
  ],
  "all_functions": [
    {
      "name": "__init__",
      "line": 37,
      "code": "def __init__(self, min_margin_of_safety: float=0.2):\n    super().__init__(name='SafetyAnalysisAgent', role='Graham-Buffett investment safety analysis')\n    self.safety_analyzer = get_global_safety_analyzer()\n    self.min_margin_of_safety = min_margin_of_safety"
    },
    {
      "name": "analyze",
      "line": 45,
      "code": "def analyze(self, data: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"\n        Analyze investment opportunity using Graham-Buffett principles.\n        \n        Args:\n            data: Contains symbol, market_price, and optional context\n            \n        Returns:\n            Safety analysis with rating, margin of safety, quality score, and recommendation\n        \"\"\"\n    symbol = data.get('symbol', 'UNKNOWN')\n    market_price = data.get('market_price', 0.0)\n    force_refresh = data.get('force_refresh', False)\n    if market_price <= 0:\n        return {'action': 'REJECT', 'reason': 'Invalid market price', 'safety_rating': SafetyRating.REJECT.value, 'confidence': 0.0}\n    try:\n        safety_analysis = self.safety_analyzer.analyze_safety(symbol=symbol, market_price=market_price, force_refresh=force_refresh)\n        memory_context = self.get_memory_context(limit=5)\n        prompt = self._build_analysis_prompt(safety_analysis, memory_context)\n        llm_response = self.reason_with_llm(prompt)\n        analysis = self._combine_analysis(safety_analysis, llm_response)\n        self.log_decision(analysis)\n        return analysis\n    except Exception as e:\n        logger.error(f'Safety analysis error for {symbol}: {e}')\n        return {'action': 'REJECT', 'reason': f'Safety analysis failed: {str(e)}', 'safety_rating': SafetyRating.REJECT.value, 'confidence': 0.0}"
    },
    {
      "name": "_build_analysis_prompt",
      "line": 101,
      "code": "def _build_analysis_prompt(self, safety_analysis: Any, memory_context: str) -> str:\n    \"\"\"Build LLM prompt for safety analysis reasoning.\"\"\"\n    margin_info = ''\n    if safety_analysis.margin_of_safety_pct is not None:\n        margin_info = f'\\nMARGIN OF SAFETY: {safety_analysis.margin_of_safety_pct * 100:.1f}%\\n- Intrinsic Value: ${safety_analysis.intrinsic_value:.2f}\\n- Market Price: ${safety_analysis.market_price:.2f}\\n- Required Minimum: {self.min_margin_of_safety * 100:.1f}%\\n'\n    else:\n        margin_info = 'MARGIN OF SAFETY: Unable to calculate (DCF unavailable)'\n    quality_info = ''\n    if safety_analysis.quality:\n        q = safety_analysis.quality\n        quality_info = f\"\\nQUALITY METRICS:\\n- Quality Score: {q.quality_score:.1f}/100\\n- Debt-to-Equity: {(q.debt_to_equity if q.debt_to_equity else 'N/A')}\\n- Current Ratio: {(q.current_ratio if q.current_ratio else 'N/A')}\\n- ROE: {(q.roe * 100 if q.roe else 'N/A')}%\\n- ROA: {(q.roa * 100 if q.roa else 'N/A')}%\\n- Profit Margin: {(q.profit_margin * 100 if q.profit_margin else 'N/A')}%\\n- Earnings Growth (3Y): {(q.earnings_growth_3y * 100 if q.earnings_growth_3y else 'N/A')}%\\n- Earnings Consistency: {q.earnings_consistency:.2f}\\n\"\n    else:\n        quality_info = 'QUALITY METRICS: Unable to calculate'\n    prompt = f\"You are a Safety Analysis Agent evaluating {safety_analysis.symbol} using Graham-Buffett investment principles.\\n\\n{safety_analysis.symbol} SAFETY ANALYSIS:\\n{safety_info}\\n{quality_info}\\n\\nSAFETY RATING: {safety_analysis.safety_rating.value.upper()}\\n\\nREASONS:\\n{chr(10).join((f'- {r}' for r in safety_analysis.reasons))}\\n\\nWARNINGS:\\n{(chr(10).join((f'- {w}' for w in safety_analysis.warnings)) if safety_analysis.warnings else 'None')}\\n\\n{memory_context}\\n\\nTASK: Provide comprehensive safety assessment:\\n1. Safety Assessment (1-10, where 10 is safest)\\n2. Margin of Safety Evaluation (EXCELLENT / GOOD / ADEQUATE / POOR / NONE)\\n3. Quality Evaluation (EXCELLENT / GOOD / ADEQUATE / POOR)\\n4. Overall Recommendation: APPROVE / REJECT\\n5. Confidence (0-1)\\n6. Key Safety Factors (what makes this safe/unsafe)\\n7. Risk Factors (what could go wrong)\\n8. Investment Thesis (2-3 sentences on why this is/isn't a good investment)\\n\\nFormat your response as:\\nSAFETY_SCORE: [1-10]\\nMARGIN_EVAL: [EXCELLENT/GOOD/ADEQUATE/POOR/NONE]\\nQUALITY_EVAL: [EXCELLENT/GOOD/ADEQUATE/POOR]\\nRECOMMENDATION: [APPROVE/REJECT]\\nCONFIDENCE: [0-1]\\nSAFETY_FACTORS: [key safety factors]\\nRISK_FACTORS: [risk factors]\\nTHESIS: [investment thesis]\"\n    return prompt"
    },
    {
      "name": "_combine_analysis",
      "line": 172,
      "code": "def _combine_analysis(self, safety_analysis: Any, llm_response: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Combine safety analysis with LLM insights.\"\"\"\n    llm_analysis = self._parse_llm_response(llm_response.get('reasoning', ''))\n    should_approve = safety_analysis.safety_rating in [SafetyRating.EXCELLENT, SafetyRating.GOOD, SafetyRating.ACCEPTABLE]\n    action = 'APPROVE' if should_approve else 'REJECT'\n    analysis = {'symbol': safety_analysis.symbol, 'market_price': safety_analysis.market_price, 'intrinsic_value': safety_analysis.intrinsic_value, 'margin_of_safety_pct': safety_analysis.margin_of_safety_pct, 'quality_score': safety_analysis.quality.quality_score if safety_analysis.quality else None, 'safety_rating': safety_analysis.safety_rating.value, 'action': action, 'confidence': llm_analysis.get('confidence', 0.5), 'safety_score': llm_analysis.get('safety_score', 5), 'margin_eval': llm_analysis.get('margin_eval', 'NONE'), 'quality_eval': llm_analysis.get('quality_eval', 'POOR'), 'safety_factors': llm_analysis.get('safety_factors', ''), 'risk_factors': llm_analysis.get('risk_factors', ''), 'thesis': llm_analysis.get('thesis', ''), 'reasons': safety_analysis.reasons, 'warnings': safety_analysis.warnings, 'full_reasoning': llm_response.get('reasoning', ''), 'timestamp': safety_analysis.timestamp.isoformat()}\n    return analysis"
    },
    {
      "name": "_parse_llm_response",
      "line": 217,
      "code": "def _parse_llm_response(self, reasoning: str) -> Dict[str, Any]:\n    \"\"\"Parse LLM response into structured format.\"\"\"\n    lines = reasoning.split('\\n')\n    analysis = {'safety_score': 5, 'margin_eval': 'NONE', 'quality_eval': 'POOR', 'recommendation': 'REJECT', 'confidence': 0.5, 'safety_factors': '', 'risk_factors': '', 'thesis': ''}\n    for line in lines:\n        line = line.strip()\n        if line.startswith('SAFETY_SCORE:'):\n            try:\n                analysis['safety_score'] = int(line.split(':')[1].strip())\n            except:\n                pass\n        elif line.startswith('MARGIN_EVAL:'):\n            eval_str = line.split(':')[1].strip().upper()\n            if eval_str in ['EXCELLENT', 'GOOD', 'ADEQUATE', 'POOR', 'NONE']:\n                analysis['margin_eval'] = eval_str\n        elif line.startswith('QUALITY_EVAL:'):\n            eval_str = line.split(':')[1].strip().upper()\n            if eval_str in ['EXCELLENT', 'GOOD', 'ADEQUATE', 'POOR']:\n                analysis['quality_eval'] = eval_str\n        elif line.startswith('RECOMMENDATION:'):\n            rec = line.split(':')[1].strip().upper()\n            if rec in ['APPROVE', 'REJECT']:\n                analysis['recommendation'] = rec\n        elif line.startswith('CONFIDENCE:'):\n            try:\n                analysis['confidence'] = float(line.split(':')[1].strip())\n            except:\n                pass\n        elif line.startswith('SAFETY_FACTORS:'):\n            analysis['safety_factors'] = line.split(':', 1)[1].strip()\n        elif line.startswith('RISK_FACTORS:'):\n            analysis['risk_factors'] = line.split(':', 1)[1].strip()\n        elif line.startswith('THESIS:'):\n            analysis['thesis'] = line.split(':', 1)[1].strip()\n    return analysis"
    }
  ]
}
