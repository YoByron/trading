{
  "dead_imports": [
    {
      "line": 9,
      "module": "annotations",
      "statement": "from __future__ import annotations"
    },
    {
      "line": 18,
      "module": "time",
      "statement": "import time"
    }
  ],
  "commented_blocks": [],
  "empty_functions": [],
  "unused_variables": [
    {
      "line": 81,
      "variable": "OVERVIEW_ENDPOINT"
    },
    {
      "line": 82,
      "variable": "CASH_FLOW_ENDPOINT"
    },
    {
      "line": 85,
      "variable": "POLYGON_BASE_URL"
    }
  ],
  "all_functions": [
    {
      "name": "get_global_dcf_calculator",
      "line": 515,
      "code": "def get_global_dcf_calculator() -> DCFValuationCalculator:\n    global _GLOBAL_DCF_CALCULATOR\n    if _GLOBAL_DCF_CALCULATOR is None:\n        _GLOBAL_DCF_CALCULATOR = DCFValuationCalculator()\n    return _GLOBAL_DCF_CALCULATOR"
    },
    {
      "name": "to_json",
      "line": 47,
      "code": "def to_json(self) -> Dict:\n    return {'intrinsic_value': self.intrinsic_value, 'discount_rate': self.discount_rate, 'terminal_growth': self.terminal_growth, 'projected_growth': self.projected_growth, 'timestamp': self.timestamp.isoformat()}"
    },
    {
      "name": "from_json",
      "line": 57,
      "code": "@classmethod\ndef from_json(cls, data: Dict) -> 'DCFResult':\n    return cls(intrinsic_value=float(data['intrinsic_value']), discount_rate=float(data['discount_rate']), terminal_growth=float(data['terminal_growth']), projected_growth=float(data['projected_growth']), timestamp=datetime.fromisoformat(data['timestamp']))"
    },
    {
      "name": "__init__",
      "line": 87,
      "code": "def __init__(self, api_key: Optional[str]=None, cache_dir: Optional[Path]=None, cache_ttl_hours: int=DEFAULT_CACHE_TTL_HOURS) -> None:\n    self.polygon_api_key = os.getenv('POLYGON_API_KEY')\n    self.api_key = api_key or os.getenv('ALPHA_VANTAGE_API_KEY')\n    if not self.polygon_api_key and (not self.api_key):\n        logger.warning('Neither POLYGON_API_KEY nor ALPHA_VANTAGE_API_KEY set. DCF valuations will be unavailable.')\n    elif self.polygon_api_key:\n        logger.info('Using Polygon.io API for DCF valuations (preferred)')\n    elif self.api_key:\n        logger.info('Using Alpha Vantage API for DCF valuations (fallback)')\n    self.cache_dir = cache_dir or Path('data/cache/dcf')\n    self.cache_dir.mkdir(parents=True, exist_ok=True)\n    self.cache_ttl = timedelta(hours=cache_ttl_hours)\n    self._session_cache: Dict[str, DCFResult] = {}"
    },
    {
      "name": "get_intrinsic_value",
      "line": 116,
      "code": "def get_intrinsic_value(self, ticker: str, force_refresh: bool=False) -> Optional[DCFResult]:\n    \"\"\"\n        Return cached or freshly computed DCF valuation for a ticker.\n\n        Args:\n            ticker: Equity ticker symbol\n            force_refresh: Skip cache and recompute\n\n        Returns:\n            DCFResult if successful, otherwise None.\n        \"\"\"\n    ticker = ticker.upper().strip()\n    if not ticker:\n        return None\n    if not self.polygon_api_key and (not self.api_key):\n        logger.debug('Skipping DCF valuation for %s (no API key)', ticker)\n        return None\n    if not force_refresh:\n        cached = self._load_from_cache(ticker)\n        if cached:\n            return cached\n    try:\n        if self.polygon_api_key:\n            overview = self._fetch_polygon_overview(ticker)\n            cash_flows = self._fetch_polygon_cash_flows(ticker)\n        else:\n            overview = self._fetch_company_overview(ticker)\n            cash_flows = self._fetch_cash_flows(ticker)\n        dcf_result = self._compute_dcf(ticker, overview, cash_flows)\n        self._store_in_cache(ticker, dcf_result)\n        return dcf_result\n    except DCFError as exc:\n        if self.polygon_api_key and self.api_key:\n            logger.info('Polygon.io failed for %s, trying Alpha Vantage fallback: %s', ticker, exc)\n            try:\n                overview = self._fetch_company_overview(ticker)\n                cash_flows = self._fetch_cash_flows(ticker)\n                dcf_result = self._compute_dcf(ticker, overview, cash_flows)\n                self._store_in_cache(ticker, dcf_result)\n                return dcf_result\n            except Exception as fallback_exc:\n                logger.warning('DCF valuation unavailable for %s (both Polygon.io and Alpha Vantage failed): %s', ticker, fallback_exc)\n        else:\n            logger.warning('DCF valuation unavailable for %s: %s', ticker, exc)\n    except Exception as exc:\n        logger.error('Unexpected error computing DCF for %s: %s', ticker, exc, exc_info=True)\n    return None"
    },
    {
      "name": "calculate_margin_of_safety",
      "line": 183,
      "code": "def calculate_margin_of_safety(self, ticker: str, market_price: float) -> Optional[float]:\n    \"\"\"\n        Compute margin of safety given a market price.\n\n        Returns:\n            Margin of safety as a decimal (e.g. 0.2 == 20% discount) or None.\n        \"\"\"\n    if market_price <= 0:\n        return None\n    result = self.get_intrinsic_value(ticker)\n    if not result or result.intrinsic_value <= 0:\n        return None\n    return (result.intrinsic_value - market_price) / result.intrinsic_value"
    },
    {
      "name": "_load_from_cache",
      "line": 204,
      "code": "def _load_from_cache(self, ticker: str) -> Optional[DCFResult]:\n    if ticker in self._session_cache:\n        cached = self._session_cache[ticker]\n        if datetime.utcnow() - cached.timestamp <= self.cache_ttl:\n            return cached\n    cache_file = self.cache_dir / f'{ticker}.json'\n    if not cache_file.exists():\n        return None\n    try:\n        with cache_file.open('r', encoding='utf-8') as f:\n            payload = json.load(f)\n        result = DCFResult.from_json(payload)\n        if datetime.utcnow() - result.timestamp > self.cache_ttl:\n            return None\n        self._session_cache[ticker] = result\n        return result\n    except Exception as exc:\n        logger.debug('Failed to load cached DCF for %s: %s', ticker, exc)\n        return None"
    },
    {
      "name": "_store_in_cache",
      "line": 229,
      "code": "def _store_in_cache(self, ticker: str, result: DCFResult) -> None:\n    self._session_cache[ticker] = result\n    cache_file = self.cache_dir / f'{ticker}.json'\n    try:\n        with cache_file.open('w', encoding='utf-8') as f:\n            json.dump(result.to_json(), f, indent=2)\n    except Exception as exc:\n        logger.debug('Failed to persist DCF cache for %s: %s', ticker, exc)"
    },
    {
      "name": "_fetch_polygon_overview",
      "line": 238,
      "code": "def _fetch_polygon_overview(self, ticker: str) -> Dict:\n    \"\"\"Fetch company overview from Polygon.io.\"\"\"\n    url = f'https://api.polygon.io/v3/reference/tickers/{ticker}'\n    params = {'apiKey': self.polygon_api_key}\n    try:\n        response = requests.get(url, params=params, timeout=30)\n        response.raise_for_status()\n        data = response.json()\n        if data.get('status') != 'OK':\n            raise DCFError(f\"Polygon.io API error: {data.get('error', 'Unknown error')}\")\n        result = data.get('results', {})\n        if not result:\n            raise DCFError('Polygon.io overview unavailable - no results')\n        shares_outstanding = result.get('share_class_shares_outstanding') or result.get('weighted_shares_outstanding', 0)\n        market_cap = result.get('market_cap', 0)\n        overview = {'Symbol': result.get('ticker', ticker), 'Beta': '1.0', 'SharesOutstanding': str(int(shares_outstanding)) if shares_outstanding else '0', 'MarketCapitalization': str(int(market_cap)) if market_cap else '0', 'Name': result.get('name', '')}\n        return overview\n    except requests.RequestException as exc:\n        raise DCFError(f'Polygon.io HTTP error: {exc}') from exc\n    except (ValueError, KeyError) as exc:\n        raise DCFError('Invalid Polygon.io JSON response') from exc"
    },
    {
      "name": "_fetch_polygon_cash_flows",
      "line": 281,
      "code": "def _fetch_polygon_cash_flows(self, ticker: str) -> Dict:\n    \"\"\"\n        Fetch cash flow statements from Polygon.io.\n\n        Note: Polygon.io Starter plan may not include financials endpoint.\n        This will raise DCFError to trigger Alpha Vantage fallback.\n        \"\"\"\n    url = f'https://api.polygon.io/v2/reference/financials'\n    params = {'ticker': ticker, 'apiKey': self.polygon_api_key, 'timeframe': 'annual', 'filing_date.gte': '2015-01-01'}\n    try:\n        response = requests.get(url, params=params, timeout=30)\n        response.raise_for_status()\n        data = response.json()\n        if data.get('status') != 'OK':\n            error_msg = data.get('error', 'Unknown error')\n            if 'access' in error_msg.lower() or 'permission' in error_msg.lower():\n                raise DCFError('Polygon.io financials endpoint requires higher tier plan - using Alpha Vantage fallback')\n            raise DCFError(f'Polygon.io API error: {error_msg}')\n        results = data.get('results', [])\n        if not results:\n            raise DCFError('No cash flow data from Polygon.io - using Alpha Vantage fallback')\n        annual_reports = []\n        for result in results:\n            financials = result.get('financials', {})\n            cash_flow = financials.get('cash_flow_statement', {})\n            operating_cf = None\n            capex = None\n            for item in cash_flow.get('financials', []):\n                label = item.get('label', '').lower()\n                value = item.get('value')\n                if 'operating' in label and 'cash' in label and ('flow' in label):\n                    operating_cf = value\n                elif 'capital' in label and 'expenditure' in label:\n                    capex = value\n            if operating_cf is not None:\n                annual_reports.append({'fiscalDateEnding': result.get('filing_date', ''), 'operatingCashflow': str(operating_cf) if operating_cf else '0', 'capitalExpenditures': str(capex) if capex else '0'})\n        if not annual_reports:\n            raise DCFError('No cash flow reports from Polygon.io - using Alpha Vantage fallback')\n        return {'annualReports': annual_reports}\n    except requests.RequestException as exc:\n        raise DCFError(f'Polygon.io HTTP error (will use Alpha Vantage fallback): {exc}') from exc\n    except (ValueError, KeyError) as exc:\n        raise DCFError('Invalid Polygon.io JSON response - using Alpha Vantage fallback') from exc"
    },
    {
      "name": "_fetch_company_overview",
      "line": 364,
      "code": "def _fetch_company_overview(self, ticker: str) -> Dict:\n    \"\"\"Fetch company overview from Alpha Vantage (fallback).\"\"\"\n    url = self.OVERVIEW_ENDPOINT.format(ticker=ticker, api_key=self.api_key)\n    data = self._perform_request(url)\n    if not data or 'Symbol' not in data:\n        raise DCFError('Company overview unavailable')\n    return data"
    },
    {
      "name": "_fetch_cash_flows",
      "line": 373,
      "code": "def _fetch_cash_flows(self, ticker: str) -> Dict:\n    \"\"\"Fetch cash flows from Alpha Vantage (fallback).\"\"\"\n    url = self.CASH_FLOW_ENDPOINT.format(ticker=ticker, api_key=self.api_key)\n    data = self._perform_request(url)\n    reports = data.get('annualReports')\n    if not reports:\n        raise DCFError('Cash flow reports missing')\n    return reports"
    },
    {
      "name": "_perform_request",
      "line": 383,
      "code": "def _perform_request(self, url: str) -> Dict:\n    try:\n        response = requests.get(url, timeout=30)\n        response.raise_for_status()\n        data = response.json()\n        if 'Note' in data or 'Information' in data:\n            raise DCFError(data.get('Note') or data.get('Information') or 'API limit reached')\n        return data\n    except requests.RequestException as exc:\n        raise DCFError(f'HTTP error: {exc}') from exc\n    except ValueError as exc:\n        raise DCFError('Invalid JSON response') from exc"
    },
    {
      "name": "_compute_dcf",
      "line": 399,
      "code": "def _compute_dcf(self, ticker: str, overview: Dict, cash_reports: Dict) -> DCFResult:\n    free_cash_flows = self._extract_free_cash_flows(cash_reports)\n    if len(free_cash_flows) < 2:\n        raise DCFError('Insufficient FCF history')\n    latest_fcf = free_cash_flows[0]\n    if latest_fcf <= 0:\n        raise DCFError('Negative free cash flow')\n    growth_rate = self._estimate_growth(free_cash_flows)\n    discount_rate = self._estimate_discount_rate(overview)\n    shares_outstanding = self._parse_float(overview.get('SharesOutstanding'))\n    if not shares_outstanding or shares_outstanding <= 0:\n        raise DCFError('Shares outstanding unavailable')\n    intrinsic_value = self._discount_cash_flows(latest_fcf=latest_fcf, growth_rate=growth_rate, discount_rate=discount_rate, shares_outstanding=shares_outstanding)\n    return DCFResult(intrinsic_value=intrinsic_value, discount_rate=discount_rate, terminal_growth=DEFAULT_TERMINAL_GROWTH, projected_growth=growth_rate, timestamp=datetime.utcnow())"
    },
    {
      "name": "_extract_free_cash_flows",
      "line": 435,
      "code": "def _extract_free_cash_flows(self, cash_reports: Dict) -> Tuple[float, ...]:\n    fcfs = []\n    for report in cash_reports:\n        operating_cf = self._parse_float(report.get('operatingCashflow'))\n        capex = self._parse_float(report.get('capitalExpenditures'))\n        if operating_cf is None or capex is None:\n            continue\n        fcfs.append(operating_cf - capex)\n    if not fcfs:\n        raise DCFError('Unable to compute free cash flow')\n    return tuple(fcfs)"
    },
    {
      "name": "_estimate_growth",
      "line": 447,
      "code": "def _estimate_growth(self, fcfs: Tuple[float, ...]) -> float:\n    if len(fcfs) < 2:\n        return 0.0\n    latest = fcfs[0]\n    oldest_index = min(len(fcfs) - 1, 3)\n    oldest = fcfs[oldest_index]\n    if oldest <= 0 or latest <= 0:\n        return 0.0\n    years = oldest_index\n    cagr = (latest / oldest) ** (1 / years) - 1 if years > 0 else 0.0\n    return max(-0.15, min(0.3, cagr))"
    },
    {
      "name": "_estimate_discount_rate",
      "line": 463,
      "code": "def _estimate_discount_rate(self, overview: Dict) -> float:\n    beta = self._parse_float(overview.get('Beta'), default=1.0)\n    discount = DEFAULT_RISK_FREE_RATE + beta * DEFAULT_EQUITY_RISK_PREMIUM\n    return max(MIN_DISCOUNT_RATE, min(MAX_DISCOUNT_RATE, discount))"
    },
    {
      "name": "_discount_cash_flows",
      "line": 468,
      "code": "def _discount_cash_flows(self, latest_fcf: float, growth_rate: float, discount_rate: float, shares_outstanding: float, projection_years: int=5) -> float:\n    projected_fcfs = []\n    fcf = latest_fcf\n    for year in range(1, projection_years + 1):\n        fcf *= 1 + growth_rate\n        discounted = fcf / (1 + discount_rate) ** year\n        projected_fcfs.append(discounted)\n    terminal_value = projected_fcfs[-1] * (1 + DEFAULT_TERMINAL_GROWTH) / (discount_rate - DEFAULT_TERMINAL_GROWTH) if discount_rate > DEFAULT_TERMINAL_GROWTH else 0.0\n    discounted_terminal = terminal_value / (1 + discount_rate) ** projection_years\n    equity_value = sum(projected_fcfs) + discounted_terminal\n    intrinsic_value = equity_value / shares_outstanding\n    return intrinsic_value"
    },
    {
      "name": "_parse_float",
      "line": 497,
      "code": "@staticmethod\ndef _parse_float(value: Optional[str], default: Optional[float]=None) -> Optional[float]:\n    if value in (None, '', 'None'):\n        return default\n    try:\n        return float(value)\n    except (TypeError, ValueError):\n        try:\n            return float(value.replace(',', ''))\n        except Exception:\n            return default"
    }
  ]
}
