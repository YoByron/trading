{
  "dead_imports": [
    {
      "line": 50,
      "module": "GrahamBuffettSafety",
      "statement": "from src.safety.graham_buffett_safety import ("
    }
  ],
  "commented_blocks": [],
  "empty_functions": [],
  "unused_variables": [
    {
      "line": 69,
      "variable": "VERY_BULLISH"
    },
    {
      "line": 70,
      "variable": "BULLISH"
    },
    {
      "line": 71,
      "variable": "NEUTRAL"
    },
    {
      "line": 72,
      "variable": "BEARISH"
    },
    {
      "line": 73,
      "variable": "VERY_BEARISH"
    },
    {
      "line": 135,
      "variable": "DEFAULT_ETF_UNIVERSE"
    },
    {
      "line": 138,
      "variable": "LOOKBACK_PERIODS"
    },
    {
      "line": 141,
      "variable": "MOMENTUM_WEIGHTS"
    },
    {
      "line": 148,
      "variable": "RSI_PERIOD"
    },
    {
      "line": 149,
      "variable": "RSI_OVERSOLD"
    },
    {
      "line": 150,
      "variable": "RSI_OVERBOUGHT"
    },
    {
      "line": 153,
      "variable": "MACD_FAST_PERIOD"
    },
    {
      "line": 154,
      "variable": "MACD_SLOW_PERIOD"
    },
    {
      "line": 155,
      "variable": "MACD_SIGNAL_PERIOD"
    },
    {
      "line": 159,
      "variable": "ATR_STOP_MULTIPLIER"
    },
    {
      "line": 160,
      "variable": "USE_ATR_STOPS"
    },
    {
      "line": 161,
      "variable": "REBALANCE_THRESHOLD"
    },
    {
      "line": 162,
      "variable": "REBALANCE_FREQUENCY_DAYS"
    }
  ],
  "all_functions": [
    {
      "name": "__init__",
      "line": 164,
      "code": "def __init__(self, daily_allocation: float=6.0, etf_universe: Optional[List[str]]=None, stop_loss_pct: float=DEFAULT_STOP_LOSS_PCT, use_sentiment: bool=True):\n    \"\"\"\n        Initialize the Core Strategy.\n\n        Args:\n            daily_allocation: Daily investment amount in dollars (default: $6)\n            etf_universe: List of ETF symbols to analyze (default: SPY, QQQ, VOO)\n            stop_loss_pct: Trailing stop-loss percentage (default: 5%)\n            use_sentiment: Whether to use AI sentiment analysis (default: True)\n\n        Raises:\n            ValueError: If daily_allocation is non-positive\n        \"\"\"\n    if daily_allocation <= 0:\n        raise ValueError(f'daily_allocation must be positive, got {daily_allocation}')\n    self.daily_allocation = daily_allocation\n    self.etf_universe = etf_universe or self.DEFAULT_ETF_UNIVERSE\n    self.stop_loss_pct = stop_loss_pct\n    self.use_sentiment = use_sentiment\n    self.current_holdings: Dict[str, float] = {}\n    self.last_rebalance_date: Optional[datetime] = None\n    self.total_invested: float = 0.0\n    self.total_value: float = 0.0\n    self.use_graham_buffett_safety = os.getenv('USE_GRAHAM_BUFFETT_SAFETY', 'true').lower() == 'true'\n    self.safety_analyzer = get_global_safety_analyzer() if self.use_graham_buffett_safety else None\n    self.daily_returns: List[float] = []\n    self.trades_executed: List[TradeOrder] = []\n    self.momentum_history: List[MomentumScore] = []\n    try:\n        self.llm_analyzer = MultiLLMAnalyzer(use_async=False) if use_sentiment else None\n        self.alpaca_trader = AlpacaTrader(paper=True)\n        self.risk_manager = RiskManager(max_daily_loss_pct=2.0, max_position_size_pct=20.0, max_drawdown_pct=10.0, max_consecutive_losses=5)\n        logger.info('Successfully initialized core dependencies')\n    except Exception as e:\n        logger.warning(f'Failed to initialize some dependencies: {e}')\n        self.llm_analyzer = None\n        self.alpaca_trader = None\n        self.risk_manager = None\n    logger.info(f'CoreStrategy initialized: daily_allocation=${daily_allocation}, etf_universe={self.etf_universe}, stop_loss={stop_loss_pct * 100}%')"
    },
    {
      "name": "execute_daily",
      "line": 236,
      "code": "def execute_daily(self) -> Optional[TradeOrder]:\n    \"\"\"\n        Execute the daily trading routine.\n\n        This is the main entry point that orchestrates:\n        1. Market sentiment analysis\n        2. Momentum calculation\n        3. ETF selection\n        4. Order execution\n        5. Risk management\n\n        Returns:\n            TradeOrder if an order was placed, None otherwise\n\n        Raises:\n            Exception: If critical trading error occurs\n        \"\"\"\n    logger.info('=' * 80)\n    logger.info('Starting daily strategy execution')\n    logger.info(f'Timestamp: {datetime.now().isoformat()}')\n    logger.info(f'Daily allocation: ${self.daily_allocation}')\n    try:\n        sentiment = self._get_market_sentiment()\n        logger.info(f'Market sentiment: {sentiment.value}')\n        if sentiment == MarketSentiment.VERY_BEARISH:\n            logger.warning('Very bearish sentiment detected - pausing new purchases')\n            return None\n        momentum_scores = self._calculate_all_momentum_scores(sentiment)\n        try:\n            best_etf = self.select_best_etf(momentum_scores)\n            logger.info(f'Selected ETF: {best_etf}')\n        except ValueError as e:\n            logger.warning(f'No valid ETF selection today: {e}')\n            logger.info('SKIPPING TRADE - Will try again tomorrow')\n            return None\n        if self.gemini3_enabled and self._gemini3_integration and self._gemini3_integration.enabled:\n            try:\n                logger.info('Validating trade with Gemini 3 AI...')\n                market_context = {'symbol': best_etf, 'sentiment': sentiment.value, 'momentum_scores': {ms.symbol: ms.score for ms in momentum_scores}, 'timestamp': datetime.now().isoformat()}\n                gemini_recommendation = self._gemini3_integration.get_trading_recommendation(symbol=best_etf, market_context=market_context, thinking_level='high')\n                if gemini_recommendation.get('decision'):\n                    decision = gemini_recommendation['decision']\n                    action = decision.get('action', 'HOLD')\n                    confidence = decision.get('confidence', 0.0)\n                    if action != 'BUY' or confidence < 0.6:\n                        logger.warning(f'Gemini 3 AI rejected trade: {action} (confidence: {confidence:.2f})')\n                        logger.info(f\"Gemini reasoning: {decision.get('reasoning', 'N/A')}\")\n                        logger.info('SKIPPING TRADE - AI validation failed')\n                        return None\n                    else:\n                        logger.info(f'Gemini 3 AI approved trade: {action} (confidence: {confidence:.2f})')\n            except Exception as e:\n                logger.warning(f'Gemini 3 validation error (proceeding): {e}')\n        current_price = self._get_current_price(best_etf)\n        if current_price is None:\n            logger.error(f'Failed to get price for {best_etf}')\n            return None\n        if self.use_graham_buffett_safety and self.safety_analyzer:\n            try:\n                should_buy, safety_analysis = self.safety_analyzer.should_buy(symbol=best_etf, market_price=current_price, force_refresh=False)\n                if not should_buy:\n                    logger.warning(f'\ud83d\udea8 {best_etf} REJECTED by Graham-Buffett Safety Module')\n                    logger.warning(f'   Safety Rating: {safety_analysis.safety_rating.value}')\n                    for reason in safety_analysis.reasons:\n                        logger.warning(f'   Reason: {reason}')\n                    for warning in safety_analysis.warnings:\n                        logger.warning(f'   Warning: {warning}')\n                    if safety_analysis.margin_of_safety_pct is not None:\n                        logger.info(f'   Margin of Safety: {safety_analysis.margin_of_safety_pct * 100:.1f}% (required: {self.safety_analyzer.min_margin_of_safety * 100:.1f}%)')\n                    if safety_analysis.quality:\n                        logger.info(f'   Quality Score: {safety_analysis.quality.quality_score:.1f}/100')\n                    logger.info('SKIPPING TRADE - Failed Graham-Buffett safety check')\n                    return None\n                else:\n                    logger.info(f'\u2705 {best_etf} PASSED Graham-Buffett Safety Check (Rating: {safety_analysis.safety_rating.value})')\n                    if safety_analysis.margin_of_safety_pct is not None:\n                        logger.info(f'   Margin of Safety: {safety_analysis.margin_of_safety_pct * 100:.1f}%')\n                    if safety_analysis.quality:\n                        logger.info(f'   Quality Score: {safety_analysis.quality.quality_score:.1f}/100')\n            except Exception as e:\n                logger.warning(f'Error in Graham-Buffett safety check (proceeding): {e}')\n        quantity = self.daily_allocation / current_price\n        if not self._validate_trade(best_etf, quantity, current_price, sentiment):\n            logger.warning('Trade failed risk validation')\n            return None\n        order = self._create_buy_order(symbol=best_etf, quantity=quantity, price=current_price, sentiment=sentiment)\n        if self.alpaca_trader:\n            try:\n                executed_order = self.alpaca_trader.execute_order(symbol=best_etf, amount_usd=self.daily_allocation, side='buy', tier='T1_CORE')\n                logger.info(f\"Alpaca order executed: {executed_order['id']}\")\n                if order.stop_loss:\n                    self.alpaca_trader.set_stop_loss(symbol=best_etf, qty=quantity, stop_price=order.stop_loss)\n                    logger.info(f'Stop-loss set at ${order.stop_loss:.2f}')\n            except Exception as e:\n                logger.error(f'Failed to execute order via Alpaca: {e}')\n                return None\n        self._update_holdings(best_etf, quantity)\n        self.total_invested += self.daily_allocation\n        self.trades_executed.append(order)\n        logger.info(f'Order executed successfully: {order}')\n        logger.info(f'Total invested to date: ${self.total_invested:.2f}')\n        if self.should_rebalance():\n            logger.info('Rebalancing required - will execute after market close')\n        return order\n    except Exception as e:\n        logger.error(f'Error in daily execution: {str(e)}', exc_info=True)\n        raise"
    },
    {
      "name": "calculate_momentum",
      "line": 443,
      "code": "def calculate_momentum(self, symbol: str) -> float:\n    \"\"\"\n        Calculate composite momentum score for a given ETF.\n\n        The momentum score is a weighted combination of:\n        - Multi-period returns (1m, 3m, 6m)\n        - Volatility-adjusted performance\n        - Sharpe ratio\n        - RSI indicator\n        - Risk-adjusted metrics\n\n        Args:\n            symbol: ETF ticker symbol\n\n        Returns:\n            Composite momentum score (0-100 scale)\n\n        Raises:\n            ValueError: If unable to calculate momentum for symbol\n        \"\"\"\n    logger.info(f'Calculating momentum for {symbol}')\n    hist = None\n    lookback_days = max(self.LOOKBACK_PERIODS.values()) + 20\n    end_date = datetime.now()\n    start_date = end_date - timedelta(days=lookback_days)\n    try:\n        ticker = yf.Ticker(symbol)\n        hist = ticker.history(start=start_date, end=end_date)\n        if hist.empty or len(hist) < lookback_days * 0.7:\n            logger.warning(f'yfinance returned insufficient data for {symbol}, trying Alpaca API')\n            hist = None\n    except Exception as e:\n        logger.warning(f'yfinance failed for {symbol}: {str(e)}, trying Alpaca API fallback')\n        hist = None\n    if hist is None or hist.empty:\n        try:\n            if self.alpaca_trader:\n                logger.info(f'Fetching historical data from Alpaca for {symbol}')\n                bars = self.alpaca_trader.get_historical_bars(symbol=symbol, timeframe='1Day', limit=lookback_days)\n                if bars and len(bars) >= lookback_days * 0.7:\n                    import pandas as pd\n                    dates = [pd.Timestamp(bar['timestamp']) for bar in bars]\n                    hist = pd.DataFrame({'Open': [bar['open'] for bar in bars], 'High': [bar['high'] for bar in bars], 'Low': [bar['low'] for bar in bars], 'Close': [bar['close'] for bar in bars], 'Volume': [bar['volume'] for bar in bars]}, index=dates)\n                    hist.index.name = 'Date'\n                    hist.sort_index(inplace=True)\n                    logger.info(f'Successfully loaded {len(hist)} bars from Alpaca for {symbol}')\n                else:\n                    raise ValueError(f'Alpaca returned insufficient data for {symbol}')\n            else:\n                raise ValueError(f'No Alpaca trader available and yfinance failed for {symbol}')\n        except Exception as e:\n            logger.error(f'Alpaca API fallback also failed for {symbol}: {str(e)}')\n            raise ValueError(f'Failed to fetch historical data for {symbol} from both yfinance and Alpaca: {str(e)}') from e\n    if hist.empty or len(hist) < lookback_days * 0.7:\n        raise ValueError(f'Insufficient data for {symbol} (got {len(hist)} bars, need {int(lookback_days * 0.7)})')\n    returns_1m = self._calculate_period_return(hist, self.LOOKBACK_PERIODS['1month'])\n    returns_3m = self._calculate_period_return(hist, self.LOOKBACK_PERIODS['3month'])\n    returns_6m = self._calculate_period_return(hist, self.LOOKBACK_PERIODS['6month'])\n    daily_returns = hist['Close'].pct_change().dropna()\n    volatility = daily_returns.std() * np.sqrt(252)\n    risk_free_rate = 0.04\n    excess_return = returns_6m - risk_free_rate\n    sharpe_ratio = excess_return / volatility if volatility > 0 else 0\n    rsi = self._calculate_rsi(hist['Close'], self.RSI_PERIOD)\n    momentum_score = returns_1m * self.MOMENTUM_WEIGHTS['1month'] * 100 + returns_3m * self.MOMENTUM_WEIGHTS['3month'] * 100 + returns_6m * self.MOMENTUM_WEIGHTS['6month'] * 100\n    volatility_penalty = volatility * 10\n    momentum_score -= volatility_penalty\n    sharpe_bonus = sharpe_ratio * 5\n    momentum_score += sharpe_bonus\n    macd_value, macd_signal, macd_histogram = self._calculate_macd(hist['Close'])\n    if macd_histogram < 0:\n        logger.warning(f'{symbol} REJECTED - Bearish MACD histogram ({macd_histogram:.4f}). Trend is down, not entering position.')\n        return -1\n    if rsi > 70:\n        logger.warning(f'{symbol} REJECTED - Overbought RSI ({rsi:.2f}). Too extended, high reversal risk.')\n        return -1\n    ma_20 = hist['Close'].rolling(window=20).mean().iloc[-1]\n    current_price = hist['Close'].iloc[-1]\n    price_vs_ma_pct = (current_price - ma_20) / ma_20 * 100\n    if current_price > ma_20 * 1.02:\n        logger.warning(f'{symbol} REJECTED - Price ${current_price:.2f} is {price_vs_ma_pct:.2f}% above 20-day MA ${ma_20:.2f}. Waiting for pullback entry to avoid buying at peak.')\n        return -1\n    if len(hist) >= 5:\n        high_5d = hist['High'].iloc[-5:].max()\n        if current_price >= high_5d * 0.98:\n            logger.warning(f'{symbol} REJECTED - Price ${current_price:.2f} is within 2% of 5-day high ${high_5d:.2f}. Avoiding entry at local peak.')\n            return -1\n    try:\n        from src.utils.technical_indicators import calculate_atr\n        atr = calculate_atr(hist, period=14)\n        if atr > 0:\n            atr_pct = atr / current_price * 100\n            avg_atr_pct = (hist['High'].iloc[-14:].max() - hist['Low'].iloc[-14:].min()) / current_price * 100 / 14\n            if atr_pct > avg_atr_pct * 2.0:\n                logger.warning(f'{symbol} REJECTED - High volatility detected (ATR: {atr_pct:.2f}% vs avg: {avg_atr_pct:.2f}%). Skipping entry during volatile period.')\n                return -1\n    except Exception as e:\n        logger.debug(f'{symbol}: ATR calculation failed, skipping volatility filter: {e}')\n    if self.RSI_OVERSOLD < rsi < 50:\n        momentum_score += 5\n    elif self.RSI_OVERSOLD < rsi < 60:\n        momentum_score += 3\n    if macd_histogram > 0:\n        momentum_score += 8\n    volume_ratio = self._calculate_volume_ratio(hist)\n    if volume_ratio > 1.5:\n        momentum_score += 10\n    elif volume_ratio > 1.2:\n        momentum_score += 5\n    elif volume_ratio < 0.5:\n        momentum_score -= 10\n    momentum_score = max(0, min(100, momentum_score))\n    logger.info(f'{symbol} momentum: {momentum_score:.2f} (1m: {returns_1m * 100:.2f}%, 3m: {returns_3m * 100:.2f}%, 6m: {returns_6m * 100:.2f}%, vol: {volatility:.2f}, sharpe: {sharpe_ratio:.2f}, rsi: {rsi:.2f}, macd: {macd_value:.4f}, signal: {macd_signal:.4f}, histogram: {macd_histogram:.4f}, vol_ratio: {volume_ratio:.2f})')\n    return momentum_score"
    },
    {
      "name": "select_best_etf",
      "line": 679,
      "code": "def select_best_etf(self, momentum_scores: Optional[List[MomentumScore]]=None) -> str:\n    \"\"\"\n        Select the ETF with the highest momentum score.\n\n        Args:\n            momentum_scores: Pre-calculated momentum scores (optional)\n\n        Returns:\n            Symbol of the best ETF to purchase\n\n        Raises:\n            ValueError: If no valid ETF can be selected\n        \"\"\"\n    logger.info('Selecting best ETF from universe')\n    if momentum_scores is None:\n        sentiment = self._get_market_sentiment()\n        momentum_scores = self._calculate_all_momentum_scores(sentiment)\n    if not momentum_scores:\n        logger.warning('\ud83d\udeab NO VALID ENTRIES TODAY - All symbols rejected by hard filters')\n        logger.warning('Either all symbols have bearish MACD or overbought RSI')\n        logger.warning('SKIPPING TRADE - Better to sit in cash than fight the trend')\n        raise ValueError('No valid trading opportunities today. All symbols failed hard filters.')\n    momentum_scores.sort(key=lambda x: x.score, reverse=True)\n    logger.info('ETF Rankings:')\n    for i, score in enumerate(momentum_scores, 1):\n        logger.info(f'  {i}. {score.symbol}: {score.score:.2f} (sentiment_boost: {score.sentiment_boost:.2f})')\n    best_etf = momentum_scores[0].symbol\n    logger.info(f'Best ETF selected: {best_etf} with score {momentum_scores[0].score:.2f}')\n    return best_etf"
    },
    {
      "name": "should_rebalance",
      "line": 732,
      "code": "def should_rebalance(self) -> bool:\n    \"\"\"\n        Determine if portfolio rebalancing is needed.\n\n        Rebalancing is triggered when:\n        1. It's been more than REBALANCE_FREQUENCY_DAYS since last rebalance\n        2. Position concentration exceeds REBALANCE_THRESHOLD\n        3. Holdings deviate significantly from target allocation\n\n        Returns:\n            True if rebalancing is recommended, False otherwise\n        \"\"\"\n    if self.last_rebalance_date is None:\n        if self.total_invested > 0:\n            logger.info('First rebalance check - considering rebalance')\n            return True\n        return False\n    days_since_rebalance = (datetime.now() - self.last_rebalance_date).days\n    if days_since_rebalance < self.REBALANCE_FREQUENCY_DAYS:\n        logger.debug(f'Rebalance not needed - only {days_since_rebalance} days since last rebalance (threshold: {self.REBALANCE_FREQUENCY_DAYS})')\n        return False\n    if not self.current_holdings:\n        return False\n    total_value = self._calculate_total_portfolio_value()\n    if total_value == 0:\n        return False\n    position_pcts = {symbol: qty * self._get_current_price(symbol) / total_value for symbol, qty in self.current_holdings.items()}\n    max_concentration = max(position_pcts.values())\n    target_allocation = 1.0 / len(self.etf_universe)\n    deviation = abs(max_concentration - target_allocation)\n    if deviation > self.REBALANCE_THRESHOLD:\n        logger.info(f'Rebalance needed - position concentration {max_concentration:.1%} deviates {deviation:.1%} from target {target_allocation:.1%}')\n        return True\n    logger.info(f'Rebalance not needed - max deviation {deviation:.1%} below threshold {self.REBALANCE_THRESHOLD:.1%}')\n    return False"
    },
    {
      "name": "rebalance_portfolio",
      "line": 793,
      "code": "def rebalance_portfolio(self) -> List[TradeOrder]:\n    \"\"\"\n        Rebalance portfolio to maintain target allocations.\n\n        Process:\n        1. Calculate current position values\n        2. Determine target allocations (equal weight)\n        3. Calculate required trades\n        4. Execute rebalancing orders\n        5. Update holdings and state\n\n        Returns:\n            List of trade orders executed during rebalancing\n\n        Raises:\n            ValueError: If rebalancing fails\n        \"\"\"\n    logger.info('=' * 80)\n    logger.info('Starting portfolio rebalancing')\n    logger.info(f'Timestamp: {datetime.now().isoformat()}')\n    rebalance_orders: List[TradeOrder] = []\n    try:\n        total_value = self._calculate_total_portfolio_value()\n        if total_value == 0:\n            logger.warning('Portfolio value is zero - cannot rebalance')\n            return []\n        logger.info(f'Total portfolio value: ${total_value:.2f}')\n        target_allocation = 1.0 / len(self.etf_universe)\n        target_value_per_etf = total_value * target_allocation\n        logger.info(f'Target allocation per ETF: {target_allocation:.1%} (${target_value_per_etf:.2f})')\n        current_allocations = {}\n        for symbol in self.etf_universe:\n            qty = self.current_holdings.get(symbol, 0.0)\n            price = self._get_current_price(symbol)\n            current_value = qty * price\n            current_allocations[symbol] = {'quantity': qty, 'price': price, 'value': current_value, 'pct': current_value / total_value}\n        logger.info('Current allocations:')\n        for symbol, alloc in current_allocations.items():\n            logger.info(f\"  {symbol}: {alloc['pct']:.1%} (${alloc['value']:.2f}, {alloc['quantity']:.4f} shares @ ${alloc['price']:.2f})\")\n        for symbol in self.etf_universe:\n            current_value = current_allocations[symbol]['value']\n            target_value = target_value_per_etf\n            value_diff = target_value - current_value\n            if abs(value_diff) < 1.0:\n                continue\n            price = current_allocations[symbol]['price']\n            quantity_diff = value_diff / price\n            if value_diff > 0:\n                order = self._create_buy_order(symbol=symbol, quantity=quantity_diff, price=price, sentiment=None, reason=f'Rebalancing - target {target_allocation:.1%}')\n            else:\n                order = TradeOrder(symbol=symbol, action='sell', quantity=abs(quantity_diff), amount=abs(value_diff), price=price, order_type='market', stop_loss=None, timestamp=datetime.now(), reason=f'Rebalancing - target {target_allocation:.1%}')\n            rebalance_orders.append(order)\n            logger.info(f'Rebalance order: {order.action.upper()} {order.quantity:.4f} {order.symbol} @ ${order.price:.2f} (${order.amount:.2f})')\n        if self.alpaca_trader:\n            for order in rebalance_orders:\n                try:\n                    if order.action == 'buy':\n                        executed = self.alpaca_trader.execute_order(symbol=order.symbol, amount_usd=order.amount, side='buy')\n                        logger.info(f\"Rebalance buy executed: {executed['id']}\")\n                    else:\n                        executed = self.alpaca_trader.execute_order(symbol=order.symbol, amount_usd=order.amount, side='sell')\n                        logger.info(f\"Rebalance sell executed: {executed['id']}\")\n                except Exception as e:\n                    logger.error(f'Failed to execute rebalance order for {order.symbol}: {e}')\n                    continue\n        for order in rebalance_orders:\n            if order.action == 'buy':\n                self.current_holdings[order.symbol] = self.current_holdings.get(order.symbol, 0.0) + order.quantity\n            else:\n                self.current_holdings[order.symbol] = self.current_holdings.get(order.symbol, 0.0) - order.quantity\n        self.last_rebalance_date = datetime.now()\n        self.trades_executed.extend(rebalance_orders)\n        logger.info(f'Rebalancing complete - executed {len(rebalance_orders)} orders')\n        logger.info('=' * 80)\n        return rebalance_orders\n    except Exception as e:\n        logger.error(f'Error during rebalancing: {str(e)}', exc_info=True)\n        raise ValueError(f'Rebalancing failed: {str(e)}') from e"
    },
    {
      "name": "get_account_summary",
      "line": 944,
      "code": "def get_account_summary(self) -> Dict[str, any]:\n    \"\"\"\n        Get comprehensive account summary from Alpaca.\n\n        Returns:\n            Dictionary containing account information and portfolio data\n        \"\"\"\n    if not self.alpaca_trader:\n        logger.warning('Alpaca trader not initialized')\n        return {'account_value': self._calculate_total_portfolio_value(), 'buying_power': 0.0, 'cash': 0.0, 'portfolio_value': self._calculate_total_portfolio_value(), 'positions': [], 'source': 'local_tracking'}\n    try:\n        account_info = self.alpaca_trader.get_account_info()\n        positions = self.alpaca_trader.get_positions()\n        performance = self.alpaca_trader.get_portfolio_performance()\n        summary = {'account_value': account_info['portfolio_value'], 'buying_power': account_info['buying_power'], 'cash': account_info['cash'], 'equity': account_info['equity'], 'portfolio_value': performance['portfolio_value'], 'profit_loss': performance['profit_loss'], 'profit_loss_pct': performance['profit_loss_pct'], 'positions': positions, 'positions_count': len(positions), 'source': 'alpaca_api', 'timestamp': datetime.now().isoformat()}\n        logger.info(f\"Account summary retrieved: ${summary['account_value']:.2f}\")\n        return summary\n    except Exception as e:\n        logger.error(f'Error getting account summary: {e}')\n        return {'account_value': self._calculate_total_portfolio_value(), 'buying_power': 0.0, 'cash': 0.0, 'portfolio_value': self._calculate_total_portfolio_value(), 'positions': [], 'source': 'error_fallback', 'error': str(e)}"
    },
    {
      "name": "update_daily_performance",
      "line": 1001,
      "code": "def update_daily_performance(self) -> None:\n    \"\"\"\n        Update daily performance metrics and returns.\n\n        Should be called at end of each trading day to track performance.\n        \"\"\"\n    try:\n        current_value = self._calculate_total_portfolio_value()\n        if self.total_value > 0:\n            daily_return = (current_value - self.total_value) / self.total_value\n            self.daily_returns.append(daily_return)\n            logger.info(f'Daily return: {daily_return * 100:.2f}%')\n        self.total_value = current_value\n        if self.risk_manager and len(self.daily_returns) > 0:\n            pnl = current_value - self.total_invested\n            self.risk_manager.record_trade_result(pnl)\n    except Exception as e:\n        logger.error(f'Error updating daily performance: {e}')"
    },
    {
      "name": "get_performance_metrics",
      "line": 1028,
      "code": "def get_performance_metrics(self) -> Dict[str, any]:\n    \"\"\"\n        Calculate comprehensive performance metrics for the strategy.\n\n        Returns:\n            Dictionary containing:\n            - total_invested: Total capital deployed\n            - current_value: Current portfolio value\n            - total_return: Absolute return in dollars\n            - total_return_pct: Percentage return\n            - annualized_return: Annualized return percentage\n            - sharpe_ratio: Risk-adjusted return metric\n            - max_drawdown: Maximum peak-to-trough decline\n            - win_rate: Percentage of profitable days\n            - num_trades: Total number of trades executed\n            - average_trade_size: Average trade amount\n            - holding_period_days: Days since first trade\n            - daily_returns: List of daily returns\n        \"\"\"\n    logger.info('Calculating performance metrics')\n    current_value = self._calculate_total_portfolio_value()\n    total_return = current_value - self.total_invested\n    total_return_pct = total_return / self.total_invested * 100 if self.total_invested > 0 else 0.0\n    if self.trades_executed:\n        first_trade_date = min((trade.timestamp for trade in self.trades_executed))\n        holding_period_days = (datetime.now() - first_trade_date).days\n    else:\n        holding_period_days = 0\n    if holding_period_days > 0 and self.total_invested > 0:\n        years = holding_period_days / 365.25\n        annualized_return = (pow(current_value / self.total_invested, 1 / years) - 1) * 100 if years > 0 else 0.0\n    else:\n        annualized_return = 0.0\n    if len(self.daily_returns) > 1:\n        mean_return = np.mean(self.daily_returns)\n        std_return = np.std(self.daily_returns)\n        risk_free_rate_daily = 0.04 / 252\n        sharpe_ratio = (mean_return - risk_free_rate_daily) / std_return * np.sqrt(252) if std_return > 0 else 0.0\n    else:\n        sharpe_ratio = 0.0\n    max_drawdown = self._calculate_max_drawdown()\n    positive_days = sum((1 for r in self.daily_returns if r > 0))\n    win_rate = positive_days / len(self.daily_returns) * 100 if self.daily_returns else 0.0\n    num_trades = len(self.trades_executed)\n    average_trade_size = sum((trade.amount for trade in self.trades_executed)) / num_trades if num_trades > 0 else 0.0\n    metrics = {'total_invested': self.total_invested, 'current_value': current_value, 'total_return': total_return, 'total_return_pct': total_return_pct, 'annualized_return': annualized_return, 'sharpe_ratio': sharpe_ratio, 'max_drawdown': max_drawdown, 'win_rate': win_rate, 'num_trades': num_trades, 'average_trade_size': average_trade_size, 'holding_period_days': holding_period_days, 'current_holdings': self.current_holdings.copy(), 'last_rebalance_date': self.last_rebalance_date}\n    logger.info('Performance Summary:')\n    logger.info(f\"  Total Invested: ${metrics['total_invested']:.2f}\")\n    logger.info(f\"  Current Value: ${metrics['current_value']:.2f}\")\n    logger.info(f\"  Total Return: ${metrics['total_return']:.2f} ({metrics['total_return_pct']:.2f}%)\")\n    logger.info(f\"  Annualized Return: {metrics['annualized_return']:.2f}%\")\n    logger.info(f\"  Sharpe Ratio: {metrics['sharpe_ratio']:.2f}\")\n    logger.info(f\"  Max Drawdown: {metrics['max_drawdown']:.2f}%\")\n    logger.info(f\"  Win Rate: {metrics['win_rate']:.1f}%\")\n    logger.info(f\"  Number of Trades: {metrics['num_trades']}\")\n    logger.info(f\"  Holding Period: {metrics['holding_period_days']} days\")\n    return metrics"
    },
    {
      "name": "_get_market_sentiment",
      "line": 1144,
      "code": "def _get_market_sentiment(self) -> MarketSentiment:\n    \"\"\"\n        Query sentiment data (Reddit + News) for current market sentiment.\n\n        This method now uses the sentiment_loader to get pre-collected sentiment\n        from Reddit and news sources instead of querying LLMs in real-time.\n\n        Priority:\n        1. Load pre-collected sentiment from data/sentiment/\n        2. Use SPY as proxy for overall market sentiment\n        3. Apply risk-off filter if market is bearish\n\n        Returns:\n            MarketSentiment enum value\n        \"\"\"\n    if not self.use_sentiment:\n        logger.debug('Sentiment disabled - using default neutral')\n        return MarketSentiment.NEUTRAL\n    try:\n        sentiment_data = load_latest_sentiment()\n        if not sentiment_data.get('sentiment_by_ticker'):\n            logger.warning('No sentiment data available - using neutral')\n            return MarketSentiment.NEUTRAL\n        market_regime = get_market_regime(sentiment_data)\n        spy_score, spy_confidence, _ = get_ticker_sentiment('SPY', sentiment_data)\n        if spy_score < 30:\n            sentiment = MarketSentiment.VERY_BEARISH\n        elif spy_score < 40:\n            sentiment = MarketSentiment.BEARISH\n        elif spy_score < 60:\n            sentiment = MarketSentiment.NEUTRAL\n        elif spy_score < 70:\n            sentiment = MarketSentiment.BULLISH\n        else:\n            sentiment = MarketSentiment.VERY_BULLISH\n        if getattr(self, 'sentiment_rag_enabled', True):\n            history = get_sentiment_history('SPY', limit=5)\n            if history:\n                logger.info('Recent SPY sentiment snapshots (RAG):')\n                for entry in history:\n                    meta = entry['metadata']\n                    logger.info('  %s score=%.1f confidence=%s regime=%s', meta.get('snapshot_date'), meta.get('sentiment_score', 0.0), meta.get('confidence', 'n/a'), meta.get('market_regime', 'n/a'))\n        logger.info(f'Sentiment analysis: {sentiment.value} (SPY score: {spy_score:.1f}, confidence: {spy_confidence}, market regime: {market_regime})')\n        meta = sentiment_data.get('meta', {})\n        freshness = meta.get('freshness', 'unknown')\n        days_old = meta.get('days_old', 0)\n        logger.info(f\"Sentiment data: {freshness} ({days_old} days old), sources: {', '.join(meta.get('sources', []))}\")\n        return sentiment\n    except Exception as e:\n        logger.error(f'Error loading sentiment data: {e}')\n        logger.debug('Falling back to neutral sentiment')\n        return MarketSentiment.NEUTRAL"
    },
    {
      "name": "_calculate_all_momentum_scores",
      "line": 1229,
      "code": "def _calculate_all_momentum_scores(self, sentiment: MarketSentiment) -> List[MomentumScore]:\n    \"\"\"\n        Calculate momentum scores for all ETFs in universe.\n\n        Args:\n            sentiment: Current market sentiment for boosting\n\n        Returns:\n            List of MomentumScore objects\n        \"\"\"\n    scores = []\n    sentiment_boost = self._get_sentiment_boost(sentiment)\n    for symbol in self.etf_universe:\n        try:\n            base_score = self.calculate_momentum(symbol)\n            if base_score < 0:\n                logger.info(f'{symbol} skipped - failed hard filters')\n                continue\n            adjusted_score = base_score + sentiment_boost\n            adjusted_score = max(0, min(100, adjusted_score))\n            ticker = yf.Ticker(symbol)\n            hist = ticker.history(period='6mo')\n            returns_1m = self._calculate_period_return(hist, 21)\n            returns_3m = self._calculate_period_return(hist, 63)\n            returns_6m = self._calculate_period_return(hist, 126)\n            daily_returns = hist['Close'].pct_change().dropna()\n            volatility = daily_returns.std() * np.sqrt(252)\n            risk_free_rate = 0.04\n            excess_return = returns_6m - risk_free_rate\n            sharpe_ratio = excess_return / volatility if volatility > 0 else 0\n            rsi = self._calculate_rsi(hist['Close'], self.RSI_PERIOD)\n            macd_value, macd_signal, macd_histogram = self._calculate_macd(hist['Close'])\n            volume_ratio = self._calculate_volume_ratio(hist)\n            score_obj = MomentumScore(symbol=symbol, score=adjusted_score, returns_1m=returns_1m, returns_3m=returns_3m, returns_6m=returns_6m, volatility=volatility, sharpe_ratio=sharpe_ratio, rsi=rsi, macd_value=macd_value, macd_signal=macd_signal, macd_histogram=macd_histogram, volume_ratio=volume_ratio, sentiment_boost=sentiment_boost, timestamp=datetime.now())\n            scores.append(score_obj)\n            self.momentum_history.append(score_obj)\n        except Exception as e:\n            logger.error(f'Failed to calculate momentum for {symbol}: {str(e)}')\n            continue\n    return scores"
    },
    {
      "name": "_get_sentiment_boost",
      "line": 1306,
      "code": "def _get_sentiment_boost(self, sentiment: MarketSentiment) -> float:\n    \"\"\"\n        Convert sentiment to momentum score adjustment.\n\n        Args:\n            sentiment: Market sentiment\n\n        Returns:\n            Score boost (positive or negative)\n        \"\"\"\n    sentiment_map = {MarketSentiment.VERY_BULLISH: 10.0, MarketSentiment.BULLISH: 5.0, MarketSentiment.NEUTRAL: 0.0, MarketSentiment.BEARISH: -5.0, MarketSentiment.VERY_BEARISH: -10.0}\n    return sentiment_map.get(sentiment, 0.0)"
    },
    {
      "name": "_get_current_price",
      "line": 1325,
      "code": "def _get_current_price(self, symbol: str) -> Optional[float]:\n    \"\"\"\n        Get current market price for symbol.\n\n        Args:\n            symbol: Ticker symbol\n\n        Returns:\n            Current price or None if unavailable\n        \"\"\"\n    try:\n        ticker = yf.Ticker(symbol)\n        data = ticker.history(period='1d')\n        if not data.empty:\n            return float(data['Close'].iloc[-1])\n        return None\n    except Exception as e:\n        logger.error(f'Error fetching price for {symbol}: {str(e)}')\n        return None"
    },
    {
      "name": "_calculate_period_return",
      "line": 1345,
      "code": "def _calculate_period_return(self, hist: pd.DataFrame, periods: int) -> float:\n    \"\"\"\n        Calculate return over specified number of periods.\n\n        Args:\n            hist: Historical price DataFrame\n            periods: Number of periods to look back\n\n        Returns:\n            Period return as decimal (e.g., 0.05 for 5%)\n        \"\"\"\n    if len(hist) < periods:\n        periods = len(hist) - 1\n    if periods <= 0:\n        return 0.0\n    end_price = hist['Close'].iloc[-1]\n    start_price = hist['Close'].iloc[-periods]\n    return (end_price - start_price) / start_price"
    },
    {
      "name": "_calculate_rsi",
      "line": 1367,
      "code": "def _calculate_rsi(self, prices: pd.Series, period: int=14) -> float:\n    \"\"\"\n        Calculate Relative Strength Index (RSI).\n\n        Args:\n            prices: Price series\n            period: RSI period (default: 14)\n\n        Returns:\n            RSI value (0-100)\n        \"\"\"\n    delta = prices.diff()\n    gain = delta.where(delta > 0, 0).rolling(window=period).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()\n    rs = gain / loss\n    rsi = 100 - 100 / (1 + rs)\n    return float(rsi.iloc[-1]) if not pd.isna(rsi.iloc[-1]) else 50.0"
    },
    {
      "name": "_calculate_macd",
      "line": 1387,
      "code": "def _calculate_macd(self, prices: pd.Series) -> Tuple[float, float, float]:\n    \"\"\"\n        Calculate MACD (Moving Average Convergence Divergence).\n\n        Uses shared utility from src.utils.technical_indicators.\n\n        Args:\n            prices: Price series\n\n        Returns:\n            Tuple of (macd_value, signal_line, histogram)\n        \"\"\"\n    from src.utils.technical_indicators import calculate_macd\n    return calculate_macd(prices, fast_period=self.MACD_FAST_PERIOD, slow_period=self.MACD_SLOW_PERIOD, signal_period=self.MACD_SIGNAL_PERIOD)"
    },
    {
      "name": "_calculate_volume_ratio",
      "line": 1408,
      "code": "def _calculate_volume_ratio(self, hist: pd.DataFrame) -> float:\n    \"\"\"\n        Calculate volume ratio (current vs 20-day average).\n\n        Uses shared utility from src.utils.technical_indicators.\n\n        Args:\n            hist: Historical price DataFrame\n\n        Returns:\n            Volume ratio (current / 20-day average)\n        \"\"\"\n    from src.utils.technical_indicators import calculate_volume_ratio\n    return calculate_volume_ratio(hist, window=20)"
    },
    {
      "name": "_validate_trade",
      "line": 1424,
      "code": "def _validate_trade(self, symbol: str, quantity: float, price: float, sentiment: MarketSentiment) -> bool:\n    \"\"\"\n        Validate trade against risk management rules using RiskManager.\n\n        Args:\n            symbol: Ticker symbol\n            quantity: Number of shares\n            price: Price per share\n            sentiment: Current market sentiment\n\n        Returns:\n            True if trade passes validation, False otherwise\n        \"\"\"\n    trade_value = quantity * price\n    if trade_value > self.daily_allocation * 1.1:\n        logger.warning(f'Trade value ${trade_value:.2f} exceeds daily allocation')\n        return False\n    total_portfolio_value = self._calculate_total_portfolio_value()\n    if total_portfolio_value > 0:\n        current_position_value = self.current_holdings.get(symbol, 0) * price\n        new_position_value = current_position_value + trade_value\n        position_pct = new_position_value / (total_portfolio_value + trade_value) * 100\n        if position_pct > 50:\n            logger.warning(f'Position size limit exceeded: {symbol} would be {position_pct:.1f}% of portfolio (max 50%). Skipping trade to maintain diversification.')\n            return False\n    if self.risk_manager:\n        try:\n            account_info = None\n            account_value = self._calculate_total_portfolio_value() + self.total_invested\n            if account_value == 0:\n                account_value = 10000.0\n            if self.alpaca_trader:\n                try:\n                    account_info = self.alpaca_trader.get_account_info()\n                    account_value = account_info.get('portfolio_value', account_value)\n                except Exception:\n                    pass\n            sentiment_score = self._get_sentiment_boost(sentiment) / 10.0\n            validation = self.risk_manager.validate_trade(symbol=symbol, amount=trade_value, sentiment_score=sentiment_score, account_value=account_value, trade_type='BUY', account_info=account_info)\n            if not validation['valid']:\n                logger.warning(f\"Risk manager rejected trade: {validation['reason']}\")\n                return False\n            if validation['warnings']:\n                for warning in validation['warnings']:\n                    logger.warning(f'Risk manager warning: {warning}')\n            if not self.risk_manager.can_trade(account_value, self.risk_manager.metrics.daily_pl, account_info):\n                logger.warning('Trading suspended by circuit breaker')\n                return False\n            if self.langchain_guard_enabled and (not self._langchain_guard(symbol, sentiment)):\n                logger.warning('LangChain approval gate rejected trade for %s', symbol)\n                return False\n            return True\n        except Exception as e:\n            logger.error(f'Error in risk validation: {e}')\n    if self.langchain_guard_enabled and (not self._langchain_guard(symbol, sentiment)):\n        logger.warning('LangChain approval gate rejected trade for %s', symbol)\n        return False\n    return True"
    },
    {
      "name": "_create_buy_order",
      "line": 1536,
      "code": "def _create_buy_order(self, symbol: str, quantity: float, price: float, sentiment: Optional[MarketSentiment], reason: Optional[str]=None) -> TradeOrder:\n    \"\"\"\n        Create a buy order with stop-loss.\n\n        Args:\n            symbol: Ticker symbol\n            quantity: Number of shares\n            price: Price per share\n            sentiment: Current market sentiment\n            reason: Trade reason (optional)\n\n        Returns:\n            TradeOrder object\n        \"\"\"\n    amount = quantity * price\n    stop_loss_price = price * (1 - self.stop_loss_pct)\n    if reason is None:\n        reason = f\"Daily DCA purchase - {(sentiment.value if sentiment else 'neutral')} sentiment\"\n    return TradeOrder(symbol=symbol, action='buy', quantity=quantity, amount=amount, price=price, order_type='market', stop_loss=stop_loss_price, timestamp=datetime.now(), reason=reason)"
    },
    {
      "name": "_langchain_guard",
      "line": 1575,
      "code": "def _langchain_guard(self, symbol: str, sentiment: MarketSentiment) -> bool:\n    \"\"\"\n        Invoke the LangChain approval agent if enabled.\n\n        Returns True when the agent responds with APPROVE. On failure, defaults to\n        fail-open unless LANGCHAIN_APPROVAL_FAIL_OPEN is set to false.\n        \"\"\"\n    try:\n        if self._langchain_agent is None:\n            from langchain_agents.agents import build_price_action_agent\n            self._langchain_agent = build_price_action_agent()\n        prompt = f\"You are the trading desk's approval co-pilot. Evaluate whether we should execute a BUY trade today. Respond with a single word: 'APPROVE' or 'DECLINE'.\\n\\nTicker: {symbol}\\nCurrent market sentiment: {sentiment.value}\\nUse the available sentiment tools to gather recent context. Decline if the data is missing, highly bearish, or confidence is low.\"\n        response = self._langchain_agent.invoke({'input': prompt})\n        if isinstance(response, dict):\n            text = response.get('output', '')\n        else:\n            text = str(response)\n        normalized = text.strip().lower()\n        approved = 'approve' in normalized and 'decline' not in normalized\n        if approved:\n            logger.info('LangChain approval granted for %s: %s', symbol, text)\n        else:\n            logger.warning('LangChain approval denied for %s: %s', symbol, text)\n        return approved\n    except Exception as exc:\n        logger.error('LangChain approval gate error: %s', exc)\n        fail_open = os.getenv('LANGCHAIN_APPROVAL_FAIL_OPEN', 'true').lower()\n        if fail_open == 'true':\n            logger.warning('LangChain approval unavailable; defaulting to APPROVE (fail-open).')\n            return True\n        return False"
    },
    {
      "name": "_update_holdings",
      "line": 1623,
      "code": "def _update_holdings(self, symbol: str, quantity: float) -> None:\n    \"\"\"\n        Update current holdings after trade.\n\n        Args:\n            symbol: Ticker symbol\n            quantity: Quantity to add (positive) or remove (negative)\n        \"\"\"\n    self.current_holdings[symbol] = self.current_holdings.get(symbol, 0.0) + quantity\n    if self.current_holdings[symbol] <= 0:\n        self.current_holdings.pop(symbol, None)"
    },
    {
      "name": "_calculate_total_portfolio_value",
      "line": 1639,
      "code": "def _calculate_total_portfolio_value(self) -> float:\n    \"\"\"\n        Calculate total current value of all holdings.\n\n        Returns:\n            Total portfolio value in dollars\n        \"\"\"\n    total = 0.0\n    for symbol, quantity in self.current_holdings.items():\n        price = self._get_current_price(symbol)\n        if price:\n            total += quantity * price\n    return total"
    },
    {
      "name": "_calculate_max_drawdown",
      "line": 1653,
      "code": "def _calculate_max_drawdown(self) -> float:\n    \"\"\"\n        Calculate maximum drawdown from peak.\n\n        Returns:\n            Maximum drawdown as percentage\n        \"\"\"\n    if not self.daily_returns:\n        return 0.0\n    cumulative = np.cumprod(1 + np.array(self.daily_returns))\n    running_max = np.maximum.accumulate(cumulative)\n    drawdown = (cumulative - running_max) / running_max\n    return float(abs(np.min(drawdown)) * 100) if len(drawdown) > 0 else 0.0"
    }
  ]
}
