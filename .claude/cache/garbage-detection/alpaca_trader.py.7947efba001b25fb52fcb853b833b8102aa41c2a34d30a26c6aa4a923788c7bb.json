{
  "dead_imports": [
    {
      "line": 25,
      "module": "Union",
      "statement": "from typing import Dict, List, Optional, Union, Any"
    },
    {
      "line": 26,
      "module": "timedelta",
      "statement": "from datetime import datetime, timedelta"
    },
    {
      "line": 27,
      "module": "Decimal",
      "statement": "from decimal import Decimal"
    },
    {
      "line": 30,
      "module": "REST",
      "statement": "from alpaca_trade_api.rest import APIError, REST"
    }
  ],
  "commented_blocks": [],
  "empty_functions": [],
  "unused_variables": [
    {
      "line": 91,
      "variable": "TIER_ALLOCATIONS"
    },
    {
      "line": 99,
      "variable": "MAX_ORDER_MULTIPLIER"
    }
  ],
  "all_functions": [
    {
      "name": "__init__",
      "line": 101,
      "code": "def __init__(self, paper: bool=True) -> None:\n    \"\"\"\n        Initialize the Alpaca trader with API credentials.\n\n        Args:\n            paper: If True, use paper trading environment. If False, use live trading.\n                  Default is True for safety.\n\n        Raises:\n            AlpacaTraderError: If API credentials are missing or invalid.\n\n        Example:\n            >>> trader = AlpacaTrader(paper=True)\n            >>> print(f\"Connected to {'paper' if trader.paper else 'live'} trading\")\n        \"\"\"\n    self.paper = paper\n    api_key = os.getenv('ALPACA_API_KEY')\n    secret_key = os.getenv('ALPACA_SECRET_KEY')\n    self.daily_investment = float(os.getenv('DAILY_INVESTMENT', '10.0'))\n    logger.info(f'Daily investment configured: ${self.daily_investment:.2f}')\n    if not api_key or not secret_key:\n        raise AlpacaTraderError('Missing API credentials. Please set ALPACA_API_KEY and ALPACA_SECRET_KEY environment variables.')\n    base_url = os.getenv('APCA_API_BASE_URL')\n    if not base_url:\n        base_url = 'https://paper-api.alpaca.markets' if paper else 'https://api.alpaca.markets'\n    try:\n        self.api = tradeapi.REST(key_id=api_key, secret_key=secret_key, base_url=base_url, api_version='v2')\n        account = self.api.get_account()\n        logger.info(f\"Successfully connected to Alpaca ({('paper' if paper else 'live')} trading)\")\n        logger.info(f'Account status: {account.status}')\n    except APIError as e:\n        logger.error(f'Failed to connect to Alpaca API: {e}')\n        raise AlpacaTraderError(f'API connection failed: {e}') from e\n    except Exception as e:\n        logger.error(f'Unexpected error during initialization: {e}')\n        raise AlpacaTraderError(f'Initialization failed: {e}') from e"
    },
    {
      "name": "validate_order_amount",
      "line": 166,
      "code": "def validate_order_amount(self, symbol: str, amount: float, tier: Optional[str]=None) -> None:\n    \"\"\"\n        Validate order amount is reasonable to prevent catastrophic errors.\n\n        This method prevents bugs like the Nov 3 incident where $1,600 was\n        deployed instead of $8 (200x too large). It checks:\n        1. Amount is not more than 10x expected for the tier\n        2. Warns if amount is 5x-10x expected (suspicious but allowed)\n\n        Args:\n            symbol: Stock or ETF symbol\n            amount: Dollar amount being ordered\n            tier: Trading tier (T1_CORE, T2_GROWTH, T3_IPO, T4_CROWD) or None\n\n        Raises:\n            OrderExecutionError: If amount exceeds 10x expected amount\n\n        Example:\n            >>> trader = AlpacaTrader()\n            >>> trader.validate_order_amount('SPY', 6.0, 'T1_CORE')  # PASS\n            >>> trader.validate_order_amount('SPY', 600.0, 'T1_CORE')  # ERROR\n        \"\"\"\n    if tier and tier in self.TIER_ALLOCATIONS:\n        expected_amount = self.daily_investment * self.TIER_ALLOCATIONS[tier]\n        tier_name = tier\n    else:\n        expected_amount = self.daily_investment\n        tier_name = 'UNSPECIFIED'\n    max_allowed = expected_amount * self.MAX_ORDER_MULTIPLIER\n    if amount > max_allowed:\n        error_msg = f'\ud83d\udea8 ORDER REJECTED FOR SAFETY \ud83d\udea8\\nSymbol: {symbol}\\nOrder amount: ${amount:.2f}\\nExpected amount: ${expected_amount:.2f} (tier: {tier_name})\\nMaximum allowed: ${max_allowed:.2f} ({self.MAX_ORDER_MULTIPLIER}x expected)\\nThis order is {amount / expected_amount:.1f}x expected - appears to be a bug.\\nREFUSING to execute to prevent financial loss.'\n        logger.error(error_msg)\n        raise OrderExecutionError(error_msg)\n    warning_threshold = expected_amount * 5.0\n    if amount > warning_threshold:\n        warning_msg = f'\u26a0\ufe0f  SUSPICIOUS ORDER SIZE \u26a0\ufe0f\\nSymbol: {symbol}\\nOrder amount: ${amount:.2f}\\nExpected amount: ${expected_amount:.2f} (tier: {tier_name})\\nThis order is {amount / expected_amount:.1f}x expected.\\nProceeding with caution...'\n        logger.warning(warning_msg)\n    else:\n        logger.info(f'\u2705 Order validation passed: ${amount:.2f} <= ${max_allowed:.2f} (expected: ${expected_amount:.2f}, tier: {tier_name})')"
    },
    {
      "name": "get_account_info",
      "line": 238,
      "code": "@retry_with_backoff(max_retries=3, initial_delay=1.0, exceptions=(APIError, ConnectionError))\ndef get_account_info(self) -> Dict[str, Any]:\n    \"\"\"\n        Retrieve account information including buying power, equity, and cash.\n\n        Retries up to 3 times with exponential backoff on network errors.\n\n        Returns:\n            Dictionary containing account information with keys:\n                - account_number: Account identification number\n                - status: Account status (ACTIVE, etc.)\n                - currency: Account currency (USD)\n                - buying_power: Available buying power\n                - cash: Available cash\n                - portfolio_value: Total portfolio value\n                - equity: Total equity\n                - last_equity: Equity as of previous trading day\n                - pattern_day_trader: PDT flag\n\n        Raises:\n            AccountError: If account information retrieval fails.\n\n        Example:\n            >>> trader = AlpacaTrader()\n            >>> account = trader.get_account_info()\n            >>> print(f\"Buying power: ${account['buying_power']}\")\n        \"\"\"\n    try:\n        account: Account = self.api.get_account()\n        account_info = {'account_number': account.account_number, 'status': account.status, 'currency': account.currency, 'buying_power': float(account.buying_power), 'cash': float(account.cash), 'portfolio_value': float(account.portfolio_value), 'equity': float(account.equity), 'last_equity': float(account.last_equity), 'pattern_day_trader': account.pattern_day_trader, 'trading_blocked': account.trading_blocked, 'transfers_blocked': account.transfers_blocked, 'account_blocked': account.account_blocked, 'created_at': str(account.created_at), 'trade_suspended_by_user': account.trade_suspended_by_user}\n        if hasattr(account, 'daytrade_count'):\n            account_info['daytrade_count'] = account.daytrade_count\n        elif hasattr(account, 'day_trade_count'):\n            account_info['daytrade_count'] = account.day_trade_count\n        else:\n            account_info['daytrade_count'] = 0\n        logger.info(f\"Retrieved account info: Portfolio value ${account_info['portfolio_value']:.2f}\")\n        return account_info\n    except APIError as e:\n        logger.error(f'Failed to retrieve account information: {e}')\n        raise AccountError(f'Account retrieval failed: {e}') from e\n    except Exception as e:\n        logger.error(f'Unexpected error retrieving account info: {e}')\n        raise AccountError(f'Unexpected error: {e}') from e"
    },
    {
      "name": "execute_order",
      "line": 308,
      "code": "@retry_with_backoff(max_retries=3, initial_delay=2.0, exceptions=(APIError, ConnectionError))\ndef execute_order(self, symbol: str, amount_usd: float, side: str='buy', tier: Optional[str]=None) -> Dict[str, Any]:\n    \"\"\"\n        Execute a market order with fractional shares based on USD amount.\n\n        Retries up to 3 times with exponential backoff on network/API errors.\n\n        Args:\n            symbol: Stock or ETF symbol (e.g., 'SPY', 'AAPL')\n            amount_usd: Dollar amount to trade (e.g., 100.0 for $100)\n            side: Order side - 'buy' or 'sell'. Default is 'buy'.\n            tier: Trading tier for validation (T1_CORE, T2_GROWTH, T3_IPO, T4_CROWD)\n\n        Returns:\n            Dictionary containing order information with keys:\n                - id: Order ID\n                - symbol: Asset symbol\n                - notional: Dollar amount\n                - side: Buy or sell\n                - type: Order type (market)\n                - status: Order status\n                - submitted_at: Submission timestamp\n                - filled_at: Fill timestamp (if filled)\n                - filled_avg_price: Average fill price\n\n        Raises:\n            OrderExecutionError: If order execution fails or validation fails.\n            ValueError: If parameters are invalid.\n\n        Example:\n            >>> trader = AlpacaTrader()\n            >>> order = trader.execute_order('SPY', 6.0, side='buy', tier='T1_CORE')\n            >>> print(f\"Order {order['id']} submitted for ${order['notional']}\")\n        \"\"\"\n    if side not in ['buy', 'sell']:\n        raise ValueError(f\"Invalid side '{side}'. Must be 'buy' or 'sell'.\")\n    if amount_usd <= 0:\n        raise ValueError(f'Amount must be positive. Got {amount_usd}')\n    symbol = symbol.upper().strip()\n    self.validate_order_amount(symbol, amount_usd, tier)\n    try:\n        account = self.api.get_account()\n        if account.trading_blocked:\n            raise OrderExecutionError('Trading is blocked for this account')\n        if side == 'buy' and float(account.buying_power) < amount_usd:\n            raise OrderExecutionError(f'Insufficient buying power. Available: ${account.buying_power}, Required: ${amount_usd}')\n        logger.info(f'Executing {side} order: {symbol} for ${amount_usd:.2f}')\n        order: Order = self.api.submit_order(symbol=symbol, notional=amount_usd, side=side, type='market', time_in_force='day')\n        order_info = {'id': order.id, 'client_order_id': order.client_order_id, 'symbol': order.symbol, 'notional': float(order.notional) if order.notional else amount_usd, 'side': order.side, 'type': order.type, 'time_in_force': order.time_in_force, 'status': order.status, 'submitted_at': str(order.submitted_at), 'filled_at': str(order.filled_at) if order.filled_at else None, 'filled_qty': float(order.filled_qty) if order.filled_qty else 0, 'filled_avg_price': float(order.filled_avg_price) if order.filled_avg_price else None}\n        logger.info(f'Order submitted successfully: {order.id} - {side.upper()} {symbol} ${amount_usd:.2f}')\n        return order_info\n    except APIError as e:\n        logger.error(f'Order execution failed: {e}')\n        raise OrderExecutionError(f'Failed to execute order: {e}') from e\n    except Exception as e:\n        logger.error(f'Unexpected error executing order: {e}')\n        raise OrderExecutionError(f'Unexpected error: {e}') from e"
    },
    {
      "name": "set_stop_loss",
      "line": 414,
      "code": "def set_stop_loss(self, symbol: str, qty: float, stop_price: float) -> Dict[str, Any]:\n    \"\"\"\n        Set a stop-loss order to limit potential losses.\n\n        Args:\n            symbol: Stock or ETF symbol\n            qty: Quantity of shares (supports fractional shares)\n            stop_price: Price at which to trigger the stop-loss\n\n        Returns:\n            Dictionary containing order information.\n\n        Raises:\n            OrderExecutionError: If stop-loss order creation fails.\n            ValueError: If parameters are invalid.\n\n        Example:\n            >>> trader = AlpacaTrader()\n            >>> order = trader.set_stop_loss('SPY', 1.5, 450.00)\n            >>> print(f\"Stop-loss set at ${order['stop_price']}\")\n        \"\"\"\n    if qty <= 0:\n        raise ValueError(f'Quantity must be positive. Got {qty}')\n    if stop_price <= 0:\n        raise ValueError(f'Stop price must be positive. Got {stop_price}')\n    symbol = symbol.upper().strip()\n    try:\n        logger.info(f'Setting stop-loss: {symbol} qty={qty} at ${stop_price:.2f}')\n        order: Order = self.api.submit_order(symbol=symbol, qty=qty, side='sell', type='stop', time_in_force='gtc', stop_price=stop_price)\n        order_info = {'id': order.id, 'client_order_id': order.client_order_id, 'symbol': order.symbol, 'qty': float(order.qty), 'side': order.side, 'type': order.type, 'stop_price': float(order.stop_price), 'time_in_force': order.time_in_force, 'status': order.status, 'submitted_at': str(order.submitted_at)}\n        logger.info(f'Stop-loss order created: {order.id}')\n        return order_info\n    except APIError as e:\n        logger.error(f'Failed to set stop-loss: {e}')\n        raise OrderExecutionError(f'Stop-loss creation failed: {e}') from e\n    except Exception as e:\n        logger.error(f'Unexpected error setting stop-loss: {e}')\n        raise OrderExecutionError(f'Unexpected error: {e}') from e"
    },
    {
      "name": "set_take_profit",
      "line": 480,
      "code": "def set_take_profit(self, symbol: str, qty: float, limit_price: float) -> Dict[str, Any]:\n    \"\"\"\n        Set a take-profit order to lock in gains.\n\n        Args:\n            symbol: Stock or ETF symbol\n            qty: Quantity of shares (supports fractional shares)\n            limit_price: Price at which to take profit\n\n        Returns:\n            Dictionary containing order information.\n\n        Raises:\n            OrderExecutionError: If take-profit order creation fails.\n            ValueError: If parameters are invalid.\n\n        Example:\n            >>> trader = AlpacaTrader()\n            >>> order = trader.set_take_profit('SPY', 1.5, 480.00)\n            >>> print(f\"Take-profit set at ${order['limit_price']}\")\n        \"\"\"\n    if qty <= 0:\n        raise ValueError(f'Quantity must be positive. Got {qty}')\n    if limit_price <= 0:\n        raise ValueError(f'Limit price must be positive. Got {limit_price}')\n    symbol = symbol.upper().strip()\n    try:\n        logger.info(f'Setting take-profit: {symbol} qty={qty} at ${limit_price:.2f}')\n        order: Order = self.api.submit_order(symbol=symbol, qty=qty, side='sell', type='limit', time_in_force='gtc', limit_price=limit_price)\n        order_info = {'id': order.id, 'client_order_id': order.client_order_id, 'symbol': order.symbol, 'qty': float(order.qty), 'side': order.side, 'type': order.type, 'limit_price': float(order.limit_price), 'time_in_force': order.time_in_force, 'status': order.status, 'submitted_at': str(order.submitted_at)}\n        logger.info(f'Take-profit order created: {order.id}')\n        return order_info\n    except APIError as e:\n        logger.error(f'Failed to set take-profit: {e}')\n        raise OrderExecutionError(f'Take-profit creation failed: {e}') from e\n    except Exception as e:\n        logger.error(f'Unexpected error setting take-profit: {e}')\n        raise OrderExecutionError(f'Unexpected error: {e}') from e"
    },
    {
      "name": "get_portfolio_performance",
      "line": 548,
      "code": "def get_portfolio_performance(self) -> Dict[str, Any]:\n    \"\"\"\n        Get portfolio performance metrics including profit/loss and returns.\n\n        Returns:\n            Dictionary containing performance metrics:\n                - equity: Current equity\n                - profit_loss: Total profit/loss in dollars\n                - profit_loss_pct: Profit/loss percentage\n                - total_return: Total return percentage\n                - positions_count: Number of open positions\n                - cash: Available cash\n                -\n\n        Raises:\n            AccountError: If portfolio data retrieval fails.\n\n        Example:\n            >>> trader = AlpacaTrader()\n            >>> performance = trader.get_portfolio_performance()\n            >>> print(f\"Total return: {performance['total_return']:.2f}%\")\n        \"\"\"\n    try:\n        account: Account = self.api.get_account()\n        positions = self.api.list_positions()\n        equity = float(account.equity)\n        last_equity = float(account.last_equity)\n        profit_loss = equity - last_equity\n        profit_loss_pct = profit_loss / last_equity * 100 if last_equity > 0 else 0\n        initial_value = float(account.last_equity)\n        current_value = equity\n        total_return = (current_value - initial_value) / initial_value * 100 if initial_value > 0 else 0\n        performance = {'equity': equity, 'last_equity': last_equity, 'profit_loss': profit_loss, 'profit_loss_pct': profit_loss_pct, 'total_return': total_return, 'positions_count': len(positions), 'cash': float(account.cash), 'buying_power': float(account.buying_power), 'portfolio_value': float(account.portfolio_value), 'timestamp': datetime.now().isoformat()}\n        logger.info(f'Portfolio performance: P/L ${profit_loss:.2f} ({profit_loss_pct:.2f}%), {len(positions)} positions')\n        return performance\n    except APIError as e:\n        logger.error(f'Failed to retrieve portfolio performance: {e}')\n        raise AccountError(f'Portfolio performance retrieval failed: {e}') from e\n    except Exception as e:\n        logger.error(f'Unexpected error retrieving portfolio performance: {e}')\n        raise AccountError(f'Unexpected error: {e}') from e"
    },
    {
      "name": "get_positions",
      "line": 620,
      "code": "def get_positions(self) -> List[Dict[str, Any]]:\n    \"\"\"\n        Get all current portfolio positions.\n\n        Returns:\n            List of dictionaries, each containing position information:\n                - symbol: Asset symbol\n                - qty: Quantity held\n                - avg_entry_price: Average entry price\n                - current_price: Current market price\n                - market_value: Current market value\n                - cost_basis: Total cost basis\n                - unrealized_pl: Unrealized profit/loss\n                - unrealized_plpc: Unrealized P/L percentage\n                - side: Long or short\n\n        Raises:\n            AccountError: If positions retrieval fails.\n\n        Example:\n            >>> trader = AlpacaTrader()\n            >>> positions = trader.get_positions()\n            >>> for pos in positions:\n            ...     print(f\"{pos['symbol']}: {pos['qty']} shares, \"\n            ...           f\"P/L: ${pos['unrealized_pl']:.2f}\")\n        \"\"\"\n    try:\n        positions: List[Position] = self.api.list_positions()\n        positions_data = []\n        for pos in positions:\n            position_info = {'symbol': pos.symbol, 'qty': float(pos.qty), 'avg_entry_price': float(pos.avg_entry_price), 'current_price': float(pos.current_price), 'market_value': float(pos.market_value), 'cost_basis': float(pos.cost_basis), 'unrealized_pl': float(pos.unrealized_pl), 'unrealized_plpc': float(pos.unrealized_plpc) * 100, 'unrealized_intraday_pl': float(pos.unrealized_intraday_pl), 'unrealized_intraday_plpc': float(pos.unrealized_intraday_plpc) * 100, 'side': pos.side, 'exchange': pos.exchange}\n            positions_data.append(position_info)\n        logger.info(f'Retrieved {len(positions_data)} positions')\n        return positions_data\n    except APIError as e:\n        logger.error(f'Failed to retrieve positions: {e}')\n        raise AccountError(f'Positions retrieval failed: {e}') from e\n    except Exception as e:\n        logger.error(f'Unexpected error retrieving positions: {e}')\n        raise AccountError(f'Unexpected error: {e}') from e"
    },
    {
      "name": "get_historical_bars",
      "line": 679,
      "code": "def get_historical_bars(self, symbol: str, timeframe: str='1Day', limit: int=100) -> List[Dict[str, Any]]:\n    \"\"\"\n        Get historical price bars (OHLCV data) for a symbol.\n\n        Args:\n            symbol: Stock or ETF symbol\n            timeframe: Bar timeframe - '1Min', '5Min', '15Min', '1Hour', '1Day'\n                      Default is '1Day'\n            limit: Number of bars to retrieve (max 10000). Default is 100.\n\n        Returns:\n            List of dictionaries containing bar data:\n                - timestamp: Bar timestamp\n                - open: Opening price\n                - high: High price\n                - low: Low price\n                - close: Closing price\n                - volume: Trading volume\n\n        Raises:\n            MarketDataError: If historical data retrieval fails.\n            ValueError: If parameters are invalid.\n\n        Example:\n            >>> trader = AlpacaTrader()\n            >>> bars = trader.get_historical_bars('SPY', timeframe='1Day', limit=30)\n            >>> for bar in bars[-5:]:\n            ...     print(f\"{bar['timestamp']}: Close ${bar['close']:.2f}\")\n        \"\"\"\n    valid_timeframes = ['1Min', '5Min', '15Min', '1Hour', '1Day']\n    if timeframe not in valid_timeframes:\n        raise ValueError(f\"Invalid timeframe '{timeframe}'. Must be one of {valid_timeframes}\")\n    if limit <= 0 or limit > 10000:\n        raise ValueError(f'Limit must be between 1 and 10000. Got {limit}')\n    symbol = symbol.upper().strip()\n    try:\n        logger.info(f'Fetching {limit} {timeframe} bars for {symbol}')\n        barset: BarSet = self.api.get_bars(symbol, timeframe, limit=limit)\n        bars_data = []\n        if symbol in barset:\n            for bar in barset[symbol]:\n                bar_info = {'timestamp': str(bar.t), 'open': float(bar.o), 'high': float(bar.h), 'low': float(bar.l), 'close': float(bar.c), 'volume': int(bar.v)}\n                bars_data.append(bar_info)\n        logger.info(f'Retrieved {len(bars_data)} bars for {symbol}')\n        return bars_data\n    except APIError as e:\n        logger.error(f'Failed to retrieve historical bars: {e}')\n        raise MarketDataError(f'Historical data retrieval failed: {e}') from e\n    except Exception as e:\n        logger.error(f'Unexpected error retrieving historical bars: {e}')\n        raise MarketDataError(f'Unexpected error: {e}') from e"
    },
    {
      "name": "cancel_all_orders",
      "line": 751,
      "code": "def cancel_all_orders(self) -> Dict[str, Any]:\n    \"\"\"\n        Cancel all open orders.\n\n        Returns:\n            Dictionary containing cancellation results:\n                - cancelled_count: Number of orders cancelled\n                - status: Success status\n\n        Raises:\n            OrderExecutionError: If order cancellation fails.\n\n        Example:\n            >>> trader = AlpacaTrader()\n            >>> result = trader.cancel_all_orders()\n            >>> print(f\"Cancelled {result['cancelled_count']} orders\")\n        \"\"\"\n    try:\n        logger.info('Cancelling all open orders')\n        open_orders = self.api.list_orders(status='open')\n        order_count = len(open_orders)\n        self.api.cancel_all_orders()\n        result = {'cancelled_count': order_count, 'status': 'success', 'timestamp': datetime.now().isoformat()}\n        logger.info(f'Successfully cancelled {order_count} orders')\n        return result\n    except APIError as e:\n        logger.error(f'Failed to cancel orders: {e}')\n        raise OrderExecutionError(f'Order cancellation failed: {e}') from e\n    except Exception as e:\n        logger.error(f'Unexpected error cancelling orders: {e}')\n        raise OrderExecutionError(f'Unexpected error: {e}') from e"
    },
    {
      "name": "get_order_status",
      "line": 794,
      "code": "def get_order_status(self, order_id: str) -> Dict[str, Any]:\n    \"\"\"\n        Get the status of a specific order.\n\n        Args:\n            order_id: The order ID to check\n\n        Returns:\n            Dictionary containing order status information.\n\n        Raises:\n            OrderExecutionError: If order status retrieval fails.\n\n        Example:\n            >>> trader = AlpacaTrader()\n            >>> status = trader.get_order_status('order-id-123')\n            >>> print(f\"Order status: {status['status']}\")\n        \"\"\"\n    try:\n        order: Order = self.api.get_order(order_id)\n        order_info = {'id': order.id, 'symbol': order.symbol, 'qty': float(order.qty) if order.qty else None, 'notional': float(order.notional) if order.notional else None, 'side': order.side, 'type': order.type, 'status': order.status, 'filled_qty': float(order.filled_qty) if order.filled_qty else 0, 'filled_avg_price': float(order.filled_avg_price) if order.filled_avg_price else None, 'submitted_at': str(order.submitted_at), 'filled_at': str(order.filled_at) if order.filled_at else None}\n        logger.info(f'Retrieved status for order {order_id}: {order.status}')\n        return order_info\n    except APIError as e:\n        logger.error(f'Failed to get order status: {e}')\n        raise OrderExecutionError(f'Order status retrieval failed: {e}') from e\n    except Exception as e:\n        logger.error(f'Unexpected error getting order status: {e}')\n        raise OrderExecutionError(f'Unexpected error: {e}') from e"
    },
    {
      "name": "cancel_order",
      "line": 841,
      "code": "def cancel_order(self, order_id: str) -> Dict[str, Any]:\n    \"\"\"\n        Cancel a specific order.\n\n        Args:\n            order_id: The order ID to cancel\n\n        Returns:\n            Dictionary containing cancellation confirmation.\n\n        Raises:\n            OrderExecutionError: If order cancellation fails.\n\n        Example:\n            >>> trader = AlpacaTrader()\n            >>> result = trader.cancel_order('order-id-123')\n            >>> print(f\"Order cancelled: {result['status']}\")\n        \"\"\"\n    try:\n        logger.info(f'Cancelling order {order_id}')\n        self.api.cancel_order(order_id)\n        result = {'order_id': order_id, 'status': 'cancelled', 'timestamp': datetime.now().isoformat()}\n        logger.info(f'Successfully cancelled order {order_id}')\n        return result\n    except APIError as e:\n        logger.error(f'Failed to cancel order: {e}')\n        raise OrderExecutionError(f'Order cancellation failed: {e}') from e\n    except Exception as e:\n        logger.error(f'Unexpected error cancelling order: {e}')\n        raise OrderExecutionError(f'Unexpected error: {e}') from e"
    },
    {
      "name": "close_position",
      "line": 879,
      "code": "def close_position(self, symbol: str) -> Dict[str, Any]:\n    \"\"\"\n        Close an entire position for a symbol.\n\n        Args:\n            symbol: Stock or ETF symbol to close\n\n        Returns:\n            Dictionary containing the closing order information.\n\n        Raises:\n            OrderExecutionError: If position closure fails.\n\n        Example:\n            >>> trader = AlpacaTrader()\n            >>> result = trader.close_position('SPY')\n            >>> print(f\"Closed position: {result['symbol']}\")\n        \"\"\"\n    symbol = symbol.upper().strip()\n    try:\n        logger.info(f'Closing position for {symbol}')\n        order: Order = self.api.close_position(symbol)\n        order_info = {'id': order.id, 'symbol': order.symbol, 'qty': float(order.qty) if order.qty else None, 'side': order.side, 'type': order.type, 'status': order.status, 'submitted_at': str(order.submitted_at)}\n        logger.info(f'Successfully closed position for {symbol}')\n        return order_info\n    except APIError as e:\n        logger.error(f'Failed to close position: {e}')\n        raise OrderExecutionError(f'Position closure failed: {e}') from e\n    except Exception as e:\n        logger.error(f'Unexpected error closing position: {e}')\n        raise OrderExecutionError(f'Unexpected error: {e}') from e"
    },
    {
      "name": "close_all_positions",
      "line": 924,
      "code": "def close_all_positions(self) -> Dict[str, Any]:\n    \"\"\"\n        Close all open positions.\n\n        Returns:\n            Dictionary containing closure results:\n                - closed_count: Number of positions closed\n                - closed_symbols: List of symbols closed\n\n        Raises:\n            OrderExecutionError: If position closure fails.\n\n        Example:\n            >>> trader = AlpacaTrader()\n            >>> result = trader.close_all_positions()\n            >>> print(f\"Closed {result['closed_count']} positions\")\n        \"\"\"\n    try:\n        logger.info('Closing all positions')\n        positions = self.api.list_positions()\n        symbols = [pos.symbol for pos in positions]\n        self.api.close_all_positions()\n        result = {'closed_count': len(symbols), 'closed_symbols': symbols, 'status': 'success', 'timestamp': datetime.now().isoformat()}\n        logger.info(f'Successfully closed {len(symbols)} positions: {symbols}')\n        return result\n    except APIError as e:\n        logger.error(f'Failed to close all positions: {e}')\n        raise OrderExecutionError(f'Position closure failed: {e}') from e\n    except Exception as e:\n        logger.error(f'Unexpected error closing all positions: {e}')\n        raise OrderExecutionError(f'Unexpected error: {e}') from e"
    }
  ]
}
