{
  "dead_imports": [
    {
      "line": 15,
      "module": "Tuple",
      "statement": "from typing import Dict, Optional, Tuple"
    }
  ],
  "commented_blocks": [],
  "empty_functions": [],
  "unused_variables": [],
  "all_functions": [
    {
      "name": "__init__",
      "line": 55,
      "code": "def __init__(self, max_daily_loss_pct: float=2.0, max_position_size_pct: float=10.0, max_drawdown_pct: float=10.0, max_consecutive_losses: int=3):\n    \"\"\"\n        Initialize the Risk Manager with configurable parameters.\n\n        Args:\n            max_daily_loss_pct: Maximum daily loss percentage (default: 2.0%)\n            max_position_size_pct: Maximum position size percentage (default: 10.0%)\n            max_drawdown_pct: Maximum drawdown percentage (default: 10.0%)\n            max_consecutive_losses: Maximum consecutive losses before warning (default: 3)\n        \"\"\"\n    self.max_daily_loss_pct = max_daily_loss_pct\n    self.max_position_size_pct = max_position_size_pct\n    self.max_drawdown_pct = max_drawdown_pct\n    self.max_consecutive_losses = max_consecutive_losses\n    self.metrics = RiskMetrics()\n    self.peak_account_value: float = 0.0\n    self.alerts: list = []\n    print(f'[RISK MANAGER] Initialized with parameters:')\n    print(f'  - Max Daily Loss: {max_daily_loss_pct}%')\n    print(f'  - Max Position Size: {max_position_size_pct}%')\n    print(f'  - Max Drawdown: {max_drawdown_pct}%')\n    print(f'  - Max Consecutive Losses: {max_consecutive_losses}')"
    },
    {
      "name": "can_trade",
      "line": 86,
      "code": "def can_trade(self, account_value: float, daily_pl: float, account_info: Optional[Dict[str, any]]=None) -> bool:\n    \"\"\"\n        Determine if trading is allowed based on current risk parameters.\n\n        Checks circuit breakers including daily loss limits, drawdown limits,\n        and Pattern Day Trader (PDT) restrictions to determine if new trades can be executed.\n\n        Args:\n            account_value: Current account value\n            daily_pl: Today's profit/loss\n            account_info: Optional account info dict with 'pattern_day_trader' and 'equity' keys\n\n        Returns:\n            bool: True if trading is allowed, False otherwise\n        \"\"\"\n    if account_info:\n        is_pdt = account_info.get('pattern_day_trader', False)\n        equity = account_info.get('equity', account_value)\n        daytrade_count = account_info.get('daytrade_count', 0)\n        if daytrade_count >= 3 and equity < 25000.0:\n            self._send_alert(severity='CRITICAL', message=f'\ud83d\udea8 PDT PROTECTION: Daytrade count ({daytrade_count}) >= 3 and equity ${equity:,.2f} < $25,000. Trading blocked to prevent account lock.', details={'equity': equity, 'daytrade_count': daytrade_count, 'pattern_day_trader': is_pdt, 'minimum_required': 25000.0})\n            self.metrics.circuit_breaker_triggered = True\n            return False\n        if is_pdt and equity < 25000.0:\n            self._send_alert(severity='CRITICAL', message=f'Pattern Day Trader restriction: Account equity ${equity:,.2f} below $25,000 minimum. Day trading restricted.', details={'equity': equity, 'pattern_day_trader': is_pdt, 'minimum_required': 25000.0})\n            self.metrics.circuit_breaker_triggered = True\n            return False\n    if account_value > self.peak_account_value:\n        self.peak_account_value = account_value\n    daily_loss_pct = daily_pl / account_value * 100 if account_value > 0 else 0\n    if daily_loss_pct < -self.max_daily_loss_pct:\n        self._send_alert(severity='CRITICAL', message=f'Daily loss limit breached: {daily_loss_pct:.2f}% (limit: {-self.max_daily_loss_pct}%)', details={'daily_pl': daily_pl, 'account_value': account_value})\n        self.metrics.circuit_breaker_triggered = True\n        return False\n    if self.peak_account_value > 0:\n        current_drawdown_pct = (self.peak_account_value - account_value) / self.peak_account_value * 100\n        if current_drawdown_pct > self.max_drawdown_pct:\n            self._send_alert(severity='CRITICAL', message=f'Maximum drawdown breached: {current_drawdown_pct:.2f}% (limit: {self.max_drawdown_pct}%)', details={'peak_value': self.peak_account_value, 'current_value': account_value})\n            self.metrics.circuit_breaker_triggered = True\n            self.metrics.max_drawdown_reached = max(self.metrics.max_drawdown_reached, current_drawdown_pct)\n            return False\n    if self.metrics.consecutive_losses >= self.max_consecutive_losses:\n        self._send_alert(severity='WARNING', message=f'Maximum consecutive losses reached: {self.metrics.consecutive_losses}', details={'consecutive_losses': self.metrics.consecutive_losses})\n    return True"
    },
    {
      "name": "calculate_position_size",
      "line": 186,
      "code": "def calculate_position_size(self, account_value: float, risk_per_trade_pct: float=1.0, price_per_share: Optional[float]=None) -> float:\n    \"\"\"\n        Calculate appropriate position size based on risk parameters.\n\n        Uses the risk percentage method to determine position size while\n        respecting maximum position size limits.\n\n        Args:\n            account_value: Current account value\n            risk_per_trade_pct: Risk per trade as percentage of account (default: 1.0%)\n            price_per_share: Price per share for share calculation (optional)\n\n        Returns:\n            float: Position size in dollars (or shares if price_per_share provided)\n        \"\"\"\n    if account_value <= 0:\n        return 0.0\n    risk_amount = account_value * (risk_per_trade_pct / 100)\n    max_position_value = account_value * (self.max_position_size_pct / 100)\n    position_value = min(risk_amount, max_position_value)\n    if price_per_share and price_per_share > 0:\n        position_size = position_value / price_per_share\n        return int(position_size)\n    return position_value"
    },
    {
      "name": "validate_trade",
      "line": 223,
      "code": "def validate_trade(self, symbol: str, amount: float, sentiment_score: float, account_value: float, trade_type: str='BUY', account_info: Optional[Dict[str, any]]=None) -> Dict[str, any]:\n    \"\"\"\n        Validate a trade before execution.\n\n        Performs comprehensive validation checks including position sizing,\n        sentiment score thresholds, risk limits, and Pattern Day Trader restrictions.\n\n        Args:\n            symbol: Trading symbol\n            amount: Trade amount in dollars\n            sentiment_score: Sentiment analysis score (-1 to 1)\n            account_value: Current account value\n            trade_type: Type of trade (BUY/SELL)\n            account_info: Optional account info dict with PDT and equity info\n\n        Returns:\n            dict: Validation result with 'valid' flag and 'reason' for rejection\n        \"\"\"\n    validation_result = {'valid': True, 'symbol': symbol, 'amount': amount, 'trade_type': trade_type, 'warnings': [], 'reason': None}\n    if self.metrics.circuit_breaker_triggered:\n        validation_result['valid'] = False\n        validation_result['reason'] = 'Circuit breaker triggered - trading suspended'\n        return validation_result\n    if account_info:\n        is_pdt = account_info.get('pattern_day_trader', False)\n        equity = account_info.get('equity', account_value)\n        daytrade_count = account_info.get('daytrade_count', 0)\n        if daytrade_count >= 3 and equity < 25000.0:\n            validation_result['valid'] = False\n            validation_result['reason'] = f'\ud83d\udea8 PDT PROTECTION: Daytrade count ({daytrade_count}) >= 3 and equity ${equity:,.2f} < $25,000. Trading blocked to prevent account lock.'\n            validation_result['warnings'].append('PDT restriction: Account must maintain $25,000 equity for unlimited day trading')\n            return validation_result\n        if daytrade_count >= 2 and equity < 25000.0:\n            validation_result['warnings'].append(f'\u26a0\ufe0f  Warning: Daytrade count ({daytrade_count}/3). Next trade will trigger PDT restriction if equity < $25,000')\n        if is_pdt and equity < 25000.0:\n            validation_result['valid'] = False\n            validation_result['reason'] = f'Pattern Day Trader restriction: Account equity ${equity:,.2f} below $25,000 minimum required for day trading'\n            validation_result['warnings'].append('PDT restriction: Account must maintain $25,000 equity for unlimited day trading')\n            return validation_result\n    if amount <= 0:\n        validation_result['valid'] = False\n        validation_result['reason'] = 'Trade amount must be positive'\n        return validation_result\n    position_size_pct = amount / account_value * 100 if account_value > 0 else 0\n    if position_size_pct > self.max_position_size_pct:\n        validation_result['valid'] = False\n        validation_result['reason'] = f'Position size {position_size_pct:.2f}% exceeds limit of {self.max_position_size_pct}%'\n        return validation_result\n    if not -1.0 <= sentiment_score <= 1.0:\n        validation_result['valid'] = False\n        validation_result['reason'] = f'Invalid sentiment score: {sentiment_score} (must be between -1 and 1)'\n        return validation_result\n    if abs(sentiment_score) < 0.3:\n        validation_result['warnings'].append(f'Weak sentiment signal: {sentiment_score:.2f} (consider stronger signals)')\n    if trade_type.upper() == 'BUY' and sentiment_score < 0:\n        validation_result['warnings'].append(f'Buy trade with negative sentiment: {sentiment_score:.2f}')\n    elif trade_type.upper() == 'SELL' and sentiment_score > 0:\n        validation_result['warnings'].append(f'Sell trade with positive sentiment: {sentiment_score:.2f}')\n    if self.metrics.consecutive_losses >= self.max_consecutive_losses:\n        validation_result['warnings'].append(f'Trading after {self.metrics.consecutive_losses} consecutive losses - exercise caution')\n    if validation_result['warnings']:\n        for warning in validation_result['warnings']:\n            self._send_alert(severity='INFO', message=warning, details={'symbol': symbol})\n    return validation_result"
    },
    {
      "name": "check_circuit_breakers",
      "line": 357,
      "code": "def check_circuit_breakers(self, account_info: Dict[str, float]) -> Dict[str, any]:\n    \"\"\"\n        Check all circuit breaker conditions.\n\n        Evaluates current account state against all configured risk limits\n        and returns detailed status information.\n\n        Args:\n            account_info: Dictionary with 'account_value' and 'daily_pl' keys\n\n        Returns:\n            dict: Circuit breaker status with all risk metrics\n        \"\"\"\n    account_value = account_info.get('account_value', 0.0)\n    daily_pl = account_info.get('daily_pl', 0.0)\n    if account_value > self.peak_account_value:\n        self.peak_account_value = account_value\n    daily_loss_pct = daily_pl / account_value * 100 if account_value > 0 else 0\n    current_drawdown_pct = 0.0\n    if self.peak_account_value > 0:\n        current_drawdown_pct = (self.peak_account_value - account_value) / self.peak_account_value * 100\n    status = {'trading_allowed': True, 'daily_loss': {'current_pct': daily_loss_pct, 'limit_pct': -self.max_daily_loss_pct, 'breached': daily_loss_pct < -self.max_daily_loss_pct}, 'drawdown': {'current_pct': current_drawdown_pct, 'limit_pct': self.max_drawdown_pct, 'breached': current_drawdown_pct > self.max_drawdown_pct}, 'consecutive_losses': {'current': self.metrics.consecutive_losses, 'limit': self.max_consecutive_losses, 'breached': self.metrics.consecutive_losses >= self.max_consecutive_losses}, 'account_value': account_value, 'peak_account_value': self.peak_account_value, 'daily_pl': daily_pl}\n    if status['daily_loss']['breached'] or status['drawdown']['breached']:\n        status['trading_allowed'] = False\n        self.metrics.circuit_breaker_triggered = True\n    return status"
    },
    {
      "name": "record_trade_result",
      "line": 415,
      "code": "def record_trade_result(self, profit_loss: float) -> None:\n    \"\"\"\n        Record the result of a completed trade.\n\n        Updates internal metrics including consecutive losses, win/loss counts,\n        and daily P&L tracking.\n\n        Args:\n            profit_loss: Profit or loss from the trade (positive for profit, negative for loss)\n        \"\"\"\n    self.metrics.total_trades += 1\n    self.metrics.daily_trades += 1\n    self.metrics.daily_pl += profit_loss\n    if profit_loss > 0:\n        self.metrics.winning_trades += 1\n        self.metrics.consecutive_losses = 0\n        print(f'[RISK MANAGER] Trade result: PROFIT ${profit_loss:.2f}')\n    elif profit_loss < 0:\n        self.metrics.losing_trades += 1\n        self.metrics.consecutive_losses += 1\n        self.metrics.max_consecutive_losses = max(self.metrics.max_consecutive_losses, self.metrics.consecutive_losses)\n        print(f'[RISK MANAGER] Trade result: LOSS ${profit_loss:.2f}')\n        if self.metrics.consecutive_losses >= self.max_consecutive_losses:\n            self._send_alert(severity='WARNING', message=f'Consecutive losses: {self.metrics.consecutive_losses}', details={'total_loss': profit_loss})\n    else:\n        print(f'[RISK MANAGER] Trade result: BREAKEVEN')\n    win_rate = self.metrics.winning_trades / self.metrics.total_trades * 100 if self.metrics.total_trades > 0 else 0\n    print(f'[RISK MANAGER] Daily P&L: ${self.metrics.daily_pl:.2f} | Win Rate: {win_rate:.1f}%')"
    },
    {
      "name": "reset_daily_counters",
      "line": 461,
      "code": "def reset_daily_counters(self) -> None:\n    \"\"\"\n        Reset daily counters and metrics.\n\n        Should be called at the start of each trading day to reset\n        daily P&L and trade counts.\n        \"\"\"\n    current_date = datetime.now().strftime('%Y-%m-%d')\n    print(f'[RISK MANAGER] Resetting daily counters')\n    print(f'  - Previous Daily P&L: ${self.metrics.daily_pl:.2f}')\n    print(f'  - Previous Daily Trades: {self.metrics.daily_trades}')\n    self.metrics.daily_pl = 0.0\n    self.metrics.daily_trades = 0\n    self.metrics.circuit_breaker_triggered = False\n    self.metrics.last_reset_date = current_date\n    self.alerts.clear()\n    print(f'[RISK MANAGER] Daily counters reset for {current_date}')"
    },
    {
      "name": "get_risk_metrics",
      "line": 482,
      "code": "def get_risk_metrics(self) -> Dict[str, any]:\n    \"\"\"\n        Get current risk metrics and statistics.\n\n        Returns:\n            dict: Comprehensive risk metrics including trades, P&L, and limits\n        \"\"\"\n    win_rate = 0.0\n    if self.metrics.total_trades > 0:\n        win_rate = self.metrics.winning_trades / self.metrics.total_trades * 100\n    return {'daily_metrics': {'daily_pl': self.metrics.daily_pl, 'daily_trades': self.metrics.daily_trades, 'last_reset': self.metrics.last_reset_date}, 'trade_statistics': {'total_trades': self.metrics.total_trades, 'winning_trades': self.metrics.winning_trades, 'losing_trades': self.metrics.losing_trades, 'win_rate_pct': round(win_rate, 2), 'consecutive_losses': self.metrics.consecutive_losses, 'max_consecutive_losses': self.metrics.max_consecutive_losses}, 'risk_limits': {'max_daily_loss_pct': self.max_daily_loss_pct, 'max_position_size_pct': self.max_position_size_pct, 'max_drawdown_pct': self.max_drawdown_pct, 'max_consecutive_losses_limit': self.max_consecutive_losses}, 'account_metrics': {'peak_account_value': self.peak_account_value, 'max_drawdown_reached': self.metrics.max_drawdown_reached, 'circuit_breaker_triggered': self.metrics.circuit_breaker_triggered}, 'alerts': self.alerts[-10:]}"
    },
    {
      "name": "_send_alert",
      "line": 521,
      "code": "def _send_alert(self, severity: str, message: str, details: Optional[Dict]=None) -> None:\n    \"\"\"\n        Send a risk management alert.\n\n        Internal method to generate and store alerts. Currently prints to console\n        but can be extended to send emails, SMS, or push notifications.\n\n        Args:\n            severity: Alert severity level (INFO, WARNING, CRITICAL)\n            message: Alert message\n            details: Additional details dictionary (optional)\n        \"\"\"\n    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n    alert = {'timestamp': timestamp, 'severity': severity, 'message': message, 'details': details or {}}\n    self.alerts.append(alert)\n    severity_symbols = {'INFO': '\u2139\ufe0f', 'WARNING': '\u26a0\ufe0f', 'CRITICAL': '\ud83d\udea8'}\n    symbol = severity_symbols.get(severity, '\u2022')\n    print(f'\\n{symbol} [RISK ALERT - {severity}] {timestamp}')\n    print(f'  Message: {message}')\n    if details:\n        print(f'  Details: {details}')\n    print()"
    }
  ]
}
