{
  "dead_imports": [
    {
      "line": 5,
      "module": "annotations",
      "statement": "from __future__ import annotations"
    }
  ],
  "commented_blocks": [],
  "empty_functions": [],
  "unused_variables": [],
  "all_functions": [
    {
      "name": "__init__",
      "line": 27,
      "code": "def __init__(self, lookback_days: int=60, symbols: Iterable[str] | None=None) -> None:\n    super().__init__('data-agent')\n    self.lookback_days = lookback_days\n    self._default_symbols: List[str] = list(symbols) if symbols else DEFAULT_SYMBOLS\n    self._provider = get_market_data_provider()\n    self._collector = DataCollector()"
    },
    {
      "name": "_load_watchlist_symbols",
      "line": 39,
      "code": "def _load_watchlist_symbols(self) -> List[str]:\n    \"\"\"Extract symbols from the tier2 watchlist JSON if available.\"\"\"\n    if not WATCHLIST_PATH.exists():\n        return []\n    try:\n        with WATCHLIST_PATH.open('r', encoding='utf-8') as fh:\n            data = json.load(fh)\n        symbols = set()\n        for entry in data.get('current_holdings', []):\n            symbol = entry.get('symbol')\n            if symbol:\n                symbols.add(symbol.upper())\n        for entry in data.get('watchlist', []):\n            symbol = entry.get('symbol')\n            if symbol:\n                symbols.add(symbol.upper())\n        return sorted(symbols)\n    except Exception as exc:\n        logger.warning('Failed to parse tier2 watchlist: %s', exc)\n        return []"
    },
    {
      "name": "_resolve_symbol_universe",
      "line": 60,
      "code": "def _resolve_symbol_universe(self, context: RunContext) -> List[str]:\n    configured = context.config.get('symbols')\n    if configured:\n        return [sym.upper() for sym in configured]\n    from_watchlist = self._load_watchlist_symbols()\n    if from_watchlist:\n        return from_watchlist\n    return self._default_symbols"
    },
    {
      "name": "_summarize_frame",
      "line": 69,
      "code": "def _summarize_frame(self, df: pd.DataFrame) -> Dict[str, Any]:\n    if df.empty:\n        return {'rows': 0}\n    latest_row = df.iloc[-1]\n    return {'rows': len(df), 'start': df.index[0].isoformat(), 'end': df.index[-1].isoformat(), 'latest_close': float(latest_row['Close']), 'latest_volume': float(latest_row['Volume'])}"
    },
    {
      "name": "execute",
      "line": 84,
      "code": "def execute(self, context: RunContext) -> AgentResult:\n    symbols = self._resolve_symbol_universe(context)\n    logger.info('Fetching market data for symbols: %s', ', '.join(symbols))\n    summaries: Dict[str, Any] = {}\n    frames: Dict[str, pd.DataFrame] = {}\n    warnings: List[str] = []\n    for symbol in symbols:\n        try:\n            df = self._provider.get_daily_bars(symbol, lookback_days=self.lookback_days)\n            if df.empty:\n                warnings.append(f'{symbol}: received empty dataframe')\n                continue\n            self._collector.save_to_csv(symbol, df)\n            frames[symbol] = df\n            summaries[symbol] = self._summarize_frame(df)\n        except Exception as exc:\n            logger.exception('Failed to load data for %s', symbol)\n            warnings.append(f'{symbol}: {exc}')\n    state_entry = context.state_cache.setdefault('market_data', {})\n    state_entry['frames'] = frames\n    state_entry['summaries'] = summaries\n    payload = {'symbols': symbols, 'summaries': summaries, 'warnings': warnings}\n    succeeded = bool(summaries)\n    if not succeeded:\n        logger.warning('DataAgent completed with no successful fetches.')\n    return AgentResult(name=self.agent_name, succeeded=succeeded, payload=payload, warnings=warnings)"
    }
  ]
}
