{
  "dead_imports": [
    {
      "line": 16,
      "module": "GrahamBuffettSafety",
      "statement": "from src.safety.graham_buffett_safety import ("
    },
    {
      "line": 16,
      "module": "SafetyRating",
      "statement": "from src.safety.graham_buffett_safety import ("
    }
  ],
  "commented_blocks": [],
  "empty_functions": [],
  "unused_variables": [],
  "all_functions": [
    {
      "name": "__init__",
      "line": 36,
      "code": "def __init__(self):\n    super().__init__(name='ValueDiscoveryAgent', role='Discover undervalued investment opportunities')\n    self.safety_analyzer = get_global_safety_analyzer()"
    },
    {
      "name": "analyze",
      "line": 43,
      "code": "def analyze(self, data: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"\n        Discover undervalued opportunities from watchlist.\n        \n        Args:\n            data: Contains watchlist (list of symbols) and optional market prices\n            \n        Returns:\n            List of undervalued opportunities ranked by safety and value\n        \"\"\"\n    watchlist = data.get('watchlist', [])\n    market_prices = data.get('market_prices', {})\n    if not watchlist:\n        return {'action': 'NO_OPPORTUNITIES', 'message': 'No symbols in watchlist', 'opportunities': []}\n    opportunities = []\n    for symbol in watchlist:\n        try:\n            market_price = market_prices.get(symbol)\n            if not market_price:\n                market_price = self._get_current_price(symbol)\n                if not market_price:\n                    continue\n            safety_analysis = self.safety_analyzer.analyze_safety(symbol=symbol, market_price=market_price, force_refresh=False)\n            if safety_analysis.margin_of_safety_pct is not None and safety_analysis.margin_of_safety_pct > 0:\n                opportunity = {'symbol': symbol, 'market_price': market_price, 'intrinsic_value': safety_analysis.intrinsic_value, 'margin_of_safety_pct': safety_analysis.margin_of_safety_pct, 'quality_score': safety_analysis.quality.quality_score if safety_analysis.quality else None, 'safety_rating': safety_analysis.safety_rating.value, 'reasons': safety_analysis.reasons, 'warnings': safety_analysis.warnings}\n                opportunity['opportunity_score'] = self._calculate_opportunity_score(opportunity)\n                opportunities.append(opportunity)\n        except Exception as e:\n            logger.warning(f'Error analyzing {symbol} for value discovery: {e}')\n            continue\n    opportunities.sort(key=lambda x: x.get('opportunity_score', 0), reverse=True)\n    memory_context = self.get_memory_context(limit=5)\n    prompt = self._build_discovery_prompt(opportunities[:10], memory_context)\n    llm_response = self.reason_with_llm(prompt)\n    analysis = self._combine_discovery_analysis(opportunities, llm_response)\n    self.log_decision(analysis)\n    return analysis"
    },
    {
      "name": "_calculate_opportunity_score",
      "line": 134,
      "code": "def _calculate_opportunity_score(self, opportunity: Dict[str, Any]) -> float:\n    \"\"\"Calculate composite opportunity score (0-100).\"\"\"\n    margin_pct = opportunity.get('margin_of_safety_pct', 0.0)\n    quality_score = opportunity.get('quality_score', 0.0)\n    safety_rating = opportunity.get('safety_rating', 'reject')\n    margin_score = min(margin_pct * 100, 50.0)\n    quality_component = quality_score / 100.0 * 40.0\n    rating_scores = {'excellent': 10, 'good': 7, 'acceptable': 4, 'poor': 1, 'reject': 0}\n    rating_component = rating_scores.get(safety_rating, 0)\n    total_score = margin_score + quality_component + rating_component\n    return round(total_score, 1)"
    },
    {
      "name": "_get_current_price",
      "line": 161,
      "code": "def _get_current_price(self, symbol: str) -> Optional[float]:\n    \"\"\"Get current market price for symbol.\"\"\"\n    try:\n        import yfinance as yf\n        ticker = yf.Ticker(symbol)\n        data = ticker.history(period='1d')\n        if not data.empty:\n            return float(data['Close'].iloc[-1])\n        return None\n    except Exception as e:\n        logger.warning(f'Error fetching price for {symbol}: {e}')\n        return None"
    },
    {
      "name": "_build_discovery_prompt",
      "line": 175,
      "code": "def _build_discovery_prompt(self, opportunities: List[Dict], memory_context: str) -> str:\n    \"\"\"Build LLM prompt for value discovery analysis.\"\"\"\n    opportunities_summary = ''\n    for i, opp in enumerate(opportunities[:5], 1):\n        opportunities_summary += f\"\\n{i}. {opp['symbol']}:\\n   - Market Price: ${opp['market_price']:.2f}\\n   - Intrinsic Value: ${opp['intrinsic_value']:.2f}\\n   - Margin of Safety: {opp['margin_of_safety_pct'] * 100:.1f}%\\n   - Quality Score: {opp['quality_score']:.1f}/100\\n   - Safety Rating: {opp['safety_rating'].upper()}\\n   - Opportunity Score: {opp['opportunity_score']:.1f}/100\\n\"\n    prompt = f'You are a Value Discovery Agent identifying the best investment opportunities.\\n\\nTOP OPPORTUNITIES:\\n{opportunities_summary}\\n\\n{memory_context}\\n\\nTASK: Provide value discovery analysis:\\n1. Best Opportunity (symbol and why)\\n2. Overall Market Assessment (VALUE-RICH / MIXED / OVERVALUED)\\n3. Recommended Action (BUY_NOW / WAIT / AVOID)\\n4. Top 3 Picks (ranked by safety and value)\\n5. Investment Strategy (how to approach these opportunities)\\n\\nFormat your response as:\\nBEST_OPPORTUNITY: [symbol and reasoning]\\nMARKET_ASSESSMENT: [VALUE-RICH/MIXED/OVERVALUED]\\nRECOMMENDED_ACTION: [BUY_NOW/WAIT/AVOID]\\nTOP_3_PICKS: [symbol1, symbol2, symbol3]\\nSTRATEGY: [investment strategy]'\n    return prompt"
    },
    {
      "name": "_combine_discovery_analysis",
      "line": 215,
      "code": "def _combine_discovery_analysis(self, opportunities: List[Dict], llm_response: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Combine opportunities with LLM insights.\"\"\"\n    llm_analysis = self._parse_llm_response(llm_response.get('reasoning', ''))\n    analysis = {'action': 'OPPORTUNITIES_FOUND' if opportunities else 'NO_OPPORTUNITIES', 'total_opportunities': len(opportunities), 'opportunities': opportunities, 'best_opportunity': llm_analysis.get('best_opportunity', ''), 'market_assessment': llm_analysis.get('market_assessment', 'MIXED'), 'recommended_action': llm_analysis.get('recommended_action', 'WAIT'), 'top_3_picks': llm_analysis.get('top_3_picks', []), 'strategy': llm_analysis.get('strategy', ''), 'full_reasoning': llm_response.get('reasoning', ''), 'timestamp': datetime.now().isoformat()}\n    return analysis"
    },
    {
      "name": "_parse_llm_response",
      "line": 237,
      "code": "def _parse_llm_response(self, reasoning: str) -> Dict[str, Any]:\n    \"\"\"Parse LLM response.\"\"\"\n    lines = reasoning.split('\\n')\n    analysis = {'best_opportunity': '', 'market_assessment': 'MIXED', 'recommended_action': 'WAIT', 'top_3_picks': [], 'strategy': ''}\n    for line in lines:\n        line = line.strip()\n        if line.startswith('BEST_OPPORTUNITY:'):\n            analysis['best_opportunity'] = line.split(':', 1)[1].strip()\n        elif line.startswith('MARKET_ASSESSMENT:'):\n            assessment = line.split(':')[1].strip().upper()\n            if assessment in ['VALUE-RICH', 'MIXED', 'OVERVALUED']:\n                analysis['market_assessment'] = assessment\n        elif line.startswith('RECOMMENDED_ACTION:'):\n            action = line.split(':')[1].strip().upper()\n            if action in ['BUY_NOW', 'WAIT', 'AVOID']:\n                analysis['recommended_action'] = action\n        elif line.startswith('TOP_3_PICKS:'):\n            picks_str = line.split(':')[1].strip()\n            picks = [p.strip() for p in picks_str.split(',')]\n            analysis['top_3_picks'] = picks[:3]\n        elif line.startswith('STRATEGY:'):\n            analysis['strategy'] = line.split(':', 1)[1].strip()\n    return analysis"
    }
  ]
}
