{
  "dead_imports": [
    {
      "line": 15,
      "module": "annotations",
      "statement": "from __future__ import annotations"
    },
    {
      "line": 23,
      "module": "List",
      "statement": "from typing import Dict, List, Optional, Tuple"
    }
  ],
  "commented_blocks": [],
  "empty_functions": [],
  "unused_variables": [],
  "all_functions": [
    {
      "name": "get_btc_signal",
      "line": 479,
      "code": "def get_btc_signal(max_age_days: int=7) -> Optional[CryptoSignal]:\n    \"\"\"Get latest BTC trading signal from newsletter\"\"\"\n    analyzer = NewsletterAnalyzer()\n    return analyzer.get_signal_for_ticker('BTC', max_age_days)"
    },
    {
      "name": "get_eth_signal",
      "line": 485,
      "code": "def get_eth_signal(max_age_days: int=7) -> Optional[CryptoSignal]:\n    \"\"\"Get latest ETH trading signal from newsletter\"\"\"\n    analyzer = NewsletterAnalyzer()\n    return analyzer.get_signal_for_ticker('ETH', max_age_days)"
    },
    {
      "name": "get_all_signals",
      "line": 491,
      "code": "def get_all_signals(max_age_days: int=7) -> Dict[str, CryptoSignal]:\n    \"\"\"Get all latest crypto trading signals from newsletter\"\"\"\n    analyzer = NewsletterAnalyzer()\n    return analyzer.get_latest_signals(max_age_days)"
    },
    {
      "name": "to_dict",
      "line": 56,
      "code": "def to_dict(self) -> Dict:\n    \"\"\"Convert signal to dictionary for JSON serialization\"\"\"\n    return {'ticker': self.ticker, 'sentiment': self.sentiment, 'confidence': self.confidence, 'entry_price': self.entry_price, 'target_price': self.target_price, 'stop_loss': self.stop_loss, 'timeframe': self.timeframe, 'reasoning': self.reasoning, 'source_date': self.source_date.isoformat() if self.source_date else None}"
    },
    {
      "name": "from_dict",
      "line": 71,
      "code": "@classmethod\ndef from_dict(cls, data: Dict) -> 'CryptoSignal':\n    \"\"\"Create signal from dictionary\"\"\"\n    return cls(ticker=data['ticker'], sentiment=data['sentiment'], confidence=float(data['confidence']), entry_price=float(data['entry_price']) if data.get('entry_price') else None, target_price=float(data['target_price']) if data.get('target_price') else None, stop_loss=float(data['stop_loss']) if data.get('stop_loss') else None, timeframe=data.get('timeframe'), reasoning=data.get('reasoning'), source_date=datetime.fromisoformat(data['source_date']) if data.get('source_date') else None)"
    },
    {
      "name": "__init__",
      "line": 95,
      "code": "def __init__(self, data_dir: Optional[Path]=None):\n    self.data_dir = data_dir or NEWSLETTER_DATA_DIR\n    self.data_dir.mkdir(parents=True, exist_ok=True)\n    self.bullish_keywords = ['bullish', 'buy', 'long', 'breakout', 'rally', 'uptrend', 'accumulate', 'support', 'bottom', 'undervalued', 'pump', 'moon', 'calls', 'strong', 'momentum', 'reversal up']\n    self.bearish_keywords = ['bearish', 'sell', 'short', 'breakdown', 'dump', 'downtrend', 'distribute', 'resistance', 'top', 'overvalued', 'crash', 'puts', 'weak', 'consolidation', 'reversal down']\n    self.technical_keywords = ['rsi', 'macd', 'moving average', 'ma', 'ema', 'sma', 'volume', 'fibonacci', 'golden cross', 'death cross', 'bollinger', 'support', 'resistance', 'trendline']"
    },
    {
      "name": "get_latest_signals",
      "line": 119,
      "code": "def get_latest_signals(self, max_age_days: int=7) -> Dict[str, CryptoSignal]:\n    \"\"\"\n        Get latest BTC/ETH signals from newsletter.\n\n        Args:\n            max_age_days: Maximum age of signals to consider (default: 7 days)\n\n        Returns:\n            Dictionary mapping ticker (BTC/ETH) to CryptoSignal\n        \"\"\"\n    signals = self._read_mcp_signals(max_age_days)\n    if signals:\n        logger.info(f'Loaded {len(signals)} signals from MCP-populated files')\n        return signals\n    if FEEDPARSER_AVAILABLE:\n        logger.info('No MCP signals found, falling back to RSS parsing')\n        signals = self._parse_rss_feed(max_age_days)\n        if signals:\n            logger.info(f'Extracted {len(signals)} signals from RSS feed')\n            return signals\n    logger.warning('No newsletter signals available from any source')\n    return {}"
    },
    {
      "name": "_read_mcp_signals",
      "line": 148,
      "code": "def _read_mcp_signals(self, max_age_days: int) -> Dict[str, CryptoSignal]:\n    \"\"\"\n        Read newsletter signals from MCP-populated JSON files.\n\n        Files are expected in format: data/newsletter_signals/newsletter_signals_YYYY-MM-DD.json\n        \"\"\"\n    signals = {}\n    cutoff_date = datetime.now(timezone.utc) - timedelta(days=max_age_days)\n    signal_files = sorted(self.data_dir.glob('newsletter_signals_*.json'), key=lambda p: p.stat().st_mtime, reverse=True)\n    for signal_file in signal_files:\n        try:\n            date_str = signal_file.stem.replace('newsletter_signals_', '')\n            file_date = datetime.strptime(date_str, '%Y-%m-%d').replace(tzinfo=timezone.utc)\n            if file_date < cutoff_date:\n                continue\n            with signal_file.open('r') as f:\n                data = json.load(f)\n            for ticker in ['BTC', 'ETH']:\n                if ticker in data:\n                    signal_data = data[ticker]\n                    signal_data['source_date'] = file_date.isoformat()\n                    signals[ticker] = CryptoSignal.from_dict(signal_data)\n                    logger.info(f'Loaded {ticker} signal from {signal_file.name}')\n        except Exception as e:\n            logger.error(f'Error reading signal file {signal_file}: {e}')\n            continue\n    return signals"
    },
    {
      "name": "_parse_rss_feed",
      "line": 192,
      "code": "def _parse_rss_feed(self, max_age_days: int) -> Dict[str, CryptoSignal]:\n    \"\"\"\n        Parse CoinSnacks RSS feed directly for trading signals.\n\n        This is a fallback when MCP-populated files are not available.\n        \"\"\"\n    if not FEEDPARSER_AVAILABLE:\n        logger.warning('feedparser not installed - cannot parse RSS feed')\n        return {}\n    try:\n        feed = feedparser.parse(COINSNACKS_RSS_URL)\n        if not feed.entries:\n            logger.warning('No entries found in CoinSnacks RSS feed')\n            return {}\n        cutoff_date = datetime.now(timezone.utc) - timedelta(days=max_age_days)\n        signals = {}\n        for entry in feed.entries:\n            try:\n                if hasattr(entry, 'published_parsed'):\n                    entry_date = datetime(*entry.published_parsed[:6], tzinfo=timezone.utc)\n                else:\n                    entry_date = datetime.now(timezone.utc)\n                if entry_date < cutoff_date:\n                    continue\n                content = entry.get('summary', '') or entry.get('description', '')\n                title = entry.get('title', '')\n                article_signals = self.parse_article(title + '\\n\\n' + content, entry_date)\n                for ticker, signal in article_signals.items():\n                    if ticker not in signals or signal.source_date > signals[ticker].source_date:\n                        signals[ticker] = signal\n            except Exception as e:\n                logger.error(f'Error parsing RSS entry: {e}')\n                continue\n        return signals\n    except Exception as e:\n        logger.error(f'Error fetching RSS feed: {e}')\n        return {}"
    },
    {
      "name": "parse_article",
      "line": 246,
      "code": "def parse_article(self, article_text: str, source_date: Optional[datetime]=None) -> Dict[str, CryptoSignal]:\n    \"\"\"\n        Extract crypto recommendations from article text.\n\n        Args:\n            article_text: Full article text (title + content)\n            source_date: Date of article publication\n\n        Returns:\n            Dictionary mapping ticker (BTC/ETH) to CryptoSignal\n        \"\"\"\n    signals = {}\n    article_lower = article_text.lower()\n    for ticker in ['BTC', 'ETH']:\n        ticker_lower = ticker.lower()\n        if ticker_lower not in article_lower and 'bitcoin' not in article_lower and ('ethereum' not in article_lower):\n            continue\n        sentiment, confidence = self._extract_sentiment(article_text, ticker)\n        entry_price, target_price, stop_loss = self._extract_price_targets(article_text, ticker)\n        timeframe = self._extract_timeframe(article_text)\n        reasoning = self._extract_reasoning(article_text, ticker)\n        signal = CryptoSignal(ticker=ticker, sentiment=sentiment, confidence=confidence, entry_price=entry_price, target_price=target_price, stop_loss=stop_loss, timeframe=timeframe, reasoning=reasoning, source_date=source_date or datetime.now(timezone.utc))\n        signals[ticker] = signal\n        logger.info(f'Extracted {ticker} signal: {sentiment} (confidence: {confidence:.2f})')\n    return signals"
    },
    {
      "name": "_extract_sentiment",
      "line": 298,
      "code": "def _extract_sentiment(self, text: str, ticker: str) -> Tuple[str, float]:\n    \"\"\"\n        Extract bullish/bearish sentiment and confidence score.\n\n        Returns:\n            Tuple of (sentiment, confidence) where sentiment is \"bullish\", \"bearish\", or \"neutral\"\n            and confidence is 0.0-1.0\n        \"\"\"\n    text_lower = text.lower()\n    bullish_count = sum((1 for keyword in self.bullish_keywords if keyword in text_lower))\n    bearish_count = sum((1 for keyword in self.bearish_keywords if keyword in text_lower))\n    technical_count = sum((1 for keyword in self.technical_keywords if keyword in text_lower))\n    if bullish_count > bearish_count:\n        sentiment = 'bullish'\n        confidence = min(0.5 + bullish_count * 0.1 + technical_count * 0.05, 1.0)\n    elif bearish_count > bullish_count:\n        sentiment = 'bearish'\n        confidence = min(0.5 + bearish_count * 0.1 + technical_count * 0.05, 1.0)\n    else:\n        sentiment = 'neutral'\n        confidence = 0.3\n    return (sentiment, confidence)"
    },
    {
      "name": "_extract_price_targets",
      "line": 328,
      "code": "def _extract_price_targets(self, text: str, ticker: str) -> Tuple[Optional[float], Optional[float], Optional[float]]:\n    \"\"\"\n        Extract entry price, target price, and stop loss from article.\n\n        Returns:\n            Tuple of (entry_price, target_price, stop_loss)\n        \"\"\"\n    entry_price = None\n    target_price = None\n    stop_loss = None\n    price_patterns = ['\\\\$(\\\\d{1,3}(?:,\\\\d{3})*(?:\\\\.\\\\d+)?)\\\\s*k\\\\b', '\\\\$(\\\\d{1,3}(?:,\\\\d{3})*(?:\\\\.\\\\d+)?)\\\\b', '(\\\\d{4,}(?:\\\\.\\\\d+)?)\\\\s*k\\\\b']\n    entry_keywords = ['entry', 'buy at', 'enter at', 'support at']\n    target_keywords = ['target', 'take profit', 'tp', 'resistance at']\n    stop_keywords = ['stop loss', 'sl', 'stop at']\n    for pattern in price_patterns:\n        for match in re.finditer(pattern, text, re.IGNORECASE):\n            price_str = match.group(1).replace(',', '').strip()\n            if not price_str or price_str == '.':\n                continue\n            try:\n                if 'k' in match.group(0).lower():\n                    price = float(price_str) * 1000\n                else:\n                    price = float(price_str)\n            except ValueError:\n                continue\n            context_start = max(0, match.start() - 50)\n            context_end = min(len(text), match.end() + 50)\n            context = text[context_start:context_end].lower()\n            if any((keyword in context for keyword in entry_keywords)):\n                entry_price = price\n            elif any((keyword in context for keyword in target_keywords)):\n                target_price = price\n            elif any((keyword in context for keyword in stop_keywords)):\n                stop_loss = price\n    return (entry_price, target_price, stop_loss)"
    },
    {
      "name": "_extract_timeframe",
      "line": 384,
      "code": "def _extract_timeframe(self, text: str) -> Optional[str]:\n    \"\"\"\n        Extract trading timeframe from article.\n\n        Returns:\n            \"short-term\", \"medium-term\", \"long-term\", or None\n        \"\"\"\n    text_lower = text.lower()\n    short_keywords = ['short-term', 'day trade', 'swing', 'days', 'hours', 'intraday']\n    medium_keywords = ['medium-term', 'weeks', 'months', 'intermediate']\n    long_keywords = ['long-term', 'hold', 'hodl', 'year', 'years', 'accumulation']\n    if any((keyword in text_lower for keyword in long_keywords)):\n        return 'long-term'\n    elif any((keyword in text_lower for keyword in medium_keywords)):\n        return 'medium-term'\n    elif any((keyword in text_lower for keyword in short_keywords)):\n        return 'short-term'\n    return None"
    },
    {
      "name": "_extract_reasoning",
      "line": 406,
      "code": "def _extract_reasoning(self, text: str, ticker: str) -> Optional[str]:\n    \"\"\"\n        Extract reasoning/justification for the signal.\n\n        Returns first paragraph mentioning the ticker (max 500 chars).\n        \"\"\"\n    paragraphs = [p.strip() for p in text.split('\\n\\n') if p.strip()]\n    ticker_lower = ticker.lower()\n    ticker_names = {'BTC': ['btc', 'bitcoin'], 'ETH': ['eth', 'ethereum']}\n    for paragraph in paragraphs:\n        paragraph_lower = paragraph.lower()\n        if any((name in paragraph_lower for name in ticker_names.get(ticker, [ticker_lower]))):\n            if len(paragraph) > 500:\n                return paragraph[:497] + '...'\n            return paragraph\n    return None"
    },
    {
      "name": "save_signals",
      "line": 432,
      "code": "def save_signals(self, signals: Dict[str, CryptoSignal], date: Optional[datetime]=None) -> Path:\n    \"\"\"\n        Save extracted signals to JSON file (for MCP to populate or manual caching).\n\n        Args:\n            signals: Dictionary of ticker -> CryptoSignal\n            date: Date for the signals (default: today)\n\n        Returns:\n            Path to saved file\n        \"\"\"\n    if not signals:\n        raise ValueError('Cannot save empty signals dictionary')\n    date = date or datetime.now(timezone.utc)\n    date_str = date.strftime('%Y-%m-%d')\n    file_path = self.data_dir / f'newsletter_signals_{date_str}.json'\n    data = {ticker: signal.to_dict() for ticker, signal in signals.items()}\n    with file_path.open('w') as f:\n        json.dump(data, f, indent=2)\n    logger.info(f'Saved {len(signals)} newsletter signals to {file_path}')\n    return file_path"
    },
    {
      "name": "get_signal_for_ticker",
      "line": 462,
      "code": "def get_signal_for_ticker(self, ticker: str, max_age_days: int=7) -> Optional[CryptoSignal]:\n    \"\"\"\n        Get signal for specific ticker (BTC or ETH).\n\n        Args:\n            ticker: Crypto ticker (BTC or ETH)\n            max_age_days: Maximum age of signal to consider\n\n        Returns:\n            CryptoSignal if available, None otherwise\n        \"\"\"\n    signals = self.get_latest_signals(max_age_days)\n    return signals.get(ticker.upper())"
    }
  ]
}
