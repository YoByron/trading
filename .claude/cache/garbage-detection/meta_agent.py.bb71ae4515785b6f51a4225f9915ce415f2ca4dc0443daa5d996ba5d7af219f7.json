{
  "dead_imports": [
    {
      "line": 11,
      "module": "List",
      "statement": "from typing import Dict, List, Any"
    }
  ],
  "commented_blocks": [],
  "empty_functions": [],
  "unused_variables": [],
  "all_functions": [
    {
      "name": "__init__",
      "line": 27,
      "code": "def __init__(self):\n    super().__init__(name='MetaAgent', role='Hierarchical coordinator and market regime detector')\n    self.agents: Dict[str, BaseAgent] = {}\n    self.market_regime = 'UNKNOWN'"
    },
    {
      "name": "register_agent",
      "line": 35,
      "code": "def register_agent(self, agent: BaseAgent) -> None:\n    \"\"\"Register a specialist agent.\"\"\"\n    self.agents[agent.name] = agent\n    logger.info(f'MetaAgent registered: {agent.name}')"
    },
    {
      "name": "analyze",
      "line": 40,
      "code": "def analyze(self, data: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"\n        Coordinate all agents to make trading decision.\n        \n        Args:\n            data: Market data, news, portfolio state\n            \n        Returns:\n            Coordinated trading decision\n        \"\"\"\n    regime = self._detect_market_regime(data)\n    self.market_regime = regime\n    memory_context = self.get_memory_context(limit=5)\n    prompt = f\"You are the Meta-Agent coordinating a multi-agent trading system.\\n\\nMARKET REGIME: {regime}\\n\\nCURRENT DATA:\\n- Market: {data.get('symbol', 'N/A')}\\n- Price: ${data.get('price', 0):.2f}\\n- Volatility: {data.get('volatility', 0):.2%}\\n- Volume Ratio: {data.get('volume_ratio', 1.0):.2f}x\\n\\n{memory_context}\\n\\nAVAILABLE SPECIALIST AGENTS:\\n- ResearchAgent: Analyzes fundamentals, news, sentiment\\n- SignalAgent: Technical analysis + momentum\\n- RiskAgent: Portfolio risk and position sizing\\n- ExecutionAgent: Order timing and execution\\n\\nTASK: Based on the {regime} market regime, which agents should I activate and how should I weight their recommendations?\\n\\nProvide your reasoning and agent activation strategy.\"\n    response = self.reason_with_llm(prompt)\n    decision = {'meta_agent_reasoning': response['reasoning'], 'market_regime': regime, 'agent_activations': self._parse_activations(response['reasoning']), 'coordinated_decision': None}\n    recommendations = {}\n    for agent_name, weight in decision['agent_activations'].items():\n        if agent_name in self.agents and weight > 0:\n            agent = self.agents[agent_name]\n            rec = agent.analyze(data)\n            recommendations[agent_name] = {'recommendation': rec, 'weight': weight}\n    final_decision = self._synthesize_decision(recommendations)\n    decision['coordinated_decision'] = final_decision\n    self.log_decision(decision)\n    return decision"
    },
    {
      "name": "_detect_market_regime",
      "line": 109,
      "code": "def _detect_market_regime(self, data: Dict[str, Any]) -> str:\n    \"\"\"\n        Detect current market regime using volatility and trend indicators.\n        \n        Returns:\n            Market regime string\n        \"\"\"\n    volatility = data.get('volatility', 0.0)\n    trend_strength = data.get('trend_strength', 0.0)\n    if volatility < 0.15:\n        return 'LOW_VOL'\n    elif volatility > 0.3:\n        return 'HIGH_VOL'\n    elif trend_strength > 0.6:\n        return 'TRENDING'\n    else:\n        return 'RANGING'"
    },
    {
      "name": "_parse_activations",
      "line": 129,
      "code": "def _parse_activations(self, reasoning: str) -> Dict[str, float]:\n    \"\"\"\n        Parse agent activations from LLM reasoning.\n        \n        For now, use simple heuristics. Can be enhanced with structured output.\n        \n        Returns:\n            Dict mapping agent names to activation weights\n        \"\"\"\n    activations = {}\n    if self.market_regime == 'LOW_VOL':\n        activations = {'ResearchAgent': 0.4, 'SignalAgent': 0.3, 'RiskAgent': 0.2, 'ExecutionAgent': 0.1}\n    elif self.market_regime == 'HIGH_VOL':\n        activations = {'ResearchAgent': 0.2, 'SignalAgent': 0.2, 'RiskAgent': 0.5, 'ExecutionAgent': 0.1}\n    elif self.market_regime == 'TRENDING':\n        activations = {'ResearchAgent': 0.2, 'SignalAgent': 0.5, 'RiskAgent': 0.2, 'ExecutionAgent': 0.1}\n    else:\n        activations = {'ResearchAgent': 0.3, 'SignalAgent': 0.3, 'RiskAgent': 0.3, 'ExecutionAgent': 0.1}\n    return activations"
    },
    {
      "name": "_synthesize_decision",
      "line": 172,
      "code": "def _synthesize_decision(self, recommendations: Dict[str, Dict]) -> Dict[str, Any]:\n    \"\"\"\n        Synthesize final decision from weighted agent recommendations.\n        \n        Args:\n            recommendations: Dict of agent recommendations with weights\n            \n        Returns:\n            Final trading decision\n        \"\"\"\n    total_buy_weight = 0.0\n    total_sell_weight = 0.0\n    total_hold_weight = 0.0\n    for agent_name, rec_data in recommendations.items():\n        rec = rec_data['recommendation']\n        weight = rec_data['weight']\n        action = rec.get('action', 'HOLD')\n        if action == 'BUY':\n            total_buy_weight += weight\n        elif action == 'SELL':\n            total_sell_weight += weight\n        else:\n            total_hold_weight += weight\n    max_weight = max(total_buy_weight, total_sell_weight, total_hold_weight)\n    if max_weight == total_buy_weight and total_buy_weight > 0.5:\n        action = 'BUY'\n        confidence = total_buy_weight\n    elif max_weight == total_sell_weight and total_sell_weight > 0.5:\n        action = 'SELL'\n        confidence = total_sell_weight\n    else:\n        action = 'HOLD'\n        confidence = total_hold_weight\n    return {'action': action, 'confidence': confidence, 'buy_weight': total_buy_weight, 'sell_weight': total_sell_weight, 'hold_weight': total_hold_weight, 'agent_recommendations': recommendations}"
    }
  ]
}
