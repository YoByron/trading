{
  "dead_imports": [
    {
      "line": 17,
      "module": "timedelta",
      "statement": "from datetime import datetime, timedelta"
    },
    {
      "line": 19,
      "module": "Tuple",
      "statement": "from typing import Dict, List, Optional, Tuple"
    }
  ],
  "commented_blocks": [],
  "empty_functions": [],
  "unused_variables": [
    {
      "line": 56,
      "variable": "STOCKTWITS_BASE_URL"
    },
    {
      "line": 57,
      "variable": "ALPHA_VANTAGE_BASE_URL"
    },
    {
      "line": 60,
      "variable": "ALPHA_VANTAGE_WEIGHT"
    },
    {
      "line": 61,
      "variable": "STOCKTWITS_WEIGHT"
    },
    {
      "line": 62,
      "variable": "YAHOO_WEIGHT"
    },
    {
      "line": 63,
      "variable": "GROK_TWITTER_WEIGHT"
    }
  ],
  "all_functions": [
    {
      "name": "main",
      "line": 725,
      "code": "def main():\n    \"\"\"CLI interface for news sentiment aggregator.\"\"\"\n    import argparse\n    parser = argparse.ArgumentParser(description='Aggregate financial news sentiment')\n    parser.add_argument('--tickers', type=str, default='SPY,QQQ,VOO,NVDA,GOOGL,AMZN', help='Comma-separated list of tickers (default: SPY,QQQ,VOO,NVDA,GOOGL,AMZN)')\n    parser.add_argument('--output-dir', type=str, default='data/sentiment', help='Directory to save reports (default: data/sentiment)')\n    parser.add_argument('--load', type=str, help='Load and display an existing report (filename)')\n    parser.add_argument('--test', action='store_true', help='Test with SPY only')\n    args = parser.parse_args()\n    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n    aggregator = NewsSentimentAggregator(output_dir=args.output_dir)\n    if args.load:\n        report_data = aggregator.load_report(args.load)\n        if report_data:\n            print('\\n' + '=' * 80)\n            print(f\"LOADED REPORT - {report_data['meta']['date']}\")\n            print('=' * 80)\n            print(json.dumps(report_data, indent=2))\n    elif args.test:\n        print('\\nTesting with SPY ticker...')\n        tickers = ['SPY']\n        report = aggregator.analyze_tickers(tickers)\n        aggregator.print_summary(report)\n        filepath = aggregator.save_report(report)\n        print(f'Report saved to: {filepath}')\n    else:\n        tickers = [t.strip() for t in args.tickers.split(',')]\n        report = aggregator.analyze_tickers(tickers)\n        aggregator.print_summary(report)\n        filepath = aggregator.save_report(report)\n        print(f'Report saved to: {filepath}')"
    },
    {
      "name": "__init__",
      "line": 65,
      "code": "def __init__(self, alpha_vantage_key: Optional[str]=None, grok_api_key: Optional[str]=None, output_dir: str='data/sentiment'):\n    \"\"\"\n        Initialize the sentiment aggregator.\n\n        Args:\n            alpha_vantage_key: Alpha Vantage API key (optional, reads from env)\n            grok_api_key: Grok/X.ai API key for Twitter sentiment (optional, reads from env)\n            output_dir: Directory to save sentiment reports\n        \"\"\"\n    self.alpha_vantage_key = alpha_vantage_key or os.getenv('ALPHA_VANTAGE_API_KEY')\n    self.grok_api_key = grok_api_key or os.getenv('GROK_API_KEY')\n    self.output_dir = Path(output_dir)\n    self.output_dir.mkdir(parents=True, exist_ok=True)\n    self.av_client = None\n    if self.alpha_vantage_key:\n        try:\n            self.av_client = TimeSeries(key=self.alpha_vantage_key, output_format='json')\n            logger.info('Alpha Vantage client initialized')\n        except Exception as e:\n            logger.warning(f'Failed to initialize Alpha Vantage: {e}')\n    else:\n        logger.warning('No Alpha Vantage API key found - sentiment will be limited')\n    self.grok_client = None\n    if self.grok_api_key:\n        try:\n            from openai import OpenAI\n            self.grok_client = OpenAI(api_key=self.grok_api_key, base_url='https://api.x.ai/v1')\n            logger.info('\u2705 Grok/X.ai API client initialized for Twitter sentiment')\n        except Exception as e:\n            logger.warning(f'Failed to initialize Grok client: {e}')\n    else:\n        logger.debug('No Grok API key found - Twitter sentiment will be skipped')\n    logger.info(f'NewsSentimentAggregator initialized: {self.output_dir}')"
    },
    {
      "name": "get_yahoo_sentiment",
      "line": 116,
      "code": "@retry_with_backoff(max_retries=3, initial_delay=1.0)\ndef get_yahoo_sentiment(self, ticker: str) -> Dict:\n    \"\"\"\n        Get news sentiment from Yahoo Finance.\n\n        Args:\n            ticker: Stock ticker symbol\n\n        Returns:\n            Dict with score, articles count, and details\n        \"\"\"\n    try:\n        stock = yf.Ticker(ticker)\n        try:\n            news = stock.news\n        except (AttributeError, TypeError):\n            try:\n                news = stock.get_news()\n            except:\n                logger.warning(f'Could not fetch Yahoo news for {ticker}')\n                return {'score': 0, 'articles': 0, 'confidence': 'low', 'error': 'api_unavailable'}\n        if not news or len(news) == 0:\n            logger.warning(f'No Yahoo news found for {ticker}')\n            return {'score': 0, 'articles': 0, 'confidence': 'low'}\n        bullish_keywords = ['surge', 'rally', 'gain', 'bull', 'upgrade', 'beat', 'strong', 'growth', 'positive', 'profit', 'rise', 'outperform', 'buy']\n        bearish_keywords = ['drop', 'fall', 'bear', 'downgrade', 'miss', 'weak', 'decline', 'negative', 'loss', 'crash', 'underperform', 'sell']\n        sentiment_score = 0\n        articles_analyzed = 0\n        for article in news[:20]:\n            title = article.get('title', '').lower()\n            bullish_count = sum((1 for kw in bullish_keywords if kw in title))\n            bearish_count = sum((1 for kw in bearish_keywords if kw in title))\n            if bullish_count > bearish_count:\n                sentiment_score += 1\n            elif bearish_count > bullish_count:\n                sentiment_score -= 1\n            articles_analyzed += 1\n        if articles_analyzed > 0:\n            normalized_score = sentiment_score / articles_analyzed * 100\n        else:\n            normalized_score = 0\n        confidence = 'high' if articles_analyzed >= 10 else 'medium' if articles_analyzed >= 5 else 'low'\n        return {'score': round(normalized_score, 2), 'articles': articles_analyzed, 'confidence': confidence, 'raw_sentiment': sentiment_score}\n    except Exception as e:\n        logger.error(f'Error getting Yahoo sentiment for {ticker}: {e}')\n        return {'score': 0, 'articles': 0, 'confidence': 'low', 'error': str(e)}"
    },
    {
      "name": "get_stocktwits_sentiment",
      "line": 222,
      "code": "@retry_with_backoff(max_retries=3, initial_delay=1.0)\ndef get_stocktwits_sentiment(self, ticker: str) -> Dict:\n    \"\"\"\n        Get sentiment from Stocktwits social trading platform.\n\n        Args:\n            ticker: Stock ticker symbol\n\n        Returns:\n            Dict with score, messages count, and details\n        \"\"\"\n    try:\n        url = f'{self.STOCKTWITS_BASE_URL}/streams/symbol/{ticker}.json'\n        response = requests.get(url, timeout=10)\n        response.raise_for_status()\n        data = response.json()\n        messages = data.get('messages', [])\n        if not messages:\n            logger.warning(f'No Stocktwits messages found for {ticker}')\n            return {'score': 0, 'messages': 0, 'confidence': 'low'}\n        bullish_count = 0\n        bearish_count = 0\n        neutral_count = 0\n        for msg in messages:\n            entities = msg.get('entities', {})\n            sentiment = entities.get('sentiment')\n            if sentiment:\n                if sentiment.get('basic') == 'Bullish':\n                    bullish_count += 1\n                elif sentiment.get('basic') == 'Bearish':\n                    bearish_count += 1\n                else:\n                    neutral_count += 1\n        total_with_sentiment = bullish_count + bearish_count + neutral_count\n        if total_with_sentiment == 0:\n            return {'score': 0, 'messages': len(messages), 'confidence': 'low'}\n        sentiment_score = (bullish_count - bearish_count) / total_with_sentiment * 100\n        confidence = 'high' if total_with_sentiment >= 20 else 'medium' if total_with_sentiment >= 10 else 'low'\n        return {'score': round(sentiment_score, 2), 'messages': len(messages), 'bullish': bullish_count, 'bearish': bearish_count, 'neutral': neutral_count, 'confidence': confidence}\n    except requests.exceptions.HTTPError as e:\n        if e.response.status_code == 404:\n            logger.warning(f'Ticker {ticker} not found on Stocktwits')\n            return {'score': 0, 'messages': 0, 'confidence': 'low', 'error': 'not_found'}\n        else:\n            logger.error(f'HTTP error getting Stocktwits sentiment for {ticker}: {e}')\n            return {'score': 0, 'messages': 0, 'confidence': 'low', 'error': str(e)}\n    except Exception as e:\n        logger.error(f'Error getting Stocktwits sentiment for {ticker}: {e}')\n        return {'score': 0, 'messages': 0, 'confidence': 'low', 'error': str(e)}"
    },
    {
      "name": "get_alpha_vantage_sentiment",
      "line": 305,
      "code": "@retry_with_backoff(max_retries=2, initial_delay=2.0)\ndef get_alpha_vantage_sentiment(self, ticker: str) -> Dict:\n    \"\"\"\n        Get AI-powered sentiment from Alpha Vantage.\n\n        Args:\n            ticker: Stock ticker symbol\n\n        Returns:\n            Dict with score, relevance, and article count\n        \"\"\"\n    if not self.alpha_vantage_key:\n        logger.warning('Alpha Vantage API key not configured')\n        return {'score': 0, 'articles': 0, 'confidence': 'low', 'error': 'no_api_key'}\n    try:\n        url = f'{self.ALPHA_VANTAGE_BASE_URL}'\n        params = {'function': 'NEWS_SENTIMENT', 'tickers': ticker, 'apikey': self.alpha_vantage_key, 'limit': 50}\n        response = requests.get(url, params=params, timeout=15)\n        response.raise_for_status()\n        data = response.json()\n        if 'Error Message' in data:\n            logger.error(f\"Alpha Vantage API error: {data['Error Message']}\")\n            return {'score': 0, 'articles': 0, 'confidence': 'low', 'error': data['Error Message']}\n        if 'Note' in data:\n            logger.warning(f\"Alpha Vantage rate limit: {data['Note']}\")\n            return {'score': 0, 'articles': 0, 'confidence': 'low', 'error': 'rate_limit'}\n        feed = data.get('feed', [])\n        if not feed:\n            logger.warning(f'No Alpha Vantage news found for {ticker}')\n            return {'score': 0, 'articles': 0, 'confidence': 'low'}\n        total_sentiment = 0\n        total_relevance = 0\n        articles_count = 0\n        for article in feed:\n            ticker_sentiments = article.get('ticker_sentiment', [])\n            for ts in ticker_sentiments:\n                if ts.get('ticker') == ticker:\n                    sentiment_score = float(ts.get('ticker_sentiment_score', 0))\n                    relevance_score = float(ts.get('relevance_score', 0))\n                    total_sentiment += sentiment_score * relevance_score\n                    total_relevance += relevance_score\n                    articles_count += 1\n        if total_relevance == 0:\n            return {'score': 0, 'articles': articles_count, 'confidence': 'low'}\n        weighted_sentiment = total_sentiment / total_relevance * 100\n        confidence = 'high' if articles_count >= 10 else 'medium' if articles_count >= 5 else 'low'\n        return {'score': round(weighted_sentiment, 2), 'articles': articles_count, 'relevance': round(total_relevance / articles_count, 3) if articles_count > 0 else 0, 'confidence': confidence}\n    except Exception as e:\n        logger.error(f'Error getting Alpha Vantage sentiment for {ticker}: {e}')\n        return {'score': 0, 'articles': 0, 'confidence': 'low', 'error': str(e)}"
    },
    {
      "name": "get_grok_twitter_sentiment",
      "line": 410,
      "code": "@retry_with_backoff(max_retries=2, initial_delay=1.0)\ndef get_grok_twitter_sentiment(self, ticker: str) -> Dict:\n    \"\"\"\n        Get real-time Twitter/X sentiment via Grok API.\n\n        Args:\n            ticker: Stock ticker symbol\n\n        Returns:\n            Dict with score, tweets analyzed, and confidence\n        \"\"\"\n    if not self.grok_client:\n        return {'score': 0, 'tweets': 0, 'confidence': 'low', 'error': 'no_api_key'}\n    try:\n        query = f'Analyze Twitter/X sentiment for ${ticker} stock. Look for recent tweets mentioning {ticker} and provide: 1. Overall sentiment score (-100 to +100), 2. Number of tweets analyzed, 3. Key bullish/bearish themes, 4. Confidence level (high/medium/low). Respond in JSON format: {{\"score\": <number>, \"tweets\": <count>, \"confidence\": \"<level>\", \"themes\": [\"<theme1>\", \"<theme2>\"]}}'\n        response = self.grok_client.chat.completions.create(model='grok-2-1212', messages=[{'role': 'system', 'content': 'You are a financial sentiment analyst. Analyze Twitter/X sentiment for stocks. Always respond with valid JSON only.'}, {'role': 'user', 'content': query}], temperature=0.3, max_tokens=500)\n        content = response.choices[0].message.content.strip()\n        import re\n        json_match = re.search('\\\\{.*\\\\}', content, re.DOTALL)\n        if json_match:\n            content = json_match.group(0)\n        result = json.loads(content)\n        score = result.get('score', 0)\n        tweets = result.get('tweets', 0)\n        confidence = result.get('confidence', 'low')\n        themes = result.get('themes', [])\n        logger.info(f'Grok Twitter sentiment for {ticker}: score={score}, tweets={tweets}, confidence={confidence}')\n        return {'score': float(score), 'tweets': int(tweets), 'confidence': confidence, 'themes': themes, 'source': 'grok_twitter'}\n    except json.JSONDecodeError as e:\n        logger.warning(f'Failed to parse Grok response for {ticker}: {e}')\n        return {'score': 0, 'tweets': 0, 'confidence': 'low', 'error': 'parse_error'}\n    except Exception as e:\n        logger.warning(f'Grok Twitter sentiment failed for {ticker}: {e}')\n        return {'score': 0, 'tweets': 0, 'confidence': 'low', 'error': str(e)}"
    },
    {
      "name": "aggregate_sentiment",
      "line": 490,
      "code": "def aggregate_sentiment(self, ticker: str) -> TickerSentiment:\n    \"\"\"\n        Aggregate sentiment from all sources for a ticker.\n\n        Args:\n            ticker: Stock ticker symbol\n\n        Returns:\n            TickerSentiment object with combined data\n        \"\"\"\n    logger.info(f'Aggregating sentiment for {ticker}...')\n    yahoo_data = self.get_yahoo_sentiment(ticker)\n    stocktwits_data = self.get_stocktwits_sentiment(ticker)\n    alpha_vantage_data = self.get_alpha_vantage_sentiment(ticker)\n    grok_twitter_data = self.get_grok_twitter_sentiment(ticker)\n    sources = {'yahoo': yahoo_data, 'stocktwits': stocktwits_data, 'alphavantage': alpha_vantage_data, 'grok_twitter': grok_twitter_data}\n    yahoo_score = yahoo_data.get('score', 0)\n    stocktwits_score = stocktwits_data.get('score', 0)\n    alpha_vantage_score = alpha_vantage_data.get('score', 0)\n    grok_twitter_score = grok_twitter_data.get('score', 0)\n    weights_sum = self.YAHOO_WEIGHT + self.STOCKTWITS_WEIGHT + self.ALPHA_VANTAGE_WEIGHT\n    if grok_twitter_data.get('error') == 'no_api_key':\n        grok_weight = 0\n        yahoo_weight = self.YAHOO_WEIGHT / weights_sum\n        stocktwits_weight = self.STOCKTWITS_WEIGHT / weights_sum\n        alpha_vantage_weight = self.ALPHA_VANTAGE_WEIGHT / weights_sum\n    else:\n        grok_weight = self.GROK_TWITTER_WEIGHT\n        yahoo_weight = self.YAHOO_WEIGHT\n        stocktwits_weight = self.STOCKTWITS_WEIGHT\n        alpha_vantage_weight = self.ALPHA_VANTAGE_WEIGHT\n    combined_score = yahoo_score * yahoo_weight + stocktwits_score * stocktwits_weight + alpha_vantage_score * alpha_vantage_weight + grok_twitter_score * grok_weight\n    confidences = [yahoo_data.get('confidence', 'low'), stocktwits_data.get('confidence', 'low'), alpha_vantage_data.get('confidence', 'low'), grok_twitter_data.get('confidence', 'low')]\n    high_count = confidences.count('high')\n    medium_count = confidences.count('medium')\n    if high_count >= 2:\n        overall_confidence = 'high'\n    elif high_count >= 1 or medium_count >= 2:\n        overall_confidence = 'medium'\n    else:\n        overall_confidence = 'low'\n    return TickerSentiment(ticker=ticker, score=round(combined_score, 2), confidence=overall_confidence, sources=sources, timestamp=datetime.now().isoformat())"
    },
    {
      "name": "analyze_tickers",
      "line": 574,
      "code": "def analyze_tickers(self, tickers: List[str]) -> SentimentReport:\n    \"\"\"\n        Analyze sentiment for multiple tickers.\n\n        Args:\n            tickers: List of ticker symbols\n\n        Returns:\n            SentimentReport with all ticker data\n        \"\"\"\n    logger.info(f'Analyzing sentiment for {len(tickers)} tickers...')\n    sentiment_data = {}\n    sources_used = set()\n    for ticker in tickers:\n        try:\n            sentiment = self.aggregate_sentiment(ticker)\n            sentiment_data[ticker] = sentiment\n            for source_name, source_data in sentiment.sources.items():\n                if source_data.get('score', 0) != 0 or source_data.get('articles', 0) > 0 or source_data.get('messages', 0) > 0:\n                    sources_used.add(source_name)\n        except Exception as e:\n            logger.error(f'Error analyzing {ticker}: {e}')\n            continue\n    report = SentimentReport(meta={'date': datetime.now().strftime('%Y-%m-%d'), 'timestamp': datetime.now().isoformat(), 'sources': sorted(list(sources_used)), 'tickers_analyzed': len(sentiment_data)}, sentiment_by_ticker=sentiment_data)\n    return report"
    },
    {
      "name": "save_report",
      "line": 619,
      "code": "def save_report(self, report: SentimentReport, filename: Optional[str]=None) -> str:\n    \"\"\"\n        Save sentiment report to JSON file.\n\n        Args:\n            report: SentimentReport to save\n            filename: Optional custom filename (default: news_YYYY-MM-DD.json)\n\n        Returns:\n            Path to saved file\n        \"\"\"\n    if filename is None:\n        today = datetime.now().strftime('%Y-%m-%d')\n        filename = f'news_{today}.json'\n    filepath = self.output_dir / filename\n    report_dict = {'meta': report.meta, 'sentiment_by_ticker': {ticker: asdict(sentiment) for ticker, sentiment in report.sentiment_by_ticker.items()}}\n    with open(filepath, 'w') as f:\n        json.dump(report_dict, f, indent=2)\n    logger.info(f'Sentiment report saved to {filepath}')\n    return str(filepath)"
    },
    {
      "name": "load_report",
      "line": 653,
      "code": "def load_report(self, filename: str) -> Optional[Dict]:\n    \"\"\"\n        Load a sentiment report from file.\n\n        Args:\n            filename: Name of the file to load\n\n        Returns:\n            Report data as dict, or None if file not found\n        \"\"\"\n    filepath = self.output_dir / filename\n    if not filepath.exists():\n        logger.error(f'Report file not found: {filepath}')\n        return None\n    with open(filepath, 'r') as f:\n        data = json.load(f)\n    logger.info(f'Loaded sentiment report from {filepath}')\n    return data"
    },
    {
      "name": "print_summary",
      "line": 675,
      "code": "def print_summary(self, report: SentimentReport):\n    \"\"\"\n        Print a formatted summary of the sentiment report.\n\n        Args:\n            report: SentimentReport to summarize\n        \"\"\"\n    print('\\n' + '=' * 80)\n    print(f\"SENTIMENT REPORT - {report.meta['date']}\")\n    print('=' * 80)\n    print(f\"Sources: {', '.join(report.meta['sources'])}\")\n    print(f\"Tickers Analyzed: {report.meta['tickers_analyzed']}\")\n    print('-' * 80)\n    for ticker, sentiment in report.sentiment_by_ticker.items():\n        score = sentiment.score\n        confidence = sentiment.confidence\n        if score > 20:\n            label = 'BULLISH'\n        elif score < -20:\n            label = 'BEARISH'\n        else:\n            label = 'NEUTRAL'\n        print(f'\\n{ticker}: {label} ({score:+.1f}) - Confidence: {confidence.upper()}')\n        for source_name, source_data in sentiment.sources.items():\n            source_score = source_data.get('score', 0)\n            articles = source_data.get('articles', 0)\n            messages = source_data.get('messages', 0)\n            if articles > 0:\n                print(f'  - {source_name.capitalize()}: {source_score:+.1f} ({articles} articles)')\n            elif messages > 0:\n                print(f'  - {source_name.capitalize()}: {source_score:+.1f} ({messages} messages)')\n            elif source_score != 0:\n                print(f'  - {source_name.capitalize()}: {source_score:+.1f}')\n    print('\\n' + '=' * 80 + '\\n')"
    }
  ]
}
