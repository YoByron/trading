{
  "dead_imports": [],
  "commented_blocks": [],
  "empty_functions": [],
  "unused_variables": [],
  "all_functions": [
    {
      "name": "__init__",
      "line": 31,
      "code": "def __init__(self, alpaca_api: Optional[tradeapi.REST]=None):\n    super().__init__(name='ExecutionAgent', role='Order execution and timing optimization')\n    self.alpaca_api = alpaca_api\n    self.execution_history: list = []"
    },
    {
      "name": "analyze",
      "line": 39,
      "code": "def analyze(self, data: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"\n        Analyze execution timing and prepare order.\n        \n        Args:\n            data: Contains action, symbol, position_size, market conditions\n            \n        Returns:\n            Execution plan with timing recommendation\n        \"\"\"\n    action = data.get('action', 'HOLD')\n    symbol = data.get('symbol', 'UNKNOWN')\n    position_size = data.get('position_size', 0)\n    market_conditions = data.get('market_conditions', {})\n    if action == 'HOLD':\n        return {'action': 'NO_EXECUTION', 'reasoning': 'HOLD recommendation - no order needed'}\n    market_status = self._check_market_status()\n    memory_context = self.get_memory_context(limit=3)\n    prompt = f\"You are an Execution Agent preparing to execute a {action} order for {symbol}.\\n\\nORDER DETAILS:\\n- Action: {action}\\n- Symbol: {symbol}\\n- Position Size: ${position_size:,.2f}\\n- Order Type: Market\\n\\nMARKET CONDITIONS:\\n- Market Status: {market_status['status']}\\n- Current Spread: {market_conditions.get('spread', 'N/A')}\\n- Volume: {market_conditions.get('volume', 'N/A')}\\n- Volatility: {market_conditions.get('volatility', 'N/A')}\\n\\n{memory_context}\\n\\nTASK: Provide execution analysis:\\n1. Execution Timing (IMMEDIATE / WAIT_5MIN / WAIT_OPEN)\\n2. Expected Slippage (%)\\n3. Confidence in Execution (0-1)\\n4. Recommendation: EXECUTE / DELAY / CANCEL\\n\\nFormat:\\nTIMING: [IMMEDIATE/WAIT_5MIN/WAIT_OPEN]\\nSLIPPAGE: [percentage]\\nCONFIDENCE: [0-1]\\nRECOMMENDATION: [EXECUTE/DELAY/CANCEL]\"\n    response = self.reason_with_llm(prompt)\n    analysis = self._parse_execution_response(response['reasoning'])\n    analysis['market_status'] = market_status\n    analysis['full_reasoning'] = response['reasoning']\n    if analysis['action'] == 'EXECUTE' and self.alpaca_api:\n        execution_result = self._execute_order(symbol, action, position_size)\n        analysis['execution_result'] = execution_result\n    else:\n        analysis['execution_result'] = {'status': 'NOT_EXECUTED', 'reason': analysis['action']}\n    self.log_decision(analysis)\n    return analysis"
    },
    {
      "name": "_check_market_status",
      "line": 114,
      "code": "def _check_market_status(self) -> Dict[str, Any]:\n    \"\"\"Check if market is open and ready for trading.\"\"\"\n    if not self.alpaca_api:\n        return {'status': 'UNKNOWN', 'is_open': False}\n    try:\n        clock = self.alpaca_api.get_clock()\n        return {'status': 'OPEN' if clock.is_open else 'CLOSED', 'is_open': clock.is_open, 'next_open': str(clock.next_open) if hasattr(clock, 'next_open') else None, 'next_close': str(clock.next_close) if hasattr(clock, 'next_close') else None}\n    except Exception as e:\n        logger.error(f'Error checking market status: {e}')\n        return {'status': 'ERROR', 'is_open': False, 'error': str(e)}"
    },
    {
      "name": "_execute_order",
      "line": 131,
      "code": "def _execute_order(self, symbol: str, action: str, position_size: float) -> Dict[str, Any]:\n    \"\"\"\n        Execute order via Alpaca API.\n        \n        Args:\n            symbol: Stock symbol\n            action: BUY or SELL\n            position_size: Dollar amount\n            \n        Returns:\n            Execution result\n        \"\"\"\n    try:\n        if action == 'BUY':\n            order = self.alpaca_api.submit_order(symbol=symbol, notional=position_size, side='buy', type='market', time_in_force='day')\n        elif action == 'SELL':\n            return {'status': 'ERROR', 'message': 'SELL not yet implemented'}\n        else:\n            return {'status': 'ERROR', 'message': f'Unknown action: {action}'}\n        result = {'status': 'SUCCESS', 'order_id': order.id, 'symbol': symbol, 'action': action, 'amount': position_size, 'order_status': order.status}\n        self.execution_history.append(result)\n        logger.info(f'Order executed: {order.id} - {symbol} {action} ${position_size}')\n        return result\n    except Exception as e:\n        logger.error(f'Order execution error: {e}')\n        return {'status': 'ERROR', 'error': str(e), 'symbol': symbol, 'action': action, 'amount': position_size}"
    },
    {
      "name": "_parse_execution_response",
      "line": 183,
      "code": "def _parse_execution_response(self, reasoning: str) -> Dict[str, Any]:\n    \"\"\"Parse LLM response into structured execution plan.\"\"\"\n    lines = reasoning.split('\\n')\n    analysis = {'timing': 'IMMEDIATE', 'slippage': 0.001, 'confidence': 0.8, 'action': 'EXECUTE'}\n    for line in lines:\n        line = line.strip()\n        if line.startswith('TIMING:'):\n            timing = line.split(':')[1].strip().upper()\n            if timing in ['IMMEDIATE', 'WAIT_5MIN', 'WAIT_OPEN']:\n                analysis['timing'] = timing\n        elif line.startswith('SLIPPAGE:'):\n            try:\n                slippage_str = line.split(':')[1].strip().replace('%', '')\n                analysis['slippage'] = float(slippage_str) / 100\n            except:\n                pass\n        elif line.startswith('CONFIDENCE:'):\n            try:\n                analysis['confidence'] = float(line.split(':')[1].strip())\n            except:\n                pass\n        elif line.startswith('RECOMMENDATION:'):\n            rec = line.split(':')[1].strip().upper()\n            if rec in ['EXECUTE', 'DELAY', 'CANCEL']:\n                analysis['action'] = rec\n    return analysis"
    }
  ]
}
