{
  "dead_imports": [
    {
      "line": 5,
      "module": "json",
      "statement": "import json"
    },
    {
      "line": 11,
      "module": "health_check",
      "statement": "from src.utils.self_healing import with_retry, health_check"
    }
  ],
  "commented_blocks": [],
  "empty_functions": [
    {
      "line": 36,
      "name": "analyze",
      "type": "pass"
    }
  ],
  "unused_variables": [],
  "all_functions": [
    {
      "name": "__init__",
      "line": 27,
      "code": "def __init__(self, name: str, role: str, model: str='claude-3-5-sonnet-20241022'):\n    self.name = name\n    self.role = role\n    self.model = model\n    self.client = Anthropic(api_key=os.getenv('ANTHROPIC_API_KEY'))\n    self.memory: List[Dict[str, Any]] = []\n    self.decision_log: List[Dict[str, Any]] = []"
    },
    {
      "name": "analyze",
      "line": 36,
      "code": "@abstractmethod\ndef analyze(self, data: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"\n        Main analysis method - must be implemented by each agent.\n        \n        Args:\n            data: Input data for analysis\n            \n        Returns:\n            Analysis results with reasoning\n        \"\"\"\n    pass"
    },
    {
      "name": "reason_with_llm",
      "line": 49,
      "code": "@with_retry(max_attempts=3, backoff=2.0)\ndef reason_with_llm(self, prompt: str, tools: Optional[List[Dict]]=None) -> Dict[str, Any]:\n    \"\"\"\n        Use LLM reasoning to make decisions.\n        \n        Args:\n            prompt: The reasoning prompt\n            tools: Optional tool definitions for tool use\n            \n        Returns:\n            LLM response with reasoning\n        \"\"\"\n    try:\n        messages = [{'role': 'user', 'content': prompt}]\n        if tools:\n            response = self.client.messages.create(model=self.model, max_tokens=4096, messages=messages, tools=tools)\n        else:\n            response = self.client.messages.create(model=self.model, max_tokens=4096, messages=messages)\n        result = {'reasoning': '', 'decision': '', 'confidence': 0.0, 'tool_calls': []}\n        for block in response.content:\n            if block.type == 'text':\n                result['reasoning'] = block.text\n            elif block.type == 'tool_use':\n                result['tool_calls'].append({'name': block.name, 'input': block.input})\n        return result\n    except Exception as e:\n        logger.error(f'{self.name} LLM reasoning error: {e}')\n        return {'reasoning': f'Error: {str(e)}', 'decision': 'NO_ACTION', 'confidence': 0.0, 'tool_calls': []}"
    },
    {
      "name": "log_decision",
      "line": 105,
      "code": "def log_decision(self, decision: Dict[str, Any]) -> None:\n    \"\"\"Log a decision for audit trail and learning.\"\"\"\n    entry = {'timestamp': datetime.now().isoformat(), 'agent': self.name, 'decision': decision}\n    self.decision_log.append(entry)\n    logger.info(f\"{self.name} decision logged: {decision.get('action', 'N/A')}\")"
    },
    {
      "name": "learn_from_outcome",
      "line": 115,
      "code": "def learn_from_outcome(self, decision_id: str, outcome: Dict[str, Any]) -> None:\n    \"\"\"\n        Learn from decision outcomes (reinforcement learning).\n        \n        Args:\n            decision_id: ID of the decision\n            outcome: Result data (profit/loss, accuracy, etc.)\n        \"\"\"\n    memory_entry = {'decision_id': decision_id, 'outcome': outcome, 'timestamp': datetime.now().isoformat()}\n    self.memory.append(memory_entry)\n    logger.info(f\"{self.name} learned from outcome: {outcome.get('result', 'N/A')}\")"
    },
    {
      "name": "get_memory_context",
      "line": 131,
      "code": "def get_memory_context(self, limit: int=10) -> str:\n    \"\"\"\n        Get recent memory context for LLM reasoning.\n        \n        Args:\n            limit: Number of recent memories to include\n            \n        Returns:\n            Formatted memory context string\n        \"\"\"\n    recent_memories = self.memory[-limit:]\n    if not recent_memories:\n        return 'No previous experience.'\n    context = 'Recent experience:\\n'\n    for mem in recent_memories:\n        outcome = mem.get('outcome', {})\n        context += f\"- {mem['timestamp']}: {outcome.get('result', 'N/A')} \"\n        context += f\"(P/L: {outcome.get('pl', 0):.2f})\\n\"\n    return context"
    }
  ]
}
