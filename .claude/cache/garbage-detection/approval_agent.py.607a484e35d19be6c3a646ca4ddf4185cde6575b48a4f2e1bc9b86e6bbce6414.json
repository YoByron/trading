{
  "dead_imports": [],
  "commented_blocks": [],
  "empty_functions": [],
  "unused_variables": [
    {
      "line": 27,
      "variable": "PENDING"
    },
    {
      "line": 28,
      "variable": "APPROVED"
    },
    {
      "line": 29,
      "variable": "REJECTED"
    },
    {
      "line": 30,
      "variable": "TIMEOUT"
    },
    {
      "line": 31,
      "variable": "EXPIRED"
    }
  ],
  "all_functions": [
    {
      "name": "__post_init__",
      "line": 47,
      "code": "def __post_init__(self):\n    if not self.created_at:\n        self.created_at = datetime.now().isoformat()"
    },
    {
      "name": "__init__",
      "line": 63,
      "code": "def __init__(self):\n    super().__init__(name='ApprovalAgent', role='Human Approval Coordinator')\n    self.pending_approvals: Dict[str, ApprovalRequest] = {}\n    self.approval_history: List[ApprovalRequest] = []\n    self.approval_dir = Path('data/approvals')\n    self.approval_dir.mkdir(parents=True, exist_ok=True)\n    self.high_value_threshold = float(os.getenv('APPROVAL_HIGH_VALUE_THRESHOLD', '1000.0'))\n    self.notification_channels = os.getenv('APPROVAL_NOTIFICATION_CHANNELS', 'email').split(',')"
    },
    {
      "name": "analyze",
      "line": 78,
      "code": "def analyze(self, data: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"\n        Process an approval request.\n\n        Args:\n            data: Approval request data\n\n        Returns:\n            Approval result\n        \"\"\"\n    request_type = data.get('type', 'trade')\n    if request_type == 'request_approval':\n        return self._request_approval(data)\n    elif request_type == 'check_approval':\n        return self._check_approval_status(data)\n    elif request_type == 'submit_decision':\n        return self._submit_decision(data)\n    else:\n        return {'success': False, 'error': f'Unknown approval type: {request_type}'}"
    },
    {
      "name": "_request_approval",
      "line": 99,
      "code": "def _request_approval(self, data: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"\n        Request human approval for a decision.\n\n        Args:\n            data: Contains decision context, type, priority\n\n        Returns:\n            Approval request ID and status\n        \"\"\"\n    approval_type = data.get('approval_type', 'trade')\n    context = data.get('context', {})\n    priority = data.get('priority', 'medium')\n    timeout = data.get('timeout_seconds', 900)\n    if approval_type == 'trade':\n        trade_value = context.get('trade_value', 0)\n        if trade_value < self.high_value_threshold:\n            return {'success': True, 'approval_required': False, 'reason': f'Trade value ${trade_value} below threshold ${self.high_value_threshold}'}\n    approval_id = str(uuid.uuid4())\n    request = ApprovalRequest(id=approval_id, type=approval_type, context=context, priority=priority, timeout_seconds=timeout)\n    self.pending_approvals[approval_id] = request\n    asyncio.create_task(self._send_notifications(request))\n    self._save_approval_request(request)\n    logger.info(f'Approval requested: {approval_id} ({approval_type}, {priority})')\n    return {'success': True, 'approval_required': True, 'approval_id': approval_id, 'status': ApprovalStatus.PENDING.value, 'timeout_at': (datetime.now() + timedelta(seconds=timeout)).isoformat(), 'notification_channels': self.notification_channels}"
    },
    {
      "name": "_check_approval_status",
      "line": 153,
      "code": "def _check_approval_status(self, data: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"\n        Check status of an approval request.\n\n        Args:\n            data: Contains approval_id\n\n        Returns:\n            Current approval status\n        \"\"\"\n    approval_id = data.get('approval_id')\n    if not approval_id:\n        return {'success': False, 'error': 'approval_id required'}\n    if approval_id in self.pending_approvals:\n        request = self.pending_approvals[approval_id]\n        created_at = datetime.fromisoformat(request.created_at)\n        timeout_at = created_at + timedelta(seconds=request.timeout_seconds)\n        if datetime.now() > timeout_at:\n            request.status = ApprovalStatus.TIMEOUT.value\n            self._finalize_approval(request)\n            return {'success': True, 'status': ApprovalStatus.TIMEOUT.value, 'reason': 'Approval request timed out'}\n        return {'success': True, 'status': request.status, 'created_at': request.created_at, 'timeout_at': timeout_at.isoformat(), 'context': request.context}\n    else:\n        for req in self.approval_history:\n            if req.id == approval_id:\n                return {'success': True, 'status': req.status, 'decision': req.decision, 'created_at': req.created_at}\n        return {'success': False, 'error': f'Approval request {approval_id} not found'}"
    },
    {
      "name": "_submit_decision",
      "line": 206,
      "code": "def _submit_decision(self, data: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"\n        Submit human decision for an approval request.\n\n        Args:\n            data: Contains approval_id, decision (approved/rejected), reason\n\n        Returns:\n            Decision result\n        \"\"\"\n    approval_id = data.get('approval_id')\n    decision = data.get('decision', 'rejected')\n    reason = data.get('reason', '')\n    decision_by = data.get('decision_by', 'human')\n    if not approval_id:\n        return {'success': False, 'error': 'approval_id required'}\n    if approval_id not in self.pending_approvals:\n        return {'success': False, 'error': f'Approval request {approval_id} not found or already processed'}\n    request = self.pending_approvals[approval_id]\n    request.status = ApprovalStatus.APPROVED.value if decision == 'approved' else ApprovalStatus.REJECTED.value\n    request.decision = {'decision': decision, 'reason': reason, 'decision_by': decision_by, 'decided_at': datetime.now().isoformat()}\n    self._finalize_approval(request)\n    logger.info(f'Approval {approval_id} {decision}: {reason}')\n    return {'success': True, 'approval_id': approval_id, 'status': request.status, 'decision': request.decision}"
    },
    {
      "name": "_finalize_approval",
      "line": 257,
      "code": "def _finalize_approval(self, request: ApprovalRequest):\n    \"\"\"Move approval from pending to history.\"\"\"\n    if request.id in self.pending_approvals:\n        del self.pending_approvals[request.id]\n    self.approval_history.append(request)\n    self._save_approval_request(request)"
    },
    {
      "name": "_send_notifications",
      "line": 267,
      "code": "async def _send_notifications(self, request: ApprovalRequest):\n    \"\"\"Send notifications to configured channels.\"\"\"\n    logger.info(f'Sending approval notifications for {request.id}')\n    notification_message = f'\ud83d\udd14 Approval Required: {request.type}\\nPriority: {request.priority}\\nID: {request.id}\\nContext: {json.dumps(request.context, indent=2)}'\n    for channel in self.notification_channels:\n        logger.info(f'Notification to {channel}: {notification_message[:100]}...')"
    },
    {
      "name": "_save_approval_request",
      "line": 285,
      "code": "def _save_approval_request(self, request: ApprovalRequest):\n    \"\"\"Save approval request to disk.\"\"\"\n    file_path = self.approval_dir / f'{request.id}.json'\n    with open(file_path, 'w') as f:\n        json.dump(asdict(request), f, indent=2)"
    },
    {
      "name": "wait_for_approval",
      "line": 291,
      "code": "async def wait_for_approval(self, approval_id: str, check_interval: int=5) -> Dict[str, Any]:\n    \"\"\"\n        Wait for approval decision (async).\n\n        Args:\n            approval_id: Approval request ID\n            check_interval: Seconds between status checks\n\n        Returns:\n            Final approval decision\n        \"\"\"\n    while True:\n        status_result = self._check_approval_status({'approval_id': approval_id})\n        if status_result.get('status') != ApprovalStatus.PENDING.value:\n            return status_result\n        await asyncio.sleep(check_interval)"
    }
  ]
}
