{
  "dead_imports": [
    {
      "line": 20,
      "module": "timedelta",
      "statement": "from datetime import datetime, timedelta"
    },
    {
      "line": 27,
      "module": "np",
      "statement": "import numpy as np"
    }
  ],
  "commented_blocks": [],
  "empty_functions": [],
  "unused_variables": [
    {
      "line": 308,
      "variable": "SP500_TICKERS"
    },
    {
      "line": 362,
      "variable": "PRIORITY_TICKERS"
    }
  ],
  "all_functions": [
    {
      "name": "main",
      "line": 1347,
      "code": "def main():\n    \"\"\"Main entry point for testing the strategy.\"\"\"\n    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n    strategy = GrowthStrategy(weekly_allocation=10.0)\n    orders = strategy.execute_weekly()\n    print('\\n' + '=' * 80)\n    print('GROWTH STRATEGY - WEEKLY EXECUTION RESULTS')\n    print('=' * 80)\n    print(f'\\nOrders Generated: {len(orders)}')\n    print('\\nOrder Details:')\n    for i, order in enumerate(orders, 1):\n        print(f'\\n  Order #{i}:')\n        print(f'    Symbol: {order.symbol}')\n        print(f'    Action: {order.action.upper()}')\n        print(f'    Quantity: {order.quantity}')\n        print(f'    Type: {order.order_type}')\n        print(f'    Reason: {order.reason}')\n    metrics = strategy.get_performance_metrics()\n    print('\\n' + '=' * 80)\n    print('PERFORMANCE METRICS')\n    print('=' * 80)\n    print(f\"\\n  Total Trades: {metrics['total_trades']}\")\n    print(f\"  Winning Trades: {metrics['winning_trades']}\")\n    print(f\"  Win Rate: {metrics['win_rate']:.1f}%\")\n    print(f\"  Total P&L: ${metrics['total_pnl']:.2f}\")\n    print(f\"  Avg Return: {metrics['avg_return']:.2f}%\")\n    print(f\"  Current Positions: {metrics['current_positions']}\")\n    print(f\"  Allocation Used: {metrics['allocation_used']:.1f}%\")\n    print(f\"  Position Value: ${metrics['position_value']:.2f}\")\n    print(f\"  Cash: ${metrics['cash']:.2f}\")\n    print(f\"  Total Value: ${metrics['total_value']:.2f}\")\n    print('\\n' + '=' * 80)"
    },
    {
      "name": "__init__",
      "line": 97,
      "code": "def __init__(self):\n    \"\"\"Initialize the multi-LLM analyzer.\"\"\"\n    logger.info('Initializing MultiLLMAnalyzer')"
    },
    {
      "name": "screen_stocks",
      "line": 101,
      "code": "def screen_stocks(self, symbols: List[str]) -> List[str]:\n    \"\"\"\n        Screen stocks using AI models.\n\n        Args:\n            symbols: List of stock symbols to screen\n\n        Returns:\n            List of promising stock symbols\n        \"\"\"\n    logger.info(f'Screening {len(symbols)} stocks with AI models')\n    return symbols[:50] if len(symbols) > 50 else symbols"
    },
    {
      "name": "get_consensus_score",
      "line": 116,
      "code": "def get_consensus_score(self, symbol: str, technical_data: Dict) -> float:\n    \"\"\"\n        Get multi-LLM consensus score for a stock.\n\n        Args:\n            symbol: Stock symbol\n            technical_data: Dictionary of technical indicators\n\n        Returns:\n            Consensus score between 0-100\n        \"\"\"\n    logger.debug(f'Getting consensus score for {symbol}')\n    score = 50.0\n    if technical_data.get('momentum', 0) > 0:\n        score += 12\n    if 30 < technical_data.get('rsi', 50) < 70:\n        score += 12\n    if technical_data.get('macd_histogram', 0) > 0:\n        score += 13\n    if technical_data.get('volume_ratio', 1) > 1.2:\n        score += 13\n    return min(100.0, max(0.0, score))"
    },
    {
      "name": "__init__",
      "line": 154,
      "code": "def __init__(self):\n    \"\"\"Initialize the Alpaca trader.\"\"\"\n    logger.info('Initializing AlpacaTrader')\n    self.positions: Dict[str, Position] = {}"
    },
    {
      "name": "submit_order",
      "line": 159,
      "code": "def submit_order(self, order: Order) -> bool:\n    \"\"\"\n        Submit a trading order.\n\n        Args:\n            order: Order to submit\n\n        Returns:\n            True if order was submitted successfully\n        \"\"\"\n    logger.info(f'Submitting {order.action} order for {order.symbol}: {order.quantity} shares')\n    return True"
    },
    {
      "name": "get_position",
      "line": 175,
      "code": "def get_position(self, symbol: str) -> Optional[Position]:\n    \"\"\"\n        Get current position for a symbol.\n\n        Args:\n            symbol: Stock symbol\n\n        Returns:\n            Position object or None if no position exists\n        \"\"\"\n    return self.positions.get(symbol)"
    },
    {
      "name": "get_all_positions",
      "line": 187,
      "code": "def get_all_positions(self) -> List[Position]:\n    \"\"\"\n        Get all current positions.\n\n        Returns:\n            List of Position objects\n        \"\"\"\n    return list(self.positions.values())"
    },
    {
      "name": "get_account_cash",
      "line": 196,
      "code": "def get_account_cash(self) -> float:\n    \"\"\"\n        Get available cash in trading account.\n\n        Returns:\n            Available cash amount\n        \"\"\"\n    return 10000.0"
    },
    {
      "name": "__init__",
      "line": 214,
      "code": "def __init__(self, max_position_size: float=0.15, max_daily_loss: float=0.05):\n    \"\"\"\n        Initialize the risk manager.\n\n        Args:\n            max_position_size: Maximum position size as fraction of portfolio (default 15%)\n            max_daily_loss: Maximum daily loss as fraction of portfolio (default 5%)\n        \"\"\"\n    self.max_position_size = max_position_size\n    self.max_daily_loss = max_daily_loss\n    logger.info(f'Initializing RiskManager (max_position={max_position_size}, max_loss={max_daily_loss})')"
    },
    {
      "name": "validate_order",
      "line": 228,
      "code": "def validate_order(self, order: Order, portfolio_value: float, current_positions: int) -> Tuple[bool, str]:\n    \"\"\"\n        Validate if an order meets risk requirements.\n\n        Args:\n            order: Order to validate\n            portfolio_value: Current portfolio value\n            current_positions: Number of current positions\n\n        Returns:\n            Tuple of (is_valid, reason)\n        \"\"\"\n    if order.action == 'buy' and current_positions >= 2:\n        return (False, 'Maximum position count (2) reached')\n    if order.action == 'buy':\n        order_value = order.quantity * (order.limit_price or 0)\n        position_fraction = order_value / portfolio_value if portfolio_value > 0 else 1.0\n        if position_fraction > self.max_position_size:\n            return (False, f'Position size ({position_fraction:.1%}) exceeds maximum ({self.max_position_size:.1%})')\n    return (True, 'Order validated')"
    },
    {
      "name": "check_stop_loss",
      "line": 261,
      "code": "def check_stop_loss(self, position: Position, current_price: float) -> bool:\n    \"\"\"\n        Check if stop-loss should be triggered.\n\n        Args:\n            position: Current position\n            current_price: Current market price\n\n        Returns:\n            True if stop-loss should be triggered\n        \"\"\"\n    return current_price <= position.stop_loss"
    },
    {
      "name": "check_take_profit",
      "line": 274,
      "code": "def check_take_profit(self, position: Position, current_price: float) -> bool:\n    \"\"\"\n        Check if take-profit should be triggered.\n\n        Args:\n            position: Current position\n            current_price: Current market price\n\n        Returns:\n            True if take-profit should be triggered\n        \"\"\"\n    return current_price >= position.take_profit"
    },
    {
      "name": "__init__",
      "line": 364,
      "code": "def __init__(self, weekly_allocation: float=10.0, use_sentiment: bool=True):\n    \"\"\"\n        Initialize the Growth Strategy.\n\n        Args:\n            weekly_allocation: Weekly trading allocation in dollars (default $10 = 5 days * $2)\n            use_sentiment: Whether to use sentiment scoring (default: True)\n        \"\"\"\n    self.weekly_allocation = weekly_allocation\n    self.stop_loss_pct = 0.03\n    self.take_profit_pct = 0.1\n    self.max_positions = 2\n    self.min_holding_weeks = 2\n    self.max_holding_weeks = 4\n    self.use_sentiment = use_sentiment\n    self.llm_analyzer = MultiLLMAnalyzer()\n    self.trader = AlpacaTrader()\n    self.risk_manager = RiskManager(max_position_size=0.15, max_daily_loss=0.05)\n    self.dcf_calculator: DCFValuationCalculator = get_global_dcf_calculator()\n    self.external_signals_cache: Dict[str, Dict] = {}\n    try:\n        mos_env = float(os.getenv('DCF_MARGIN_OF_SAFETY', '0.15'))\n    except ValueError:\n        mos_env = 0.15\n    self.required_margin_of_safety = max(0.0, min(0.5, mos_env))\n    self.total_trades = 0\n    self.winning_trades = 0\n    self.total_pnl = 0.0\n    self.sentiment_data = None\n    self.langchain_guard_enabled = os.getenv('LANGCHAIN_APPROVAL_ENABLED', 'false').lower() == 'true'\n    self._langchain_agent = None\n    logger.info(f\"GrowthStrategy initialized with ${weekly_allocation} weekly allocation, sentiment={('enabled' if use_sentiment else 'disabled')}\")"
    },
    {
      "name": "execute_weekly",
      "line": 411,
      "code": "def execute_weekly(self) -> List[Order]:\n    \"\"\"\n        Execute the weekly trading routine.\n\n        This is the main entry point called once per week to:\n        1. Screen candidates with AI\n        2. Apply technical filters\n        3. Get multi-LLM rankings\n        4. Generate buy orders for top stocks\n        5. Manage existing positions\n\n        Returns:\n            List of Order objects to execute\n        \"\"\"\n    logger.info('=' * 80)\n    logger.info('Starting weekly execution')\n    logger.info('=' * 80)\n    self.external_signals_cache = load_latest_signals()\n    if self.external_signals_cache:\n        logger.info('Loaded %d external signals (sources: %s)', len(self.external_signals_cache), ', '.join(sorted({sig.get('source', 'unknown') for sig in self.external_signals_cache.values()})))\n    else:\n        logger.info('No external signals found - proceeding with internal models only')\n    orders = []\n    management_orders = self.manage_existing_positions()\n    orders.extend(management_orders)\n    current_positions = len(self.trader.get_all_positions())\n    available_slots = self.max_positions - current_positions\n    if available_slots > 0:\n        logger.info(f'Available slots for new positions: {available_slots}')\n        candidates = self.screen_candidates_with_ai()\n        logger.info(f'AI screening returned {len(candidates)} candidates')\n        if candidates:\n            filtered = self.apply_technical_filters(candidates)\n            logger.info(f'Technical filters passed: {len(filtered)} stocks')\n            if filtered:\n                ranked = self.get_multi_llm_ranking(filtered)\n                logger.info(f'Multi-LLM ranking complete: {len(ranked)} stocks')\n                buy_orders = self._generate_buy_orders(ranked[:available_slots])\n                orders.extend(buy_orders)\n    else:\n        logger.info('No available slots for new positions')\n    logger.info(f'Weekly execution complete: {len(orders)} orders generated')\n    return orders"
    },
    {
      "name": "screen_candidates_with_ai",
      "line": 485,
      "code": "def screen_candidates_with_ai(self) -> List[str]:\n    \"\"\"\n        Screen S&P 500 stocks using AI models.\n\n        Uses multi-LLM analysis to identify promising candidates based on:\n        - News sentiment\n        - Earnings trends\n        - Market positioning\n        - Growth potential\n\n        Returns:\n            List of stock symbols that passed AI screening\n        \"\"\"\n    logger.info('Starting AI screening of S&P 500 stocks')\n    base_universe = self.SP500_TICKERS.copy()\n    for ticker in reversed(self.PRIORITY_TICKERS):\n        if ticker not in base_universe:\n            base_universe.insert(0, ticker)\n    candidates = base_universe\n    screened = self.llm_analyzer.screen_stocks(candidates)\n    logger.info(f'AI screening complete: {len(screened)}/{len(candidates)} stocks passed')\n    return screened"
    },
    {
      "name": "apply_technical_filters",
      "line": 516,
      "code": "def apply_technical_filters(self, candidates: List[str]) -> List[CandidateStock]:\n    \"\"\"\n        Apply technical filters to candidate stocks.\n\n        Filters based on:\n        - Momentum: Positive price momentum over 20 days\n        - RSI: Between 30 and 70 (not oversold/overbought)\n        - Volume: Above average volume (1.2x 20-day average)\n\n        Args:\n            candidates: List of stock symbols to filter\n\n        Returns:\n            List of CandidateStock objects that passed filters\n        \"\"\"\n    logger.info(f'Applying technical filters to {len(candidates)} candidates')\n    filtered_stocks = []\n    for symbol in candidates:\n        try:\n            score = self.calculate_technical_score(symbol)\n            ticker = yf.Ticker(symbol)\n            hist = ticker.history(period='3mo')\n            if len(hist) < 20:\n                logger.debug(f'{symbol}: Insufficient data')\n                continue\n            current_price = hist['Close'].iloc[-1]\n            momentum = self._calculate_momentum(hist)\n            rsi = self._calculate_rsi(hist)\n            macd_value, macd_signal, macd_histogram = self._calculate_macd(hist)\n            volume_ratio = self._calculate_volume_ratio(hist)\n            if momentum > 0 and 30 < rsi < 70 and (volume_ratio > 1.2) and (macd_histogram > 0):\n                candidate = CandidateStock(symbol=symbol, technical_score=score, consensus_score=0.0, current_price=current_price, momentum=momentum, rsi=rsi, macd_value=macd_value, macd_signal=macd_signal, macd_histogram=macd_histogram, volume_ratio=volume_ratio)\n                filtered_stocks.append(candidate)\n                logger.debug(f'{symbol}: PASSED (momentum={momentum:.2f}, RSI={rsi:.1f}, MACD={macd_histogram:.4f}, vol_ratio={volume_ratio:.2f})')\n            else:\n                logger.debug(f'{symbol}: FILTERED OUT (momentum={momentum:.2f}, RSI={rsi:.1f}, MACD={macd_histogram:.4f}, vol_ratio={volume_ratio:.2f})')\n        except Exception as e:\n            logger.warning(f'Error processing {symbol}: {e}')\n            continue\n    logger.info(f'Technical filtering complete: {len(filtered_stocks)} stocks passed')\n    return filtered_stocks"
    },
    {
      "name": "get_multi_llm_ranking",
      "line": 595,
      "code": "def get_multi_llm_ranking(self, candidates: List[CandidateStock]) -> List[CandidateStock]:\n    \"\"\"\n        Get multi-LLM consensus scores and rank candidates with sentiment overlay.\n\n        Combines:\n        1. Technical score (from MACD, RSI, volume)\n        2. LLM consensus score (multi-model agreement)\n        3. Sentiment modifier (Reddit + News sentiment)\n        4. DCF margin-of-safety filter + score\n        5. External signal conviction (Alpha Vantage news + YouTube analysis)\n\n        Final score weights:\n            - 30% technical\n            - 30% consensus\n            - 15% sentiment (confidence-weighted)\n            - 15% DCF discount (capped at 100)\n            - 10% external signal score (mapped to 0-100)\n\n        Args:\n            candidates: List of candidate stocks to rank\n\n        Returns:\n            List of CandidateStock objects sorted by ranking (best first)\n        \"\"\"\n    logger.info(f'Getting multi-LLM consensus scores for {len(candidates)} candidates')\n    if self.use_sentiment and self.sentiment_data is None:\n        try:\n            self.sentiment_data = load_latest_sentiment()\n            logger.info('Loaded sentiment data for ranking')\n            if getattr(self, 'sentiment_rag_enabled', True):\n                history = get_sentiment_history('SPY', limit=5)\n                formatted = [f\"{h['metadata'].get('snapshot_date')} (score={h['metadata'].get('sentiment_score', 0.0):.1f}, confidence={h['metadata'].get('confidence', 'n/a')})\" for h in history]\n                if formatted:\n                    logger.info('Recent SPY sentiment snapshots (RAG): %s', '; '.join(formatted))\n        except Exception as e:\n            logger.warning(f'Failed to load sentiment data: {e}')\n            self.sentiment_data = {}\n    filtered_candidates: List[CandidateStock] = []\n    for candidate in candidates:\n        technical_data = {'momentum': candidate.momentum, 'rsi': candidate.rsi, 'macd_value': candidate.macd_value, 'macd_signal': candidate.macd_signal, 'macd_histogram': candidate.macd_histogram, 'volume_ratio': candidate.volume_ratio, 'technical_score': candidate.technical_score}\n        consensus_score = self.llm_analyzer.get_consensus_score(candidate.symbol, technical_data)\n        candidate.consensus_score = consensus_score\n        sentiment_modifier = 0\n        if self.use_sentiment and self.sentiment_data:\n            try:\n                sent_score, sent_confidence, _ = get_ticker_sentiment(candidate.symbol, self.sentiment_data, default_score=50.0)\n                confidence_weight = {'high': 1.0, 'medium': 0.6, 'low': 0.3}.get(sent_confidence, 0.3)\n                sentiment_modifier = (sent_score - 50) / 50 * 15 * confidence_weight\n                logger.debug(f'{candidate.symbol}: sentiment={sent_score:.1f} (confidence={sent_confidence}) \u2192 modifier={sentiment_modifier:+.1f}')\n            except Exception as e:\n                logger.warning(f'Failed to get sentiment for {candidate.symbol}: {e}')\n        candidate.sentiment_modifier = sentiment_modifier\n        dcf_result = self.dcf_calculator.get_intrinsic_value(candidate.symbol)\n        if not dcf_result:\n            logger.info('Skipping %s - DCF valuation unavailable (requires Alpha Vantage fundamentals)', candidate.symbol)\n            continue\n        intrinsic_value = dcf_result.intrinsic_value\n        if intrinsic_value <= 0:\n            logger.info('Skipping %s - intrinsic value invalid (%.2f)', candidate.symbol, intrinsic_value)\n            continue\n        discount = (intrinsic_value - candidate.current_price) / intrinsic_value\n        candidate.intrinsic_value = intrinsic_value\n        candidate.dcf_discount = discount\n        if discount < self.required_margin_of_safety:\n            logger.info('Skipping %s - margin of safety %.1f%% below threshold %.1f%%', candidate.symbol, discount * 100, self.required_margin_of_safety * 100)\n            continue\n        external_signal = get_signal_for_ticker(candidate.symbol, signals=self.external_signals_cache)\n        if external_signal:\n            candidate.external_signal_score = external_signal.get('score', 0.0)\n            candidate.external_signal_confidence = external_signal.get('confidence', 0.0)\n            if candidate.external_signal_score < -20:\n                logger.info('Skipping %s - external signals bearish (score=%.1f)', candidate.symbol, candidate.external_signal_score)\n                continue\n        else:\n            candidate.external_signal_score = 0.0\n            candidate.external_signal_confidence = 0.0\n        logger.debug('%s: consensus=%.1f, sentiment=%.1f, MACD=%.4f, intrinsic=%.2f, discount=%.1f%%, external=%.1f', candidate.symbol, consensus_score, sentiment_modifier, candidate.macd_histogram, intrinsic_value, discount * 100, candidate.external_signal_score)\n        filtered_candidates.append(candidate)\n    if not filtered_candidates:\n        logger.warning('All candidates rejected after DCF margin-of-safety filter')\n        return []\n    filtered_candidates.sort(key=lambda x: 0.3 * x.technical_score + 0.3 * x.consensus_score + 0.15 * (50 + x.sentiment_modifier) + 0.15 * min(100.0, max(0.0, (x.dcf_discount or 0.0) * 400)) + 0.1 * min(100.0, max(0.0, (x.external_signal_score + 100) / 2)), reverse=True)\n    logger.info('Multi-LLM ranking complete (with sentiment + DCF)')\n    for i, candidate in enumerate(filtered_candidates[:5], 1):\n        sentiment_mod = candidate.sentiment_modifier\n        dcf_score = min(100.0, max(0.0, (candidate.dcf_discount or 0.0) * 400))\n        external_score = min(100.0, max(0.0, (candidate.external_signal_score + 100) / 2))\n        combined_score = 0.3 * candidate.technical_score + 0.3 * candidate.consensus_score + 0.15 * (50 + sentiment_mod) + 0.15 * dcf_score + 0.1 * external_score\n        logger.info(f'  #{i}: {candidate.symbol} (combined={combined_score:.1f}, technical={candidate.technical_score:.1f}, consensus={candidate.consensus_score:.1f}, sentiment_mod={sentiment_mod:+.1f}, dcf_discount={(candidate.dcf_discount or 0.0) * 100:.1f}%, external={candidate.external_signal_score:.1f}, intrinsic={candidate.intrinsic_value:.2f})')\n    return filtered_candidates"
    },
    {
      "name": "manage_existing_positions",
      "line": 805,
      "code": "def manage_existing_positions(self) -> List[Order]:\n    \"\"\"\n        Manage existing positions and generate exit orders.\n\n        Checks each position for:\n        - Stop-loss trigger (3% loss)\n        - Take-profit trigger (10% gain)\n        - Maximum holding period (4 weeks)\n        - Minimum holding period (2 weeks) for regular review\n\n        Returns:\n            List of sell orders for positions that should be closed\n        \"\"\"\n    logger.info('Managing existing positions')\n    orders = []\n    positions = self.trader.get_all_positions()\n    if not positions:\n        logger.info('No existing positions to manage')\n        return orders\n    logger.info(f'Checking {len(positions)} positions')\n    for position in positions:\n        try:\n            ticker = yf.Ticker(position.symbol)\n            current_price = ticker.history(period='1d')['Close'].iloc[-1]\n            pnl_pct = (current_price - position.entry_price) / position.entry_price\n            holding_days = (datetime.now() - position.entry_date).days\n            holding_weeks = holding_days / 7\n            logger.info(f'  {position.symbol}: price=${current_price:.2f}, entry=${position.entry_price:.2f}, P&L={pnl_pct:.2%}, holding={holding_weeks:.1f}w')\n            if self.risk_manager.check_stop_loss(position, current_price):\n                logger.info(f'  -> STOP-LOSS TRIGGERED for {position.symbol}')\n                order = Order(symbol=position.symbol, action='sell', quantity=position.quantity, order_type='market', reason=f'Stop-loss triggered at {current_price:.2f} (entry: {position.entry_price:.2f})')\n                orders.append(order)\n                self._record_trade(position, current_price, 'stop_loss')\n                continue\n            if self.risk_manager.check_take_profit(position, current_price):\n                logger.info(f'  -> TAKE-PROFIT TRIGGERED for {position.symbol}')\n                order = Order(symbol=position.symbol, action='sell', quantity=position.quantity, order_type='market', reason=f'Take-profit triggered at {current_price:.2f} (entry: {position.entry_price:.2f})')\n                orders.append(order)\n                self._record_trade(position, current_price, 'take_profit')\n                continue\n            if holding_weeks >= self.max_holding_weeks:\n                logger.info(f'  -> MAX HOLDING PERIOD for {position.symbol}')\n                order = Order(symbol=position.symbol, action='sell', quantity=position.quantity, order_type='market', reason=f'Maximum holding period ({self.max_holding_weeks}w) reached')\n                orders.append(order)\n                self._record_trade(position, current_price, 'max_holding')\n                continue\n            if holding_weeks >= self.min_holding_weeks:\n                should_exit = self._should_exit_position(position, current_price)\n                if should_exit:\n                    logger.info(f'  -> REVIEW EXIT for {position.symbol}')\n                    order = Order(symbol=position.symbol, action='sell', quantity=position.quantity, order_type='market', reason='Weekly review indicates exit')\n                    orders.append(order)\n                    self._record_trade(position, current_price, 'review_exit')\n                else:\n                    logger.info(f'  -> HOLD {position.symbol}')\n        except Exception as e:\n            logger.error(f'Error managing position {position.symbol}: {e}')\n            continue\n    logger.info(f'Position management complete: {len(orders)} exit orders generated')\n    return orders"
    },
    {
      "name": "calculate_technical_score",
      "line": 915,
      "code": "def calculate_technical_score(self, symbol: str) -> float:\n    \"\"\"\n        Calculate technical score for a stock.\n\n        Combines multiple technical indicators into a single score (0-100):\n        - Price momentum (20-day)\n        - RSI (Relative Strength Index)\n        - Volume trends\n        - Moving average crossovers\n\n        Args:\n            symbol: Stock symbol\n\n        Returns:\n            Technical score between 0 and 100\n        \"\"\"\n    try:\n        ticker = yf.Ticker(symbol)\n        hist = ticker.history(period='3mo')\n        if len(hist) < 20:\n            return 0.0\n        score = 0.0\n        momentum = self._calculate_momentum(hist)\n        if momentum > 0:\n            score += min(20, momentum * 10)\n        rsi = self._calculate_rsi(hist)\n        if 30 < rsi < 70:\n            score += 20\n        elif 20 < rsi < 80:\n            score += 12\n        macd_value, macd_signal, macd_histogram = self._calculate_macd(hist)\n        if macd_histogram > 0:\n            score += 20\n        elif macd_histogram > -0.01:\n            score += 10\n        elif macd_histogram < 0:\n            score += 0\n        volume_ratio = self._calculate_volume_ratio(hist)\n        if volume_ratio > 1.5:\n            score += 20\n        elif volume_ratio > 1.2:\n            score += 12\n        elif volume_ratio > 1.0:\n            score += 8\n        elif volume_ratio < 0.5:\n            score -= 10\n        ma_score = self._calculate_ma_score(hist)\n        score += min(20, ma_score)\n        return min(100.0, max(0.0, score))\n    except Exception as e:\n        logger.warning(f'Error calculating technical score for {symbol}: {e}')\n        return 0.0"
    },
    {
      "name": "get_performance_metrics",
      "line": 989,
      "code": "def get_performance_metrics(self) -> Dict:\n    \"\"\"\n        Get strategy performance metrics.\n\n        Returns:\n            Dictionary containing performance statistics:\n            - total_trades: Total number of trades executed\n            - winning_trades: Number of profitable trades\n            - win_rate: Percentage of winning trades\n            - total_pnl: Total profit/loss\n            - avg_return: Average return per trade\n            - current_positions: Number of current positions\n            - allocation_used: Percentage of allocation currently used\n        \"\"\"\n    positions = self.trader.get_all_positions()\n    cash = self.trader.get_account_cash()\n    position_value = 0.0\n    for pos in positions:\n        try:\n            ticker = yf.Ticker(pos.symbol)\n            current_price = ticker.history(period='1d')['Close'].iloc[-1]\n            position_value += current_price * pos.quantity\n        except:\n            position_value += pos.entry_price * pos.quantity\n    total_value = cash + position_value\n    allocation_used = position_value / total_value * 100 if total_value > 0 else 0\n    win_rate = self.winning_trades / self.total_trades * 100 if self.total_trades > 0 else 0\n    avg_return = self.total_pnl / self.total_trades if self.total_trades > 0 else 0\n    metrics = {'total_trades': self.total_trades, 'winning_trades': self.winning_trades, 'win_rate': win_rate, 'total_pnl': self.total_pnl, 'avg_return': avg_return, 'current_positions': len(positions), 'allocation_used': allocation_used, 'position_value': position_value, 'cash': cash, 'total_value': total_value}\n    return metrics"
    },
    {
      "name": "_calculate_momentum",
      "line": 1043,
      "code": "def _calculate_momentum(self, hist: pd.DataFrame) -> float:\n    \"\"\"Calculate price momentum over 20 days.\"\"\"\n    if len(hist) < 20:\n        return 0.0\n    current_price = hist['Close'].iloc[-1]\n    price_20d_ago = hist['Close'].iloc[-20]\n    momentum = (current_price - price_20d_ago) / price_20d_ago\n    return momentum"
    },
    {
      "name": "_calculate_rsi",
      "line": 1054,
      "code": "def _calculate_rsi(self, hist: pd.DataFrame, period: int=14) -> float:\n    \"\"\"Calculate Relative Strength Index.\"\"\"\n    if len(hist) < period + 1:\n        return 50.0\n    closes = hist['Close']\n    deltas = closes.diff()\n    gains = deltas.where(deltas > 0, 0.0)\n    losses = -deltas.where(deltas < 0, 0.0)\n    avg_gains = gains.rolling(window=period).mean()\n    avg_losses = losses.rolling(window=period).mean()\n    rs = avg_gains / avg_losses\n    rsi = 100 - 100 / (1 + rs)\n    return rsi.iloc[-1]"
    },
    {
      "name": "_calculate_macd",
      "line": 1073,
      "code": "def _calculate_macd(self, hist: pd.DataFrame, fast: int=12, slow: int=26, signal: int=9) -> tuple:\n    \"\"\"\n        Calculate MACD (Moving Average Convergence Divergence).\n\n        MACD is a trend-following momentum indicator that shows the relationship between\n        two exponential moving averages (EMAs) of a security's price.\n\n        Formula:\n        - MACD Line = 12-day EMA - 26-day EMA\n        - Signal Line = 9-day EMA of MACD Line\n        - Histogram = MACD Line - Signal Line\n\n        Trading Signals:\n        - Bullish: MACD crosses above signal line (histogram > 0)\n        - Bearish: MACD crosses below signal line (histogram < 0)\n        - Momentum strength: Larger histogram = stronger momentum\n\n        Args:\n            hist: Historical price DataFrame with 'Close' column\n            fast: Fast EMA period (default: 12)\n            slow: Slow EMA period (default: 26)\n            signal: Signal line EMA period (default: 9)\n\n        Returns:\n            Tuple of (macd_value, signal_line, histogram)\n        \"\"\"\n    if len(hist) < slow + signal:\n        return (0.0, 0.0, 0.0)\n    closes = hist['Close']\n    ema_fast = closes.ewm(span=fast, adjust=False).mean()\n    ema_slow = closes.ewm(span=slow, adjust=False).mean()\n    macd_line = ema_fast - ema_slow\n    signal_line = macd_line.ewm(span=signal, adjust=False).mean()\n    histogram = macd_line - signal_line\n    return (float(macd_line.iloc[-1]) if not pd.isna(macd_line.iloc[-1]) else 0.0, float(signal_line.iloc[-1]) if not pd.isna(signal_line.iloc[-1]) else 0.0, float(histogram.iloc[-1]) if not pd.isna(histogram.iloc[-1]) else 0.0)"
    },
    {
      "name": "_calculate_volume_ratio",
      "line": 1126,
      "code": "def _calculate_volume_ratio(self, hist: pd.DataFrame) -> float:\n    \"\"\"Calculate current volume vs 20-day average.\"\"\"\n    if len(hist) < 20:\n        return 1.0\n    current_volume = hist['Volume'].iloc[-1]\n    avg_volume = hist['Volume'].iloc[-20:].mean()\n    if avg_volume == 0:\n        return 1.0\n    return current_volume / avg_volume"
    },
    {
      "name": "_calculate_ma_score",
      "line": 1139,
      "code": "def _calculate_ma_score(self, hist: pd.DataFrame) -> float:\n    \"\"\"Calculate moving average crossover score (0-20 points).\"\"\"\n    if len(hist) < 50:\n        return 0.0\n    closes = hist['Close']\n    ma20 = closes.rolling(window=20).mean()\n    ma50 = closes.rolling(window=50).mean()\n    current_price = closes.iloc[-1]\n    current_ma20 = ma20.iloc[-1]\n    current_ma50 = ma50.iloc[-1]\n    score = 0.0\n    if current_price > current_ma20 and current_price > current_ma50:\n        score += 12\n    if current_ma20 > current_ma50:\n        score += 8\n    return score"
    },
    {
      "name": "_generate_buy_orders",
      "line": 1164,
      "code": "def _generate_buy_orders(self, candidates: List[CandidateStock]) -> List[Order]:\n    \"\"\"Generate buy orders for top candidate stocks.\"\"\"\n    orders = []\n    available_cash = self.trader.get_account_cash()\n    cash_per_position = self.weekly_allocation / len(candidates) if candidates else 0\n    logger.info(f'Generating buy orders for {len(candidates)} candidates')\n    logger.info(f'Cash per position: ${cash_per_position:.2f}')\n    for candidate in candidates:\n        try:\n            if candidate.dcf_discount is None or candidate.intrinsic_value is None:\n                logger.warning('Skipping order for %s - missing DCF metrics (discount=%s, intrinsic=%s)', candidate.symbol, candidate.dcf_discount, candidate.intrinsic_value)\n                continue\n            dcf_discount_pct = candidate.dcf_discount * 100\n            if candidate.dcf_discount < self.required_margin_of_safety:\n                logger.info('Skipping order for %s - margin of safety %.1f%% below threshold %.1f%%', candidate.symbol, dcf_discount_pct, self.required_margin_of_safety * 100)\n                continue\n            quantity = int(cash_per_position / candidate.current_price)\n            if quantity < 1:\n                logger.warning(f'Insufficient funds for {candidate.symbol} at ${candidate.current_price:.2f}')\n                continue\n            dcf_score = min(100.0, max(0.0, candidate.dcf_discount * 400))\n            combined_score = 0.3 * candidate.technical_score + 0.3 * candidate.consensus_score + 0.15 * (50 + candidate.sentiment_modifier) + 0.15 * dcf_score + 0.1 * min(100.0, max(0.0, (candidate.external_signal_score + 100) / 2))\n            order = Order(symbol=candidate.symbol, action='buy', quantity=quantity, order_type='market', limit_price=candidate.current_price, reason=f'Top ranked stock (combined={combined_score:.1f}, DCF discount={dcf_discount_pct:.1f}%, external_score={candidate.external_signal_score:.1f}, intrinsic=${candidate.intrinsic_value:.2f})')\n            portfolio_value = available_cash\n            current_positions = len(self.trader.get_all_positions())\n            is_valid, reason = self.risk_manager.validate_order(order, portfolio_value, current_positions)\n            if is_valid:\n                if self.langchain_guard_enabled and (not self._langchain_guard(candidate.symbol)):\n                    logger.warning('  LangChain approval gate rejected order for %s', candidate.symbol)\n                    continue\n                orders.append(order)\n                logger.info(f'  BUY order created: {candidate.symbol} x{quantity} @ ${candidate.current_price:.2f}')\n            else:\n                logger.warning(f'  Order rejected for {candidate.symbol}: {reason}')\n        except Exception as e:\n            logger.error(f'Error generating buy order for {candidate.symbol}: {e}')\n            continue\n    return orders"
    },
    {
      "name": "_should_exit_position",
      "line": 1260,
      "code": "def _should_exit_position(self, position: Position, current_price: float) -> bool:\n    \"\"\"\n        Determine if a position should be exited during weekly review.\n\n        Considers:\n        - Current P&L\n        - Technical indicators\n        - Consensus score changes\n        \"\"\"\n    pnl_pct = (current_price - position.entry_price) / position.entry_price\n    if pnl_pct < -0.02:\n        return True\n    try:\n        technical_score = self.calculate_technical_score(position.symbol)\n        if technical_score < 40:\n            return True\n    except:\n        pass\n    return False"
    },
    {
      "name": "_record_trade",
      "line": 1286,
      "code": "def _record_trade(self, position: Position, exit_price: float, exit_reason: str):\n    \"\"\"Record trade results for performance tracking.\"\"\"\n    pnl = (exit_price - position.entry_price) * position.quantity\n    pnl_pct = (exit_price - position.entry_price) / position.entry_price\n    self.total_trades += 1\n    if pnl > 0:\n        self.winning_trades += 1\n    self.total_pnl += pnl\n    logger.info(f'Trade recorded: {position.symbol} {exit_reason} - P&L: ${pnl:.2f} ({pnl_pct:.2%})')"
    },
    {
      "name": "_langchain_guard",
      "line": 1302,
      "code": "def _langchain_guard(self, symbol: str) -> bool:\n    \"\"\"\n        Optional LangChain approval step for GrowthStrategy orders.\n        \"\"\"\n    try:\n        if self._langchain_agent is None:\n            from langchain_agents.agents import build_price_action_agent\n            self._langchain_agent = build_price_action_agent()\n        prompt = f'You are the growth strategy approval co-pilot. Decide whether we should open a NEW long position today. Respond with only APPROVE or DECLINE.\\n\\nTicker: {symbol}\\nUse the available sentiment and MCP tools to gather context. Decline if sentiment is negative, confidence is low, or data is stale.'\n        response = self._langchain_agent.invoke({'input': prompt})\n        if isinstance(response, dict):\n            text = response.get('output', '')\n        else:\n            text = str(response)\n        normalized = text.strip().lower()\n        approved = 'approve' in normalized and 'decline' not in normalized\n        if approved:\n            logger.info('LangChain approval granted for %s: %s', symbol, text)\n        else:\n            logger.warning('LangChain approval denied for %s: %s', symbol, text)\n        return approved\n    except Exception as exc:\n        logger.error('LangChain approval gate error for %s: %s', symbol, exc)\n        fail_open = os.getenv('LANGCHAIN_APPROVAL_FAIL_OPEN', 'true').lower()\n        if fail_open == 'true':\n            logger.warning('LangChain approval unavailable; defaulting to APPROVE (fail-open).')\n            return True\n        return False"
    }
  ]
}
