{
  "dead_imports": [
    {
      "line": 7,
      "module": "annotations",
      "statement": "from __future__ import annotations"
    },
    {
      "line": 11,
      "module": "timedelta",
      "statement": "from datetime import datetime, timedelta"
    },
    {
      "line": 12,
      "module": "Path",
      "statement": "from pathlib import Path"
    }
  ],
  "commented_blocks": [],
  "empty_functions": [],
  "unused_variables": [],
  "all_functions": [
    {
      "name": "get_market_data",
      "line": 24,
      "code": "@tool\ndef get_market_data(symbol: str, lookback_days: int=60, timeframe: str='1Day') -> str:\n    \"\"\"\n    Fetch historical market data (OHLCV) for a symbol.\n\n    Args:\n        symbol: Stock ticker symbol (e.g., 'AAPL', 'SPY')\n        lookback_days: Number of days of historical data to fetch (default: 60)\n        timeframe: Data timeframe - '1Day', '1Hour', '5Min' (default: '1Day')\n\n    Returns:\n        JSON string with market data including dates, open, high, low, close, volume\n    \"\"\"\n    try:\n        provider = get_market_data_provider()\n        df = provider.get_daily_bars(symbol=symbol, lookback_days=lookback_days)\n        if df.empty:\n            return json.dumps({'error': f'No data available for {symbol}'})\n        data = {'symbol': symbol, 'rows': len(df), 'start_date': df.index[0].isoformat() if len(df) > 0 else None, 'end_date': df.index[-1].isoformat() if len(df) > 0 else None, 'latest_close': float(df['Close'].iloc[-1]) if len(df) > 0 else None, 'latest_volume': float(df['Volume'].iloc[-1]) if len(df) > 0 else None, 'data': [{'date': date.isoformat(), 'open': float(row['Open']), 'high': float(row['High']), 'low': float(row['Low']), 'close': float(row['Close']), 'volume': float(row['Volume'])} for date, row in df.tail(100).iterrows()]}\n        return json.dumps(data, indent=2)\n    except Exception as e:\n        logger.exception(f'Error fetching market data for {symbol}')\n        return json.dumps({'error': str(e)})"
    },
    {
      "name": "query_sentiment",
      "line": 74,
      "code": "@tool\ndef query_sentiment(query: str, ticker: Optional[str]=None, limit: int=5) -> str:\n    \"\"\"\n    Search historical sentiment data using semantic search.\n\n    Args:\n        query: Natural language query about market sentiment (e.g., \"bullish momentum\")\n        ticker: Optional ticker symbol to filter results\n        limit: Maximum number of results to return (default: 5)\n\n    Returns:\n        JSON string with sentiment entries matching the query\n    \"\"\"\n    try:\n        store = SentimentRAGStore()\n        results = store.query(query=query, ticker=ticker, top_k=limit)\n        if not results:\n            return json.dumps({'message': 'No matching sentiment entries found'})\n        formatted = []\n        for entry in results:\n            metadata = entry.get('metadata', {})\n            formatted.append({'id': entry.get('id'), 'score': entry.get('score'), 'snapshot_date': metadata.get('snapshot_date'), 'ticker': metadata.get('ticker'), 'sentiment_score': metadata.get('sentiment_score'), 'confidence': metadata.get('confidence'), 'market_regime': metadata.get('market_regime'), 'sources': metadata.get('source_list')})\n        return json.dumps(formatted, indent=2)\n    except Exception as e:\n        logger.exception(f'Error querying sentiment: {query}')\n        return json.dumps({'error': str(e)})"
    },
    {
      "name": "get_sentiment_history",
      "line": 120,
      "code": "@tool\ndef get_sentiment_history(ticker: str, limit: int=5) -> str:\n    \"\"\"\n    Get recent sentiment history for a ticker.\n\n    Args:\n        ticker: Stock ticker symbol (e.g., 'SPY', 'NVDA')\n        limit: Number of recent entries to return (default: 5)\n\n    Returns:\n        JSON string with recent sentiment snapshots for the ticker\n    \"\"\"\n    try:\n        store = SentimentRAGStore()\n        results = store.get_ticker_history(ticker=ticker, limit=limit)\n        if not results:\n            return json.dumps({'message': f'No sentiment history found for {ticker}'})\n        formatted = []\n        for entry in results:\n            metadata = entry.get('metadata', {})\n            formatted.append({'id': entry.get('id'), 'snapshot_date': metadata.get('snapshot_date'), 'ticker': metadata.get('ticker'), 'sentiment_score': metadata.get('sentiment_score'), 'confidence': metadata.get('confidence'), 'market_regime': metadata.get('market_regime'), 'sources': metadata.get('source_list')})\n        return json.dumps(formatted, indent=2)\n    except Exception as e:\n        logger.exception(f'Error fetching sentiment history for {ticker}')\n        return json.dumps({'error': str(e)})"
    },
    {
      "name": "analyze_technical_indicators",
      "line": 163,
      "code": "@tool\ndef analyze_technical_indicators(symbol: str, lookback_days: int=60) -> str:\n    \"\"\"\n    Calculate technical indicators for a symbol.\n\n    Args:\n        symbol: Stock ticker symbol\n        lookback_days: Number of days of data to use for calculations\n\n    Returns:\n        JSON string with technical indicators (RSI, MACD, volume ratio, etc.)\n    \"\"\"\n    try:\n        from src.utils.technical_indicators import calculate_macd, calculate_rsi, calculate_volume_ratio\n        provider = get_market_data_provider()\n        df = provider.get_daily_bars(symbol=symbol, lookback_days=lookback_days)\n        if df.empty:\n            return json.dumps({'error': f'No data available for {symbol}'})\n        if len(df) < 26:\n            return json.dumps({'error': f'Insufficient data for {symbol} (need at least 26 bars)'})\n        macd_value, macd_signal, macd_histogram = calculate_macd(df['Close'])\n        rsi_val = calculate_rsi(df['Close'])\n        volume_ratio = calculate_volume_ratio(df)\n        indicators = {'symbol': symbol, 'macd': {'value': float(macd_value), 'signal': float(macd_signal), 'histogram': float(macd_histogram)}, 'rsi': float(rsi_val), 'volume_ratio': float(volume_ratio), 'current_price': float(df['Close'].iloc[-1]), 'calculation_date': datetime.now().isoformat()}\n        return json.dumps(indicators, indent=2)\n    except Exception as e:\n        logger.exception(f'Error calculating technical indicators for {symbol}')\n        return json.dumps({'error': str(e)})"
    },
    {
      "name": "build_trading_tools",
      "line": 219,
      "code": "def build_trading_tools() -> List:\n    \"\"\"\n    Build all trading-specific tools for deepagents.\n\n    Returns:\n        List of tool objects compatible with deepagents\n    \"\"\"\n    return [get_market_data, query_sentiment, get_sentiment_history, analyze_technical_indicators]"
    }
  ]
}
