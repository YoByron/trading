#!/usr/bin/env python3
"""
Publish blog posts to GitHub Pages and Dev.to.

Usage:
    python publish_blog.py "Topic title here"
    python publish_blog.py  # Auto-generates from recent context
"""

import json
import os
import re
import subprocess
import sys
from datetime import datetime
from pathlib import Path

try:
    import requests
except ImportError:
    requests = None

# Project paths
PROJECT_ROOT = Path(__file__).parent.parent.parent.parent.parent
POSTS_DIR = PROJECT_ROOT / "docs" / "_posts"


def slugify(text: str) -> str:
    """Convert text to URL-friendly slug."""
    # Lowercase
    slug = text.lower()
    # Remove special chars except spaces and hyphens
    slug = re.sub(r"[^a-z0-9\s-]", "", slug)
    # Replace spaces with hyphens
    slug = re.sub(r"\s+", "-", slug)
    # Remove multiple hyphens
    slug = re.sub(r"-+", "-", slug)
    # Trim hyphens from ends
    slug = slug.strip("-")
    return slug[:50]  # Limit length


def get_recent_commits(n: int = 5) -> list[str]:
    """Get recent commit messages for context."""
    try:
        result = subprocess.run(
            ["git", "log", f"-{n}", "--oneline", "--no-decorate"],
            cwd=PROJECT_ROOT,
            capture_output=True,
            text=True,
            check=True,
        )
        return result.stdout.strip().split("\n")
    except subprocess.CalledProcessError:
        return []


def get_current_branch() -> str:
    """Get current git branch name."""
    try:
        result = subprocess.run(
            ["git", "branch", "--show-current"],
            cwd=PROJECT_ROOT,
            capture_output=True,
            text=True,
            check=True,
        )
        return result.stdout.strip()
    except subprocess.CalledProcessError:
        return "main"


def generate_blog_content(
    title: str,
    challenge: str = "",
    approach: str = "",
    tech_stack: list[str] | None = None,
    results: str = "",
    lessons: str = "",
) -> str:
    """Generate blog post content."""
    now = datetime.now()
    date_str = now.strftime("%Y-%m-%d %H:%M:%S")

    if tech_stack is None:
        tech_stack = [
            "Claude Opus 4.5",
            "Python 3.11",
            "GitHub Actions",
            "Alpaca API",
        ]

    # Default content if not provided
    if not challenge:
        challenge = "This post documents recent engineering work on the AI trading system."
    if not approach:
        approach = "We followed our established patterns using Claude Code for implementation."
    if not results:
        results = "The implementation was successful and is now deployed."
    if not lessons:
        lessons = "Continuous iteration with AI assistance accelerates development."

    tech_table = "\n".join(f"| {tech} |" for tech in tech_stack)

    content = f"""---
layout: post
title: "{title}"
date: {date_str}
categories: [engineering, trading, ai]
tags: [claude-ai, python, automation, trading-system]
---

# {title}

*Published: {now.strftime("%B %d, %Y")}*

---

## The Challenge

{challenge}

---

## The Approach

{approach}

---

## Tech Stack

| Technology |
|------------|
{tech_table}

---

## Results

{results}

---

## Lessons Learned

{lessons}

---

*Auto-generated by AI Trading System | [View Source](https://github.com/IgorGanapolsky/trading)*

*Follow our journey: [GitHub Pages](https://igorganapolsky.github.io/trading/)*
"""
    return content


def save_to_github_pages(title: str, content: str) -> Path:
    """Save blog post to docs/_posts/ directory."""
    POSTS_DIR.mkdir(parents=True, exist_ok=True)

    date_str = datetime.now().strftime("%Y-%m-%d")
    slug = slugify(title)
    filename = f"{date_str}-{slug}.md"
    filepath = POSTS_DIR / filename

    with open(filepath, "w") as f:
        f.write(content)

    print(f"Saved to GitHub Pages: {filepath}")
    return filepath


def publish_to_devto(title: str, content: str, filepath: Path) -> str | None:
    """Publish to Dev.to via API."""
    api_key = os.getenv("DEVTO_API_KEY")

    if not api_key:
        print("DEVTO_API_KEY not set - skipping Dev.to publish")
        return None

    if requests is None:
        print("requests library not available - skipping Dev.to publish")
        return None

    # Remove Jekyll frontmatter for Dev.to
    lines = content.split("\n")
    in_frontmatter = False
    clean_lines = []
    for line in lines:
        if line.strip() == "---":
            in_frontmatter = not in_frontmatter
            continue
        if not in_frontmatter:
            clean_lines.append(line)

    body = "\n".join(clean_lines)

    # Add Dev.to footer
    body += """

---

*Follow our AI trading journey: [GitHub](https://github.com/IgorGanapolsky/trading)*

*All trades are paper trading - not financial advice.*
"""

    # Build canonical URL
    date_str = datetime.now().strftime("%Y-%m-%d")
    slug = slugify(title)
    canonical_url = f"https://igorganapolsky.github.io/trading/{date_str}-{slug}/"

    headers = {"api-key": api_key, "Content-Type": "application/json"}

    payload = {
        "article": {
            "title": title,
            "body_markdown": body,
            "published": True,
            "tags": ["trading", "ai", "machinelearning", "python"],
            "series": "AI Trading Daily Reports",
            "canonical_url": canonical_url,
        }
    }

    try:
        resp = requests.post(
            "https://dev.to/api/articles", headers=headers, json=payload, timeout=30
        )

        if resp.status_code in [200, 201]:
            url = resp.json().get("url")
            print(f"Published to Dev.to: {url}")
            return url
        else:
            print(f"Dev.to publish failed: {resp.status_code}")
            print(resp.text[:500] if resp.text else "No response body")
            return None

    except Exception as e:
        print(f"Dev.to error: {e}")
        return None


def git_commit_and_push(filepath: Path, title: str) -> str | None:
    """Commit and push the blog post."""
    try:
        # Add the file
        subprocess.run(
            ["git", "add", str(filepath)],
            cwd=PROJECT_ROOT,
            check=True,
            capture_output=True,
        )

        # Check if there are changes to commit
        result = subprocess.run(
            ["git", "diff", "--staged", "--quiet"],
            cwd=PROJECT_ROOT,
            capture_output=True,
        )

        if result.returncode == 0:
            print("No changes to commit - file may already exist")
            return None

        # Commit
        commit_msg = f"feat(blog): Publish: {title[:50]}"
        subprocess.run(
            ["git", "commit", "-m", commit_msg],
            cwd=PROJECT_ROOT,
            check=True,
            capture_output=True,
        )

        # Get commit hash
        result = subprocess.run(
            ["git", "rev-parse", "--short", "HEAD"],
            cwd=PROJECT_ROOT,
            capture_output=True,
            text=True,
            check=True,
        )
        commit_hash = result.stdout.strip()

        # Push
        subprocess.run(
            ["git", "push"],
            cwd=PROJECT_ROOT,
            check=True,
            capture_output=True,
        )

        print(f"Committed and pushed: {commit_hash}")
        return commit_hash

    except subprocess.CalledProcessError as e:
        print(f"Git error: {e}")
        if e.stderr:
            print(e.stderr.decode() if isinstance(e.stderr, bytes) else e.stderr)
        return None


def main():
    """Main entry point for blog publishing."""
    print("=" * 50)
    print("PUBLISH BLOG")
    print("=" * 50)

    # Get topic from args or generate from context
    if len(sys.argv) > 1:
        title = " ".join(sys.argv[1:])
    else:
        # Auto-generate from recent context
        commits = get_recent_commits(3)

        if commits:
            # Use most recent commit as title inspiration
            latest = commits[0].split(" ", 1)[-1] if commits else "Daily Update"
            title = f"Engineering Update: {latest[:40]}"
        else:
            title = f"Engineering Update: {datetime.now().strftime('%B %d, %Y')}"

        print(f"Auto-generated title: {title}")

    # Generate content
    content = generate_blog_content(
        title=title,
        challenge="This post documents recent engineering work on the AI trading system.",
        approach="We followed our established patterns using Claude Code for implementation.",
        tech_stack=[
            "Claude Opus 4.5 (AI reasoning)",
            "Python 3.11",
            "GitHub Actions (CI/CD)",
            "Alpaca API (trading)",
            "Vertex AI RAG (knowledge base)",
        ],
        results="The implementation was successful and is now deployed.",
        lessons="AI-assisted development accelerates iteration cycles significantly.",
    )

    # Save to GitHub Pages
    filepath = save_to_github_pages(title, content)

    # Publish to Dev.to
    devto_url = publish_to_devto(title, content, filepath)

    # Commit and push
    commit_hash = git_commit_and_push(filepath, title)

    # Summary
    print("\n" + "=" * 50)
    print("BLOG POST PUBLISHED")
    print("=" * 50)
    print(f"Title: {title}")
    print(f"GitHub Pages: {filepath}")
    if devto_url:
        print(f"Dev.to: {devto_url}")
    if commit_hash:
        print(f"Commit: {commit_hash}")
    print("=" * 50)

    return 0


if __name__ == "__main__":
    sys.exit(main())
