#!/bin/bash
# Pre-commit hook for repository hygiene
# Automatically organizes files and runs quality checks

echo "üßπ Running repository hygiene check..."

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Get repository root
REPO_ROOT=$(git rev-parse --show-toplevel)
cd "$REPO_ROOT"

# Run comprehensive hygiene orchestrator (coordinates all checks in parallel)
if [ -f ".claude/hooks/hygiene-orchestrator.sh" ]; then
    bash .claude/hooks/hygiene-orchestrator.sh || exit 1
fi

# Track if we made any changes
MADE_CHANGES=0

# Validate dependencies if requirements.txt changed
if git diff --cached --name-only | grep -q "requirements.txt"; then
    echo "üîç Validating dependencies (requirements.txt changed)..."
    python3 scripts/validate_dependencies.py || {
        echo -e "${RED}‚ùå Dependency validation failed!${NC}"
        echo "   Fix dependency conflicts before committing"
        exit 1
    }
fi

# Block unnecessary meta-documentation files
echo "üìã Checking for unnecessary meta-documentation..."
BLOCKED_PATTERNS=(
    "*AUDIT*.md"
    "*SUMMARY*.md"
    "*COMPLETE*.md"
    "*VERIFICATION*.md"
    "*STATUS*.md"
    "*REPORT*.md"
    "*FIX*.md"
    "*IMPLEMENTATION*.md"
)

BLOCKED_FILES=()
# Check all staged new files
while IFS= read -r file; do
    if [ ! -z "$file" ]; then
        # Skip allowed files
        if [[ "$file" =~ ^docs/status/ ]] || [[ "$file" == "README.md" ]] || [[ "$file" == "docs/README_COMPREHENSIVE.md" ]]; then
            continue
        fi
        
        # Check if filename matches blocked patterns
        filename=$(basename "$file")
        for pattern in "${BLOCKED_PATTERNS[@]}"; do
            pattern_regex=$(echo "$pattern" | sed 's/\*/\.\*/g')
            if [[ "$filename" =~ $pattern_regex ]]; then
                BLOCKED_FILES+=("$file")
                break
            fi
        done
    fi
done < <(git diff --cached --name-only --diff-filter=A | grep '\.md$' || true)

if [ ${#BLOCKED_FILES[@]} -gt 0 ]; then
    echo -e "${RED}‚ùå BLOCKED: Unnecessary meta-documentation detected${NC}"
    echo ""
    echo "The following files are meta-documentation and should NOT be created:"
    for file in "${BLOCKED_FILES[@]}"; do
        echo -e "  ${RED}‚ùå $file${NC}"
    done
    echo ""
    echo "RULE: Only create actionable documentation"
    echo "  ‚úÖ Guides (HOW TO do something)"
    echo "  ‚úÖ Architecture (HOW IT WORKS)"
    echo "  ‚úÖ Roadmaps (WHAT TO DO)"
    echo ""
    echo "  ‚ùå Audits, summaries, status reports"
    echo "  ‚ùå Documentation about documentation"
    echo "  ‚ùå Implementation details (put in code comments)"
    echo ""
    echo "To bypass this check, remove the files or rename them."
    exit 1
fi

# 1. Check for misplaced files in root
echo "üìÅ Checking for misplaced files in root directory..."

# Move test files to tests/
for file in test_*.py *_test.py; do
    if [ -f "$file" ] && [ "$file" != "tests/" ]; then
        echo "  ‚Üí Moving $file to tests/"
        git mv "$file" tests/ 2>/dev/null || mv "$file" tests/
        git add "tests/$file"
        MADE_CHANGES=1
    fi
done

# Move docs to docs/ (except README.md, LICENSE.md, and CLAUDE.md)
# CLAUDE.md must stay at root for automatic loading by Claude Code
for file in *.md; do
    if [ -f "$file" ] && [ "$file" != "README.md" ] && [ "$file" != "LICENSE.md" ] && [ "$file" != "CLAUDE.md" ]; then
        echo "  ‚Üí Moving $file to docs/"
        git mv "$file" docs/ 2>/dev/null || mv "$file" docs/
        git add "docs/$file"
        MADE_CHANGES=1
    fi
done

# Move JSON data files to data/
for file in *_data.json *_state.json; do
    if [ -f "$file" ]; then
        echo "  ‚Üí Moving $file to data/"
        git mv "$file" data/ 2>/dev/null || mv "$file" data/
        git add "data/$file"
        MADE_CHANGES=1
    fi
done

# 2. Check for large files
echo "üì¶ Checking for large files..."
LARGE_FILES=$(git diff --cached --name-only | xargs -I {} du -k {} 2>/dev/null | awk '$1 > 1024 {print $2}')
if [ ! -z "$LARGE_FILES" ]; then
    echo -e "${YELLOW}‚ö†Ô∏è  Warning: Large files detected (>1MB):${NC}"
    echo "$LARGE_FILES"
fi

# 3. Check for TODO/FIXME comments
echo "üìù Checking for TODO/FIXME comments..."
TODO_COUNT=$(git diff --cached | grep -c "TODO\|FIXME" || echo "0")
if [ "$TODO_COUNT" -gt 0 ]; then
    echo -e "${YELLOW}‚ö†Ô∏è  Found $TODO_COUNT TODO/FIXME comments${NC}"
fi

# 4. Check Python files for basic quality
echo "üêç Checking Python files..."
PYTHON_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.py$')
if [ ! -z "$PYTHON_FILES" ]; then
    for file in $PYTHON_FILES; do
        # Check for print statements (should use logging)
        if grep -q "print(" "$file" 2>/dev/null && ! grep -q "scripts/" <<< "$file"; then
            echo -e "${YELLOW}‚ö†Ô∏è  $file contains print() statements - consider using logging${NC}"
        fi
        
        # Check for import *
        if grep -q "from .* import \*" "$file" 2>/dev/null; then
            echo -e "${YELLOW}‚ö†Ô∏è  $file uses 'import *' - be more specific${NC}"
        fi
    done
fi

# 5. Security Scanning
echo "üîí Scanning for security issues..."
SECURITY_ISSUES=0

# Check Python files for security vulnerabilities
PYTHON_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.py$')
if [ ! -z "$PYTHON_FILES" ]; then
    for file in $PYTHON_FILES; do
        # Check for clear-text logging of API keys/secrets
        # Pattern 1: key[:20], key[:10] etc - exposing more than 4 chars (in f-strings or regular code)
        # Pattern 2: key[10:] - exposing end of key
        # Pattern 3: f-string with {api_key[:N]} where N > 4
        # Require use of mask_api_key() utility instead
        if grep -nE "(api_key|secret|token|password|bearer|api_secret|secret_key)\s*\[:([5-9]|[1-9][0-9]+)\]" "$file" 2>/dev/null ||
           grep -nE "(api_key|secret|token|password|bearer|api_secret|secret_key)\s*\[([5-9]|[1-9][0-9]+):\]" "$file" 2>/dev/null ||
           grep -nE "f[\"'].*\{[^}]*\b(api_key|secret|token|password|bearer|api_secret|secret_key)\s*\[:([5-9]|[1-9][0-9]+)\}" "$file" 2>/dev/null ||
           grep -nE "print\s*\([^)]*\{(api_key|secret|token|password|bearer|api_secret|secret_key)\[:" "$file" 2>/dev/null; then
            echo -e "${RED}‚ùå SECURITY: $file exposes too many characters of sensitive data${NC}"
            echo -e "${YELLOW}   Fix: Use mask_api_key() from src.utils.security${NC}"
            echo -e "${YELLOW}   Example: from src.utils.security import mask_api_key${NC}"
            echo -e "${YELLOW}            masked_key = mask_api_key(api_key)${NC}"
            echo -e "${YELLOW}            print(f'API key: {masked_key}')${NC}"
            SECURITY_ISSUES=$((SECURITY_ISSUES + 1))
        fi

        # Check for hardcoded secrets (common patterns)
        if grep -nE "(api_key|secret|token|password)\s*=\s*['\"][a-zA-Z0-9]{20,}" "$file" 2>/dev/null; then
            echo -e "${RED}‚ùå SECURITY: $file contains potential hardcoded secrets${NC}"
            echo -e "${YELLOW}   Fix: Use environment variables via os.getenv()${NC}"
            SECURITY_ISSUES=$((SECURITY_ISSUES + 1))
        fi

        # Check for SQL injection vulnerabilities
        if grep -nE "execute\(['\"].*\+.*['\"]" "$file" 2>/dev/null ||
           grep -nE "execute\(['\"].*%.*['\"].*%" "$file" 2>/dev/null; then
            echo -e "${YELLOW}‚ö†Ô∏è  SECURITY: $file may have SQL injection risk${NC}"
            echo -e "${YELLOW}   Review: Use parameterized queries${NC}"
        fi
    done
fi

# Check YAML workflow files for missing permissions
WORKFLOW_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.github/workflows/.*\.yml$')
if [ ! -z "$WORKFLOW_FILES" ]; then
    for file in $WORKFLOW_FILES; do
        if ! grep -q "^permissions:" "$file" 2>/dev/null; then
            echo -e "${YELLOW}‚ö†Ô∏è  SECURITY: $file missing explicit permissions${NC}"
            echo -e "${YELLOW}   Fix: Add 'permissions:' block (contents: read/write, issues: write, etc.)${NC}"
        fi
    done
fi

if [ $SECURITY_ISSUES -gt 0 ]; then
    echo -e "${RED}‚ùå Found $SECURITY_ISSUES critical security issues - commit blocked${NC}"
    exit 1
fi

# 6. Update README if new docs added
if git diff --cached --name-only | grep -q "^docs/.*\.md$"; then
    echo "üìÑ New documentation detected - consider updating README.md"
fi

# Summary
echo ""
if [ $MADE_CHANGES -eq 1 ]; then
    echo -e "${GREEN}‚úÖ Repository hygiene: Files organized${NC}"
    echo -e "${YELLOW}‚ö†Ô∏è  Files were moved - review changes before committing${NC}"
else
    echo -e "${GREEN}‚úÖ Repository hygiene: All clean${NC}"
fi

echo ""
exit 0

