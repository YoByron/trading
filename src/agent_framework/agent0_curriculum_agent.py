"""
Agent0 Curriculum Agent: Generates increasingly challenging trading tasks

The Curriculum Agent creates frontier tasks that push the Executor Agent's capabilities.
As the Executor Agent improves, the Curriculum Agent generates harder challenges,
creating a symbiotic co-evolution loop.

Inspired by: Agent0 paper (arXiv:2511.16043)
"""

from __future__ import annotations

import json
import logging
from dataclasses import dataclass, field, asdict
from datetime import datetime, timedelta
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple
from uuid import uuid4

logger = logging.getLogger(__name__)


class TaskDifficulty(Enum):
    """Task difficulty levels"""
    BEGINNER = "beginner"  # Basic tasks, low complexity
    INTERMEDIATE = "intermediate"  # Moderate complexity
    ADVANCED = "advanced"  # High complexity
    EXPERT = "expert"  # Maximum complexity, frontier tasks
    FRONTIER = "frontier"  # Beyond current capabilities


class TaskCategory(Enum):
    """Categories of trading tasks"""
    MARKET_ANALYSIS = "market_analysis"
    SIGNAL_GENERATION = "signal_generation"
    RISK_MANAGEMENT = "risk_management"
    PORTFOLIO_OPTIMIZATION = "portfolio_optimization"
    EXECUTION_STRATEGY = "execution_strategy"
    MULTI_ASSET = "multi_asset"
    REGIME_DETECTION = "regime_detection"
    SENTIMENT_INTEGRATION = "sentiment_integration"


@dataclass
class TradingTask:
    """A trading task generated by the Curriculum Agent"""
    task_id: str = field(default_factory=lambda: str(uuid4()))
    created_at: str = field(default_factory=lambda: datetime.now().isoformat())
    
    # Task definition
    category: TaskCategory = TaskCategory.MARKET_ANALYSIS
    difficulty: TaskDifficulty = TaskDifficulty.BEGINNER
    title: str = ""
    description: str = ""
    objectives: List[str] = field(default_factory=list)
    
    # Task parameters
    symbols: List[str] = field(default_factory=list)
    constraints: Dict[str, Any] = field(default_factory=dict)
    required_tools: List[str] = field(default_factory=list)
    evaluation_criteria: Dict[str, Any] = field(default_factory=dict)
    
    # Evolution tracking
    generation_iteration: int = 0
    parent_task_id: Optional[str] = None  # If this task evolved from another
    complexity_score: float = 0.0  # 0-1 scale
    
    # Execution tracking
    executed: bool = False
    execution_result: Optional[Dict[str, Any]] = None
    success_score: float = 0.0  # 0-1 scale
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization"""
        data = asdict(self)
        data["category"] = self.category.value
        data["difficulty"] = self.difficulty.value
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> TradingTask:
        """Create from dictionary"""
        data["category"] = TaskCategory(data["category"])
        data["difficulty"] = TaskDifficulty(data["difficulty"])
        return cls(**data)


@dataclass
class CurriculumState:
    """State tracking for curriculum evolution"""
    iteration: int = 0
    current_difficulty: TaskDifficulty = TaskDifficulty.BEGINNER
    executor_capability_score: float = 0.0  # 0-1 scale
    tasks_generated: int = 0
    tasks_completed: int = 0
    success_rate: float = 0.0
    last_evolution: Optional[str] = None
    
    # Difficulty progression tracking
    difficulty_history: List[Tuple[int, TaskDifficulty, float]] = field(default_factory=list)
    
    def evolve_difficulty(self, success_rate: float) -> TaskDifficulty:
        """
        Evolve difficulty based on executor performance
        
        Args:
            success_rate: Recent success rate (0-1)
            
        Returns:
            New difficulty level
        """
        self.success_rate = success_rate
        
        # If success rate is high, increase difficulty
        if success_rate >= 0.8 and self.current_difficulty != TaskDifficulty.FRONTIER:
            if self.current_difficulty == TaskDifficulty.BEGINNER:
                self.current_difficulty = TaskDifficulty.INTERMEDIATE
            elif self.current_difficulty == TaskDifficulty.INTERMEDIATE:
                self.current_difficulty = TaskDifficulty.ADVANCED
            elif self.current_difficulty == TaskDifficulty.ADVANCED:
                self.current_difficulty = TaskDifficulty.EXPERT
            elif self.current_difficulty == TaskDifficulty.EXPERT:
                self.current_difficulty = TaskDifficulty.FRONTIER
            
            self.last_evolution = datetime.now().isoformat()
            logger.info(f"ðŸ“ˆ Curriculum evolved: {self.current_difficulty.value} (success_rate={success_rate:.2f})")
        
        # If success rate is low, decrease difficulty
        elif success_rate < 0.5 and self.current_difficulty != TaskDifficulty.BEGINNER:
            if self.current_difficulty == TaskDifficulty.FRONTIER:
                self.current_difficulty = TaskDifficulty.EXPERT
            elif self.current_difficulty == TaskDifficulty.EXPERT:
                self.current_difficulty = TaskDifficulty.ADVANCED
            elif self.current_difficulty == TaskDifficulty.ADVANCED:
                self.current_difficulty = TaskDifficulty.INTERMEDIATE
            elif self.current_difficulty == TaskDifficulty.INTERMEDIATE:
                self.current_difficulty = TaskDifficulty.BEGINNER
            
            self.last_evolution = datetime.now().isoformat()
            logger.info(f"ðŸ“‰ Curriculum adjusted: {self.current_difficulty.value} (success_rate={success_rate:.2f})")
        
        # Record difficulty change
        self.difficulty_history.append((self.iteration, self.current_difficulty, success_rate))
        
        return self.current_difficulty


class CurriculumAgent:
    """
    Curriculum Agent: Generates increasingly challenging trading tasks
    
    Responsibilities:
    1. Analyze executor agent capabilities
    2. Generate tasks at appropriate difficulty level
    3. Evolve task complexity based on executor performance
    4. Create frontier tasks that push boundaries
    """
    
    def __init__(self, storage_dir: Optional[Path] = None):
        """
        Initialize Curriculum Agent
        
        Args:
            storage_dir: Directory for storing curriculum state and tasks
        """
        self.storage_dir = storage_dir or Path("data/agent_context/curriculum")
        self.storage_dir.mkdir(parents=True, exist_ok=True)
        
        # Load curriculum state
        self.state = self._load_state()
        
        # Task templates by category and difficulty
        self.task_templates = self._initialize_templates()
        
        logger.info(f"âœ… Curriculum Agent initialized (iteration={self.state.iteration}, difficulty={self.state.current_difficulty.value})")
    
    def generate_task(
        self,
        executor_capability: Optional[float] = None,
        category: Optional[TaskCategory] = None,
        symbols: Optional[List[str]] = None
    ) -> TradingTask:
        """
        Generate a new trading task at appropriate difficulty level
        
        Args:
            executor_capability: Current executor capability score (0-1)
            category: Specific task category (optional)
            symbols: Specific symbols to use (optional)
            
        Returns:
            Generated TradingTask
        """
        self.state.iteration += 1
        
        # Update executor capability if provided
        if executor_capability is not None:
            self.state.executor_capability_score = executor_capability
        
        # Evolve difficulty based on recent performance
        if self.state.tasks_completed > 0:
            recent_success_rate = self._calculate_recent_success_rate()
            self.state.evolve_difficulty(recent_success_rate)
        
        # Select category
        if category is None:
            category = self._select_category()
        
        # Select difficulty (may be adjusted based on capability)
        difficulty = self._adjust_difficulty(self.state.current_difficulty, executor_capability)
        
        # Generate task using template
        task = self._create_task_from_template(category, difficulty, symbols)
        
        # Save task
        self._save_task(task)
        self._save_state()
        
        self.state.tasks_generated += 1
        logger.info(f"ðŸ“‹ Generated task: {task.title} ({difficulty.value}, {category.value})")
        
        return task
    
    def record_execution_result(self, task_id: str, result: Dict[str, Any], success_score: float):
        """
        Record execution result for a task
        
        Args:
            task_id: Task identifier
            result: Execution result dictionary
            success_score: Success score (0-1)
        """
        task = self._load_task(task_id)
        if task:
            task.executed = True
            task.execution_result = result
            task.success_score = success_score
            self._save_task(task)
            
            self.state.tasks_completed += 1
            self._save_state()
            
            logger.info(f"âœ… Task {task_id} completed (success_score={success_score:.2f})")
    
    def _create_task_from_template(
        self,
        category: TaskCategory,
        difficulty: TaskDifficulty,
        symbols: Optional[List[str]] = None
    ) -> TradingTask:
        """Create a task from template based on category and difficulty"""
        template_key = f"{category.value}_{difficulty.value}"
        
        if template_key not in self.task_templates:
            # Fallback to generic template
            template_key = f"market_analysis_{difficulty.value}"
        
        template = self.task_templates[template_key]
        
        # Select symbols if not provided
        if not symbols:
            symbols = self._select_symbols(category, difficulty)
        
        # Calculate complexity score
        complexity_score = self._calculate_complexity(category, difficulty)
        
        # Create task
        task = TradingTask(
            category=category,
            difficulty=difficulty,
            title=template["title"].format(symbols=", ".join(symbols)),
            description=template["description"].format(symbols=", ".join(symbols)),
            objectives=template["objectives"],
            symbols=symbols,
            constraints=template.get("constraints", {}),
            required_tools=template.get("required_tools", []),
            evaluation_criteria=template.get("evaluation_criteria", {}),
            generation_iteration=self.state.iteration,
            complexity_score=complexity_score
        )
        
        return task
    
    def _initialize_templates(self) -> Dict[str, Dict[str, Any]]:
        """Initialize task templates for different categories and difficulties"""
        templates = {}
        
        # Market Analysis Tasks
        templates["market_analysis_beginner"] = {
            "title": "Analyze market conditions for {symbols}",
            "description": "Perform basic market analysis for the given symbols. Identify current market regime (bullish/bearish/range-bound) and key technical indicators.",
            "objectives": [
                "Identify market regime",
                "Calculate key technical indicators (RSI, MACD)",
                "Provide basic market assessment"
            ],
            "required_tools": ["get_market_data", "analyze_technical_indicators"],
            "evaluation_criteria": {
                "regime_accuracy": 0.3,
                "indicator_calculation": 0.3,
                "reasoning_quality": 0.4
            }
        }
        
        templates["market_analysis_intermediate"] = {
            "title": "Multi-timeframe analysis for {symbols}",
            "description": "Perform comprehensive multi-timeframe analysis. Compare daily, hourly, and 15-minute charts. Identify divergences and key support/resistance levels.",
            "objectives": [
                "Multi-timeframe analysis",
                "Identify support/resistance levels",
                "Detect divergences",
                "Assess trend strength"
            ],
            "required_tools": ["get_market_data", "analyze_technical_indicators"],
            "evaluation_criteria": {
                "multi_timeframe_coherence": 0.3,
                "support_resistance_accuracy": 0.3,
                "divergence_detection": 0.2,
                "reasoning_quality": 0.2
            }
        }
        
        templates["market_analysis_advanced"] = {
            "title": "Regime detection and transition prediction for {symbols}",
            "description": "Detect current market regime and predict potential regime transitions. Analyze volatility clustering, correlation shifts, and structural breaks.",
            "objectives": [
                "Detect current regime",
                "Identify regime transition signals",
                "Assess transition probability",
                "Provide risk-adjusted recommendations"
            ],
            "required_tools": ["get_market_data", "analyze_technical_indicators", "query_sentiment"],
            "evaluation_criteria": {
                "regime_detection_accuracy": 0.3,
                "transition_prediction": 0.3,
                "risk_assessment": 0.2,
                "reasoning_depth": 0.2
            }
        }
        
        templates["market_analysis_expert"] = {
            "title": "Multi-asset correlation and regime analysis for {symbols}",
            "description": "Analyze cross-asset correlations, sector rotations, and macro regime shifts. Integrate multiple data sources including sentiment, options flow, and fundamentals.",
            "objectives": [
                "Cross-asset correlation analysis",
                "Sector rotation detection",
                "Macro regime identification",
                "Multi-source data integration",
                "Forward-looking regime prediction"
            ],
            "required_tools": ["get_market_data", "analyze_technical_indicators", "query_sentiment", "call_mcp_tool"],
            "evaluation_criteria": {
                "correlation_analysis": 0.25,
                "regime_prediction": 0.25,
                "data_integration": 0.25,
                "reasoning_sophistication": 0.25
            }
        }
        
        templates["market_analysis_frontier"] = {
            "title": "Frontier: Real-time adaptive strategy for {symbols} under regime uncertainty",
            "description": "Develop an adaptive trading strategy that dynamically adjusts to regime uncertainty. Must handle multiple concurrent regimes, non-stationary market dynamics, and integrate real-time data streams.",
            "objectives": [
                "Handle regime uncertainty",
                "Adaptive strategy design",
                "Real-time data integration",
                "Non-stationary dynamics handling",
                "Multi-objective optimization"
            ],
            "required_tools": ["get_market_data", "analyze_technical_indicators", "query_sentiment", "call_mcp_tool"],
            "evaluation_criteria": {
                "adaptability": 0.3,
                "uncertainty_handling": 0.3,
                "real_time_performance": 0.2,
                "innovation": 0.2
            }
        }
        
        # Signal Generation Tasks
        templates["signal_generation_beginner"] = {
            "title": "Generate basic trading signal for {symbols}",
            "description": "Generate a simple trading signal (BUY/SELL/HOLD) based on basic technical indicators.",
            "objectives": [
                "Calculate basic indicators",
                "Generate clear signal",
                "Provide entry/exit levels"
            ],
            "required_tools": ["get_market_data", "analyze_technical_indicators"],
            "evaluation_criteria": {
                "signal_clarity": 0.4,
                "indicator_usage": 0.3,
                "entry_exit_quality": 0.3
            }
        }
        
        templates["signal_generation_intermediate"] = {
            "title": "Multi-factor signal generation for {symbols}",
            "description": "Generate trading signals using multiple factors: technical, sentiment, and volume analysis. Provide confidence scores.",
            "objectives": [
                "Multi-factor analysis",
                "Confidence scoring",
                "Risk-adjusted signals"
            ],
            "required_tools": ["get_market_data", "analyze_technical_indicators", "query_sentiment"],
            "evaluation_criteria": {
                "factor_integration": 0.3,
                "confidence_calibration": 0.3,
                "signal_quality": 0.4
            }
        }
        
        templates["signal_generation_advanced"] = {
            "title": "Adaptive signal generation with regime awareness for {symbols}",
            "description": "Generate signals that adapt to current market regime. Different strategies for trending vs. ranging markets.",
            "objectives": [
                "Regime-aware signals",
                "Adaptive strategy selection",
                "Dynamic parameter adjustment"
            ],
            "required_tools": ["get_market_data", "analyze_technical_indicators", "query_sentiment"],
            "evaluation_criteria": {
                "regime_adaptation": 0.35,
                "strategy_selection": 0.3,
                "signal_performance": 0.35
            }
        }
        
        templates["signal_generation_expert"] = {
            "title": "Multi-timeframe signal fusion for {symbols}",
            "description": "Generate signals by fusing multiple timeframes. Resolve conflicts between timeframes and provide unified signal.",
            "objectives": [
                "Multi-timeframe analysis",
                "Signal fusion",
                "Conflict resolution",
                "Unified signal generation"
            ],
            "required_tools": ["get_market_data", "analyze_technical_indicators", "query_sentiment"],
            "evaluation_criteria": {
                "timeframe_fusion": 0.3,
                "conflict_resolution": 0.3,
                "signal_coherence": 0.4
            }
        }
        
        templates["signal_generation_frontier"] = {
            "title": "Frontier: Real-time signal generation with uncertainty quantification for {symbols}",
            "description": "Generate signals with explicit uncertainty quantification. Handle model uncertainty, data uncertainty, and regime uncertainty simultaneously.",
            "objectives": [
                "Uncertainty quantification",
                "Real-time signal generation",
                "Multi-uncertainty handling",
                "Bayesian reasoning"
            ],
            "required_tools": ["get_market_data", "analyze_technical_indicators", "query_sentiment", "call_mcp_tool"],
            "evaluation_criteria": {
                "uncertainty_quantification": 0.35,
                "real_time_performance": 0.25,
                "reasoning_sophistication": 0.4
            }
        }
        
        # Risk Management Tasks
        templates["risk_management_beginner"] = {
            "title": "Basic position sizing for {symbols}",
            "description": "Calculate appropriate position sizes based on account balance and basic risk parameters.",
            "objectives": [
                "Calculate position size",
                "Apply risk limits",
                "Consider account balance"
            ],
            "required_tools": ["call_mcp_tool"],
            "evaluation_criteria": {
                "position_size_accuracy": 0.5,
                "risk_limit_compliance": 0.5
            }
        }
        
        templates["risk_management_intermediate"] = {
            "title": "Volatility-adjusted position sizing for {symbols}",
            "description": "Calculate position sizes adjusted for asset volatility. Use ATR or historical volatility.",
            "objectives": [
                "Volatility calculation",
                "Volatility-adjusted sizing",
                "Risk parity principles"
            ],
            "required_tools": ["get_market_data", "call_mcp_tool"],
            "evaluation_criteria": {
                "volatility_estimation": 0.3,
                "sizing_adjustment": 0.4,
                "risk_parity": 0.3
            }
        }
        
        templates["risk_management_advanced"] = {
            "title": "Portfolio risk assessment and optimization for {symbols}",
            "description": "Assess portfolio-level risk including correlations, concentration, and tail risk. Optimize position sizes.",
            "objectives": [
                "Portfolio risk calculation",
                "Correlation analysis",
                "Concentration risk",
                "Position optimization"
            ],
            "required_tools": ["get_market_data", "call_mcp_tool"],
            "evaluation_criteria": {
                "risk_calculation": 0.3,
                "correlation_analysis": 0.3,
                "optimization_quality": 0.4
            }
        }
        
        templates["risk_management_expert"] = {
            "title": "Dynamic risk management with regime adaptation for {symbols}",
            "description": "Implement dynamic risk management that adapts to changing market regimes. Adjust risk parameters based on volatility regimes.",
            "objectives": [
                "Regime detection",
                "Dynamic risk adjustment",
                "Volatility regime adaptation",
                "Tail risk management"
            ],
            "required_tools": ["get_market_data", "call_mcp_tool"],
            "evaluation_criteria": {
                "regime_adaptation": 0.3,
                "dynamic_adjustment": 0.35,
                "tail_risk": 0.35
            }
        }
        
        templates["risk_management_frontier"] = {
            "title": "Frontier: Real-time risk management with uncertainty propagation for {symbols}",
            "description": "Implement risk management that propagates uncertainty through all calculations. Handle model risk, parameter uncertainty, and regime uncertainty.",
            "objectives": [
                "Uncertainty propagation",
                "Model risk quantification",
                "Real-time risk monitoring",
                "Adaptive risk limits"
            ],
            "required_tools": ["get_market_data", "call_mcp_tool"],
            "evaluation_criteria": {
                "uncertainty_propagation": 0.35,
                "model_risk": 0.3,
                "real_time_monitoring": 0.35
            }
        }
        
        return templates
    
    def _select_category(self) -> TaskCategory:
        """Select a task category based on current state"""
        # Rotate through categories to ensure diversity
        categories = list(TaskCategory)
        category_index = self.state.iteration % len(categories)
        return categories[category_index]
    
    def _select_symbols(self, category: TaskCategory, difficulty: TaskDifficulty) -> List[str]:
        """Select appropriate symbols for the task"""
        # Default symbols
        base_symbols = ["SPY", "QQQ", "VOO"]
        
        # For advanced/expert tasks, use more symbols
        if difficulty in [TaskDifficulty.ADVANCED, TaskDifficulty.EXPERT, TaskDifficulty.FRONTIER]:
            return base_symbols + ["AAPL", "MSFT", "TSLA"]
        
        # For beginner/intermediate, use fewer symbols
        return base_symbols[:2]
    
    def _adjust_difficulty(
        self,
        base_difficulty: TaskDifficulty,
        executor_capability: Optional[float]
    ) -> TaskDifficulty:
        """Adjust difficulty based on executor capability"""
        if executor_capability is None:
            return base_difficulty
        
        # If executor capability is very high, push to harder difficulty
        if executor_capability > 0.8 and base_difficulty != TaskDifficulty.FRONTIER:
            difficulty_map = {
                TaskDifficulty.BEGINNER: TaskDifficulty.INTERMEDIATE,
                TaskDifficulty.INTERMEDIATE: TaskDifficulty.ADVANCED,
                TaskDifficulty.ADVANCED: TaskDifficulty.EXPERT,
                TaskDifficulty.EXPERT: TaskDifficulty.FRONTIER
            }
            return difficulty_map.get(base_difficulty, base_difficulty)
        
        # If executor capability is very low, use easier difficulty
        if executor_capability < 0.3 and base_difficulty != TaskDifficulty.BEGINNER:
            difficulty_map = {
                TaskDifficulty.FRONTIER: TaskDifficulty.EXPERT,
                TaskDifficulty.EXPERT: TaskDifficulty.ADVANCED,
                TaskDifficulty.ADVANCED: TaskDifficulty.INTERMEDIATE,
                TaskDifficulty.INTERMEDIATE: TaskDifficulty.BEGINNER
            }
            return difficulty_map.get(base_difficulty, base_difficulty)
        
        return base_difficulty
    
    def _calculate_complexity(self, category: TaskCategory, difficulty: TaskDifficulty) -> float:
        """Calculate complexity score (0-1)"""
        difficulty_scores = {
            TaskDifficulty.BEGINNER: 0.2,
            TaskDifficulty.INTERMEDIATE: 0.4,
            TaskDifficulty.ADVANCED: 0.6,
            TaskDifficulty.EXPERT: 0.8,
            TaskDifficulty.FRONTIER: 1.0
        }
        
        category_multipliers = {
            TaskCategory.MARKET_ANALYSIS: 1.0,
            TaskCategory.SIGNAL_GENERATION: 1.1,
            TaskCategory.RISK_MANAGEMENT: 1.2,
            TaskCategory.PORTFOLIO_OPTIMIZATION: 1.3,
            TaskCategory.EXECUTION_STRATEGY: 1.1,
            TaskCategory.MULTI_ASSET: 1.4,
            TaskCategory.REGIME_DETECTION: 1.2,
            TaskCategory.SENTIMENT_INTEGRATION: 1.1
        }
        
        base_score = difficulty_scores.get(difficulty, 0.5)
        multiplier = category_multipliers.get(category, 1.0)
        
        return min(1.0, base_score * multiplier)
    
    def _calculate_recent_success_rate(self, window: int = 10) -> float:
        """Calculate recent success rate from completed tasks"""
        tasks_dir = self.storage_dir / "tasks"
        if not tasks_dir.exists():
            return 0.5  # Default to medium success rate
        
        # Load recent tasks
        task_files = sorted(tasks_dir.glob("*.json"), key=lambda p: p.stat().st_mtime, reverse=True)
        recent_tasks = []
        
        for task_file in task_files[:window]:
            try:
                with open(task_file, "r") as f:
                    task_data = json.load(f)
                    task = TradingTask.from_dict(task_data)
                    if task.executed:
                        recent_tasks.append(task)
            except Exception as e:
                logger.warning(f"Failed to load task {task_file}: {e}")
        
        if not recent_tasks:
            return 0.5
        
        # Calculate average success score
        avg_success = sum(task.success_score for task in recent_tasks) / len(recent_tasks)
        return avg_success
    
    def _save_task(self, task: TradingTask):
        """Save task to disk"""
        tasks_dir = self.storage_dir / "tasks"
        tasks_dir.mkdir(parents=True, exist_ok=True)
        
        task_file = tasks_dir / f"{task.task_id}.json"
        with open(task_file, "w") as f:
            json.dump(task.to_dict(), f, indent=2)
    
    def _load_task(self, task_id: str) -> Optional[TradingTask]:
        """Load task from disk"""
        task_file = self.storage_dir / "tasks" / f"{task_id}.json"
        if not task_file.exists():
            return None
        
        try:
            with open(task_file, "r") as f:
                data = json.load(f)
                return TradingTask.from_dict(data)
        except Exception as e:
            logger.error(f"Failed to load task {task_id}: {e}")
            return None
    
    def _save_state(self):
        """Save curriculum state to disk"""
        state_file = self.storage_dir / "curriculum_state.json"
        
        state_dict = asdict(self.state)
        # Convert difficulty history tuples
        state_dict["difficulty_history"] = [
            {"iteration": i, "difficulty": d.value, "success_rate": s}
            for i, d, s in self.state.difficulty_history
        ]
        state_dict["current_difficulty"] = self.state.current_difficulty.value
        
        with open(state_file, "w") as f:
            json.dump(state_dict, f, indent=2)
    
    def _load_state(self) -> CurriculumState:
        """Load curriculum state from disk"""
        state_file = self.storage_dir / "curriculum_state.json"
        
        if not state_file.exists():
            return CurriculumState()
        
        try:
            with open(state_file, "r") as f:
                data = json.load(f)
            
            # Convert difficulty back to enum
            data["current_difficulty"] = TaskDifficulty(data["current_difficulty"])
            
            # Convert difficulty history
            difficulty_history = []
            for entry in data.get("difficulty_history", []):
                difficulty_history.append((
                    entry["iteration"],
                    TaskDifficulty(entry["difficulty"]),
                    entry["success_rate"]
                ))
            data["difficulty_history"] = difficulty_history
            
            return CurriculumState(**data)
        except Exception as e:
            logger.warning(f"Failed to load curriculum state: {e}")
            return CurriculumState()
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get curriculum statistics"""
        return {
            "iteration": self.state.iteration,
            "current_difficulty": self.state.current_difficulty.value,
            "executor_capability": self.state.executor_capability_score,
            "tasks_generated": self.state.tasks_generated,
            "tasks_completed": self.state.tasks_completed,
            "success_rate": self.state.success_rate,
            "last_evolution": self.state.last_evolution,
            "difficulty_history": [
                {"iteration": i, "difficulty": d.value, "success_rate": s}
                for i, d, s in self.state.difficulty_history[-10:]
            ]
        }

