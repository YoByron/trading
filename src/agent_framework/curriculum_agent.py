"""
Curriculum Agent: Generates increasingly challenging trading tasks

Inspired by Agent0's Curriculum Agent pattern:
- Analyzes current system capabilities
- Generates frontier tasks that push boundaries
- Adapts difficulty based on executor performance
- Creates tasks that require tool-integrated reasoning
"""

from __future__ import annotations

import json
import logging
from dataclasses import dataclass, field, asdict
from datetime import datetime, timedelta
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Set
from uuid import uuid4

from .base import TradingAgent, AgentResult
from .context import RunContext

logger = logging.getLogger(__name__)


class TaskDifficulty(Enum):
    """Task difficulty levels"""

    EASY = "easy"  # Basic tasks within current capabilities
    MEDIUM = "medium"  # Slightly challenging
    HARD = "hard"  # Pushes boundaries
    FRONTIER = "frontier"  # Beyond current capabilities - learning opportunity


class TaskCategory(Enum):
    """Categories of trading tasks"""

    MARKET_ANALYSIS = "market_analysis"  # Complex market condition analysis
    RISK_MANAGEMENT = "risk_management"  # Advanced risk scenarios
    EXECUTION_OPTIMIZATION = "execution_optimization"  # Optimal execution strategies
    PORTFOLIO_OPTIMIZATION = "portfolio_optimization"  # Multi-asset optimization
    REGIME_DETECTION = "regime_detection"  # Market regime identification
    SENTIMENT_INTEGRATION = "sentiment_integration"  # Multi-source sentiment fusion
    MULTI_TIMEFRAME = "multi_timeframe"  # Cross-timeframe analysis
    EDGE_CASE = "edge_case"  # Unusual market conditions


@dataclass
class TradingTask:
    """
    A trading task generated by the Curriculum Agent.

    Tasks are designed to challenge the Executor Agent and push
    the boundaries of system capabilities.
    """

    task_id: str = field(default_factory=lambda: str(uuid4()))
    created_at: str = field(default_factory=lambda: datetime.now().isoformat())
    difficulty: TaskDifficulty = TaskDifficulty.MEDIUM
    category: TaskCategory = TaskCategory.MARKET_ANALYSIS
    description: str = ""
    objectives: List[str] = field(default_factory=list)
    constraints: Dict[str, Any] = field(default_factory=dict)
    required_tools: List[str] = field(default_factory=list)
    expected_capabilities: List[str] = field(default_factory=list)
    context: Dict[str, Any] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for storage"""
        return {
            "task_id": self.task_id,
            "created_at": self.created_at,
            "difficulty": self.difficulty.value,
            "category": self.category.value,
            "description": self.description,
            "objectives": self.objectives,
            "constraints": self.constraints,
            "required_tools": self.required_tools,
            "expected_capabilities": self.expected_capabilities,
            "context": self.context,
            "metadata": self.metadata,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> TradingTask:
        """Create from dictionary"""
        return cls(
            task_id=data["task_id"],
            created_at=data["created_at"],
            difficulty=TaskDifficulty(data["difficulty"]),
            category=TaskCategory(data["category"]),
            description=data["description"],
            objectives=data.get("objectives", []),
            constraints=data.get("constraints", {}),
            required_tools=data.get("required_tools", []),
            expected_capabilities=data.get("expected_capabilities", []),
            context=data.get("context", {}),
            metadata=data.get("metadata", {}),
        )


@dataclass
class TaskPerformance:
    """Performance metrics for a completed task"""

    task_id: str
    executor_agent: str
    success: bool
    completion_time_seconds: float
    quality_score: float  # 0.0 to 1.0
    tool_usage: Dict[str, int] = field(default_factory=dict)
    errors: List[str] = field(default_factory=list)
    feedback: str = ""
    completed_at: str = field(default_factory=lambda: datetime.now().isoformat())


class CurriculumAgent(TradingAgent):
    """
    Curriculum Agent: Generates increasingly challenging trading tasks.

    Key Responsibilities:
    1. Analyze current system capabilities
    2. Generate frontier tasks that push boundaries
    3. Adapt difficulty based on executor performance
    4. Create tasks requiring tool-integrated reasoning
    """

    def __init__(self, storage_dir: Optional[Path] = None):
        super().__init__("CurriculumAgent")
        self.storage_dir = storage_dir or Path("data/agent_context/curriculum")
        self.storage_dir.mkdir(parents=True, exist_ok=True)

        # Task history
        self.generated_tasks: Dict[str, TradingTask] = {}
        self.task_performances: List[TaskPerformance] = []

        # Capability tracking
        self.current_capabilities: Set[str] = set()
        self.successful_difficulties: Dict[TaskDifficulty, int] = {
            diff: 0 for diff in TaskDifficulty
        }

        # Load history
        self._load_history()

        logger.info(
            f"âœ… Curriculum Agent initialized: {len(self.generated_tasks)} tasks in history"
        )

    def execute(self, context: RunContext) -> AgentResult:
        """
        Generate a new challenging trading task.

        Args:
            context: Current run context with market data, portfolio state, etc.

        Returns:
            AgentResult with generated task
        """
        try:
            # Analyze current capabilities
            capabilities = self._analyze_capabilities(context)

            # Determine target difficulty
            target_difficulty = self._determine_target_difficulty()

            # Generate task
            task = self._generate_task(
                context=context, difficulty=target_difficulty, capabilities=capabilities
            )

            # Store task
            self.generated_tasks[task.task_id] = task
            self._save_task(task)

            logger.info(
                f"ðŸ“š Generated task: {task.task_id} ({target_difficulty.value})"
            )
            logger.info(f"   Category: {task.category.value}")
            logger.info(f"   Objectives: {len(task.objectives)}")

            return AgentResult(
                name=self.agent_name,
                succeeded=True,
                payload={
                    "task": task.to_dict(),
                    "capabilities_analyzed": list(capabilities),
                    "target_difficulty": target_difficulty.value,
                },
            )

        except Exception as e:
            logger.exception(f"âŒ Curriculum Agent failed: {e}")
            return AgentResult(name=self.agent_name, succeeded=False, error=str(e))

    def _analyze_capabilities(self, context: RunContext) -> Set[str]:
        """
        Analyze current system capabilities based on:
        - Recent task performances
        - Available tools
        - Market conditions
        """
        capabilities = set()

        # Analyze recent successes
        recent_performances = [
            p for p in self.task_performances if p.success and p.quality_score > 0.7
        ][
            -10:
        ]  # Last 10 successful tasks

        for perf in recent_performances:
            if perf.task_id in self.generated_tasks:
                task = self.generated_tasks[perf.task_id]
                capabilities.update(task.expected_capabilities)
                capabilities.update(task.required_tools)

        # Add baseline capabilities
        capabilities.update(
            [
                "market_data_fetching",
                "technical_analysis",
                "risk_calculation",
                "order_execution",
            ]
        )

        return capabilities

    def _determine_target_difficulty(self) -> TaskDifficulty:
        """
        Determine target difficulty based on recent performance.

        Strategy:
        - If consistently succeeding at current level, increase difficulty
        - If failing, decrease difficulty
        - Always generate some frontier tasks for exploration
        """
        if not self.task_performances:
            return TaskDifficulty.MEDIUM

        recent_performances = self.task_performances[-20:]  # Last 20 tasks

        if not recent_performances:
            return TaskDifficulty.MEDIUM

        # Calculate success rate by difficulty
        success_by_difficulty: Dict[TaskDifficulty, List[bool]] = {
            diff: [] for diff in TaskDifficulty
        }

        for perf in recent_performances:
            if perf.task_id in self.generated_tasks:
                task = self.generated_tasks[perf.task_id]
                success_by_difficulty[task.difficulty].append(perf.success)

        # Determine next difficulty
        for difficulty in [
            TaskDifficulty.FRONTIER,
            TaskDifficulty.HARD,
            TaskDifficulty.MEDIUM,
            TaskDifficulty.EASY,
        ]:
            successes = success_by_difficulty.get(difficulty, [])
            if not successes:
                continue

            success_rate = sum(successes) / len(successes)

            # If success rate > 70%, we can try harder
            if success_rate > 0.7:
                if difficulty == TaskDifficulty.EASY:
                    return TaskDifficulty.MEDIUM
                elif difficulty == TaskDifficulty.MEDIUM:
                    return TaskDifficulty.HARD
                elif difficulty == TaskDifficulty.HARD:
                    return TaskDifficulty.FRONTIER
                else:  # Already at frontier
                    return TaskDifficulty.FRONTIER

        # Default: try medium difficulty
        return TaskDifficulty.MEDIUM

    def _generate_task(
        self, context: RunContext, difficulty: TaskDifficulty, capabilities: Set[str]
    ) -> TradingTask:
        """
        Generate a specific trading task.

        Tasks are designed to:
        1. Require tool-integrated reasoning
        2. Push current capabilities
        3. Be solvable but challenging
        """
        # Select category based on difficulty and capabilities
        category = self._select_category(difficulty, capabilities)

        # Generate task based on category
        if category == TaskCategory.MARKET_ANALYSIS:
            return self._generate_market_analysis_task(difficulty, context)
        elif category == TaskCategory.RISK_MANAGEMENT:
            return self._generate_risk_management_task(difficulty, context)
        elif category == TaskCategory.EXECUTION_OPTIMIZATION:
            return self._generate_execution_optimization_task(difficulty, context)
        elif category == TaskCategory.PORTFOLIO_OPTIMIZATION:
            return self._generate_portfolio_optimization_task(difficulty, context)
        elif category == TaskCategory.REGIME_DETECTION:
            return self._generate_regime_detection_task(difficulty, context)
        elif category == TaskCategory.SENTIMENT_INTEGRATION:
            return self._generate_sentiment_integration_task(difficulty, context)
        elif category == TaskCategory.MULTI_TIMEFRAME:
            return self._generate_multi_timeframe_task(difficulty, context)
        else:  # EDGE_CASE
            return self._generate_edge_case_task(difficulty, context)

    def _select_category(
        self, difficulty: TaskDifficulty, capabilities: Set[str]
    ) -> TaskCategory:
        """Select task category based on difficulty and capabilities"""
        # For frontier tasks, prefer complex categories
        if difficulty == TaskDifficulty.FRONTIER:
            categories = [
                TaskCategory.PORTFOLIO_OPTIMIZATION,
                TaskCategory.MULTI_TIMEFRAME,
                TaskCategory.SENTIMENT_INTEGRATION,
            ]
        elif difficulty == TaskDifficulty.HARD:
            categories = [
                TaskCategory.RISK_MANAGEMENT,
                TaskCategory.EXECUTION_OPTIMIZATION,
                TaskCategory.REGIME_DETECTION,
            ]
        else:
            categories = [TaskCategory.MARKET_ANALYSIS, TaskCategory.RISK_MANAGEMENT]

        # Select category that requires capabilities we have
        import random

        return random.choice(categories)

    def _generate_market_analysis_task(
        self, difficulty: TaskDifficulty, context: RunContext
    ) -> TradingTask:
        """Generate market analysis task"""
        if difficulty == TaskDifficulty.FRONTIER:
            description = (
                "Analyze multi-asset correlation patterns across SPY, QQQ, VOO, and sector ETFs "
                "during volatile market conditions. Identify regime shifts and generate trading "
                "signals that account for cross-asset dynamics and regime transitions."
            )
            objectives = [
                "Calculate correlation matrix across 10+ assets",
                "Detect regime shifts using statistical methods",
                "Generate signals that account for correlations",
                "Validate signals against historical regime transitions",
            ]
            required_tools = [
                "market_data",
                "statistical_analysis",
                "correlation_calculator",
            ]
        elif difficulty == TaskDifficulty.HARD:
            description = (
                "Perform comprehensive technical analysis combining MACD, RSI, Bollinger Bands, "
                "and volume analysis across multiple timeframes (1h, 4h, daily) to identify "
                "high-probability entry points."
            )
            objectives = [
                "Calculate indicators across 3 timeframes",
                "Identify confluence zones",
                "Generate entry signals with confidence scores",
            ]
            required_tools = ["market_data", "technical_indicators", "multi_timeframe"]
        else:  # MEDIUM/EASY
            description = (
                "Analyze current market conditions for SPY using technical indicators (MACD, RSI) "
                "and generate a trading signal with rationale."
            )
            objectives = [
                "Fetch current market data",
                "Calculate MACD and RSI",
                "Generate BUY/SELL/HOLD signal",
            ]
            required_tools = ["market_data", "technical_indicators"]

        return TradingTask(
            difficulty=difficulty,
            category=TaskCategory.MARKET_ANALYSIS,
            description=description,
            objectives=objectives,
            required_tools=required_tools,
            expected_capabilities=["market_analysis", "signal_generation"],
            context={"symbols": ["SPY", "QQQ", "VOO"]},
        )

    def _generate_risk_management_task(
        self, difficulty: TaskDifficulty, context: RunContext
    ) -> TradingTask:
        """Generate risk management task"""
        if difficulty == TaskDifficulty.FRONTIER:
            description = (
                "Design a dynamic risk management system that adjusts position sizes based on "
                "real-time volatility, correlation with existing positions, and portfolio-level "
                "risk metrics. Account for tail risk and implement stress testing."
            )
            objectives = [
                "Calculate portfolio-level risk metrics",
                "Adjust position sizes dynamically",
                "Implement correlation-based risk limits",
                "Perform stress testing scenarios",
            ]
            required_tools = ["risk_calculator", "portfolio_analyzer", "stress_tester"]
        elif difficulty == TaskDifficulty.HARD:
            description = (
                "Calculate optimal position sizes using Kelly Criterion and volatility-adjusted "
                "sizing for a portfolio with 5 positions, ensuring total portfolio risk stays "
                "within 2% daily loss limit."
            )
            objectives = [
                "Calculate Kelly Criterion for each position",
                "Adjust for volatility",
                "Ensure portfolio-level risk limits",
            ]
            required_tools = ["risk_calculator", "position_sizer"]
        else:
            description = (
                "Calculate appropriate position size for a $100 trade with 5% stop-loss, "
                "ensuring risk per trade is limited to 1% of portfolio."
            )
            objectives = ["Calculate position size", "Validate against risk limits"]
            required_tools = ["risk_calculator"]

        return TradingTask(
            difficulty=difficulty,
            category=TaskCategory.RISK_MANAGEMENT,
            description=description,
            objectives=objectives,
            required_tools=required_tools,
            expected_capabilities=["risk_management", "position_sizing"],
        )

    def _generate_execution_optimization_task(
        self, difficulty: TaskDifficulty, context: RunContext
    ) -> TradingTask:
        """Generate execution optimization task"""
        description = (
            "Optimize order execution timing and method (market vs limit) based on "
            "current spread, volume profile, and time-of-day patterns to minimize slippage."
        )
        objectives = [
            "Analyze current spread and volume",
            "Determine optimal execution method",
            "Calculate expected slippage",
            "Execute with optimal timing",
        ]
        required_tools = ["market_data", "execution_analyzer", "slippage_calculator"]

        return TradingTask(
            difficulty=difficulty,
            category=TaskCategory.EXECUTION_OPTIMIZATION,
            description=description,
            objectives=objectives,
            required_tools=required_tools,
            expected_capabilities=["execution_optimization"],
        )

    def _generate_portfolio_optimization_task(
        self, difficulty: TaskDifficulty, context: RunContext
    ) -> TradingTask:
        """Generate portfolio optimization task"""
        description = (
            "Optimize portfolio allocation across 5 assets considering correlation, "
            "expected returns, and risk constraints. Rebalance dynamically based on "
            "changing market conditions."
        )
        objectives = [
            "Calculate correlation matrix",
            "Optimize allocation weights",
            "Validate risk constraints",
            "Generate rebalancing plan",
        ]
        required_tools = [
            "portfolio_optimizer",
            "correlation_calculator",
            "risk_calculator",
        ]

        return TradingTask(
            difficulty=TaskDifficulty.FRONTIER,
            category=TaskCategory.PORTFOLIO_OPTIMIZATION,
            description=description,
            objectives=objectives,
            required_tools=required_tools,
            expected_capabilities=["portfolio_optimization"],
        )

    def _generate_regime_detection_task(
        self, difficulty: TaskDifficulty, context: RunContext
    ) -> TradingTask:
        """Generate regime detection task"""
        description = (
            "Detect current market regime (bull, bear, sideways, volatile) using multiple "
            "indicators and adapt trading strategy accordingly."
        )
        objectives = [
            "Calculate regime indicators",
            "Classify current regime",
            "Adapt strategy parameters",
        ]
        required_tools = ["market_data", "regime_detector"]

        return TradingTask(
            difficulty=difficulty,
            category=TaskCategory.REGIME_DETECTION,
            description=description,
            objectives=objectives,
            required_tools=required_tools,
            expected_capabilities=["regime_detection"],
        )

    def _generate_sentiment_integration_task(
        self, difficulty: TaskDifficulty, context: RunContext
    ) -> TradingTask:
        """Generate sentiment integration task"""
        description = (
            "Integrate sentiment from multiple sources (news, social media, options flow) "
            "to generate trading signals that complement technical analysis."
        )
        objectives = [
            "Fetch sentiment from multiple sources",
            "Aggregate and weight sentiment",
            "Combine with technical signals",
        ]
        required_tools = ["sentiment_analyzer", "news_fetcher", "options_analyzer"]

        return TradingTask(
            difficulty=difficulty,
            category=TaskCategory.SENTIMENT_INTEGRATION,
            description=description,
            objectives=objectives,
            required_tools=required_tools,
            expected_capabilities=["sentiment_analysis"],
        )

    def _generate_multi_timeframe_task(
        self, difficulty: TaskDifficulty, context: RunContext
    ) -> TradingTask:
        """Generate multi-timeframe analysis task"""
        description = (
            "Perform analysis across multiple timeframes (1h, 4h, daily, weekly) to identify "
            "trade setups with high probability, ensuring alignment across timeframes."
        )
        objectives = [
            "Analyze 4+ timeframes",
            "Identify confluence zones",
            "Generate high-probability signals",
        ]
        required_tools = ["market_data", "multi_timeframe_analyzer"]

        return TradingTask(
            difficulty=difficulty,
            category=TaskCategory.MULTI_TIMEFRAME,
            description=objectives,
            objectives=objectives,
            required_tools=required_tools,
            expected_capabilities=["multi_timeframe_analysis"],
        )

    def _generate_edge_case_task(
        self, difficulty: TaskDifficulty, context: RunContext
    ) -> TradingTask:
        """Generate edge case task"""
        description = (
            "Handle edge case: Market gap up 5%+ at open. Determine if this is a continuation "
            "pattern or exhaustion, and decide whether to trade or wait."
        )
        objectives = [
            "Analyze gap pattern",
            "Determine continuation vs exhaustion",
            "Make trading decision",
        ]
        required_tools = ["market_data", "pattern_detector"]

        return TradingTask(
            difficulty=difficulty,
            category=TaskCategory.EDGE_CASE,
            description=description,
            objectives=objectives,
            required_tools=required_tools,
            expected_capabilities=["edge_case_handling"],
        )

    def record_performance(self, performance: TaskPerformance) -> None:
        """Record executor performance on a task"""
        self.task_performances.append(performance)

        # Update difficulty success tracking
        if performance.task_id in self.generated_tasks:
            task = self.generated_tasks[performance.task_id]
            if performance.success:
                self.successful_difficulties[task.difficulty] += 1

        # Persist performance
        self._save_performance(performance)

        logger.info(
            f"ðŸ“Š Task performance recorded: {performance.task_id} "
            f"({performance.success}, quality={performance.quality_score:.2f})"
        )

    def _save_task(self, task: TradingTask) -> None:
        """Save task to disk"""
        task_file = self.storage_dir / "tasks" / f"{task.task_id}.json"
        task_file.parent.mkdir(parents=True, exist_ok=True)

        with open(task_file, "w") as f:
            json.dump(task.to_dict(), f, indent=2)

    def _save_performance(self, performance: TaskPerformance) -> None:
        """Save performance to disk"""
        perf_file = (
            self.storage_dir
            / "performances"
            / f"{performance.task_id}_{performance.completed_at}.json"
        )
        perf_file.parent.mkdir(parents=True, exist_ok=True)

        with open(perf_file, "w") as f:
            json.dump(asdict(performance), f, indent=2)

    def _load_history(self) -> None:
        """Load task and performance history"""
        # Load tasks
        tasks_dir = self.storage_dir / "tasks"
        if tasks_dir.exists():
            for task_file in tasks_dir.glob("*.json"):
                try:
                    with open(task_file, "r") as f:
                        data = json.load(f)
                        task = TradingTask.from_dict(data)
                        self.generated_tasks[task.task_id] = task
                except Exception as e:
                    logger.warning(f"Failed to load task {task_file}: {e}")

        # Load performances
        perf_dir = self.storage_dir / "performances"
        if perf_dir.exists():
            for perf_file in perf_dir.glob("*.json"):
                try:
                    with open(perf_file, "r") as f:
                        data = json.load(f)
                        perf = TaskPerformance(**data)
                        self.task_performances.append(perf)
                except Exception as e:
                    logger.warning(f"Failed to load performance {perf_file}: {e}")
