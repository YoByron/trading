"""
Mean Reversion Strategy

A strategy that profits from price returning to its mean after extreme deviations.
Works best in ranging/sideways markets (complements momentum in trending markets).

Key Indicators:
- RSI: Oversold (<30) = buy signal, Overbought (>70) = sell signal
- Bollinger Bands: Price below lower band = buy, above upper band = sell
- Volume: Confirms conviction of reversal

Entry Conditions (BUY):
- RSI < 30 (oversold)
- Price below lower Bollinger Band (2 std devs)
- Volume > 0.8x average (some conviction)

Entry Conditions (SELL/SHORT):
- RSI > 70 (overbought)
- Price above upper Bollinger Band
- Volume > 0.8x average

Exit Conditions:
- Price returns to SMA (mean reversion complete)
- RSI returns to neutral (40-60 range)
- Stop-loss at 2x ATR

Author: Trading System
Created: 2025-12-05
"""

from __future__ import annotations

import logging
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Optional

import pandas as pd

from src.utils.technical_indicators import calculate_rsi, calculate_volume_ratio

logger = logging.getLogger(__name__)


@dataclass
class MeanReversionSignal:
    """Signal generated by mean reversion strategy."""

    symbol: str
    action: str  # "buy", "sell", "hold"
    strength: float  # 0.0 to 1.0
    rsi: float
    bb_position: float  # 0 = at lower band, 1 = at upper band, 0.5 = at SMA
    volume_ratio: float
    entry_price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    reason: str = ""


class MeanReversionStrategy:
    """
    Mean Reversion Strategy for ranging markets.

    This strategy identifies oversold/overbought conditions and trades
    the expected reversion to the mean. Best used in conjunction with
    a regime detector to avoid trading during strong trends.

    Attributes:
        etf_universe: List of symbols to trade
        daily_allocation: Dollar amount to allocate per trade
        lookback_period: Period for SMA/Bollinger calculation
        bb_std_dev: Number of standard deviations for Bollinger Bands
        rsi_oversold: RSI threshold for oversold condition
        rsi_overbought: RSI threshold for overbought condition
    """

    def __init__(
        self,
        etf_universe: Optional[list[str]] = None,
        daily_allocation: float = 10.0,
        lookback_period: int = 20,
        bb_std_dev: float = 2.0,
        rsi_oversold: float = 30.0,
        rsi_overbought: float = 70.0,
        volume_threshold: float = 0.8,
        atr_stop_multiplier: float = 2.0,
    ):
        """
        Initialize the mean reversion strategy.

        Args:
            etf_universe: Symbols to trade (default: major ETFs)
            daily_allocation: Dollar amount per trade
            lookback_period: SMA/BB calculation period
            bb_std_dev: Bollinger Band standard deviations
            rsi_oversold: RSI level for buy signal
            rsi_overbought: RSI level for sell signal
            volume_threshold: Minimum volume ratio for entry
            atr_stop_multiplier: ATR multiplier for stop-loss
        """
        self.etf_universe = etf_universe or ["SPY", "QQQ", "IWM", "DIA", "VOO"]
        self.daily_allocation = daily_allocation
        self.lookback_period = lookback_period
        self.bb_std_dev = bb_std_dev
        self.rsi_oversold = rsi_oversold
        self.rsi_overbought = rsi_overbought
        self.volume_threshold = volume_threshold
        self.atr_stop_multiplier = atr_stop_multiplier

        # Strategy name for registry
        self.name = "MeanReversionStrategy"

        logger.info(
            f"MeanReversionStrategy initialized: universe={self.etf_universe}, "
            f"RSI thresholds={rsi_oversold}/{rsi_overbought}, "
            f"BB std_dev={bb_std_dev}"
        )

    def calculate_bollinger_bands(
        self, prices: pd.Series
    ) -> tuple[float, float, float, float]:
        """
        Calculate Bollinger Bands.

        Args:
            prices: Price series (Close prices)

        Returns:
            Tuple of (sma, upper_band, lower_band, bb_position)
            bb_position: 0 = at lower band, 1 = at upper band, 0.5 = at SMA
        """
        if len(prices) < self.lookback_period:
            logger.warning(
                f"Insufficient data for BB: {len(prices)} < {self.lookback_period}"
            )
            return (0.0, 0.0, 0.0, 0.5)

        sma = prices.rolling(window=self.lookback_period).mean().iloc[-1]
        std = prices.rolling(window=self.lookback_period).std().iloc[-1]

        upper_band = sma + (self.bb_std_dev * std)
        lower_band = sma - (self.bb_std_dev * std)

        current_price = prices.iloc[-1]

        # Calculate position within bands (0 = lower, 1 = upper)
        band_width = upper_band - lower_band
        if band_width > 0:
            bb_position = (current_price - lower_band) / band_width
        else:
            bb_position = 0.5

        return (float(sma), float(upper_band), float(lower_band), float(bb_position))

    def calculate_atr(self, hist: pd.DataFrame, period: int = 14) -> float:
        """
        Calculate Average True Range for stop-loss placement.

        Args:
            hist: DataFrame with High, Low, Close columns
            period: ATR period

        Returns:
            ATR value
        """
        if len(hist) < period + 1:
            return 0.0

        high = hist["High"]
        low = hist["Low"]
        close = hist["Close"].shift(1)

        tr1 = high - low
        tr2 = abs(high - close)
        tr3 = abs(low - close)

        tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
        atr = tr.rolling(window=period).mean().iloc[-1]

        return float(atr) if not pd.isna(atr) else 0.0

    def generate_signal(
        self, symbol: str, hist: pd.DataFrame
    ) -> MeanReversionSignal:
        """
        Generate a mean reversion signal for a single symbol.

        Args:
            symbol: Ticker symbol
            hist: Historical OHLCV data

        Returns:
            MeanReversionSignal with action and metadata
        """
        if hist is None or len(hist) < self.lookback_period + 14:
            return MeanReversionSignal(
                symbol=symbol,
                action="hold",
                strength=0.0,
                rsi=50.0,
                bb_position=0.5,
                volume_ratio=1.0,
                reason="Insufficient data",
            )

        # Calculate indicators
        prices = hist["Close"]
        rsi = calculate_rsi(prices, period=14)
        sma, upper_band, lower_band, bb_position = self.calculate_bollinger_bands(prices)
        volume_ratio = calculate_volume_ratio(hist, window=20)
        atr = self.calculate_atr(hist)

        current_price = float(prices.iloc[-1])

        # Default signal
        action = "hold"
        strength = 0.0
        reason = "No signal"
        stop_loss = None
        take_profit = None

        # Check for BUY signal (oversold + below lower band)
        if rsi < self.rsi_oversold and bb_position < 0.2:
            if volume_ratio >= self.volume_threshold:
                action = "buy"
                # Strength based on how oversold
                rsi_strength = (self.rsi_oversold - rsi) / self.rsi_oversold
                bb_strength = (0.2 - bb_position) / 0.2
                strength = min(1.0, (rsi_strength + bb_strength) / 2)

                # Stop-loss below entry
                stop_loss = current_price - (atr * self.atr_stop_multiplier)
                # Take profit at SMA (mean reversion target)
                take_profit = sma

                reason = f"Oversold (RSI={rsi:.1f}, BB={bb_position:.2f})"
            else:
                reason = f"Oversold but low volume ({volume_ratio:.2f})"

        # Check for SELL signal (overbought + above upper band)
        elif rsi > self.rsi_overbought and bb_position > 0.8:
            if volume_ratio >= self.volume_threshold:
                action = "sell"
                # Strength based on how overbought
                rsi_strength = (rsi - self.rsi_overbought) / (100 - self.rsi_overbought)
                bb_strength = (bb_position - 0.8) / 0.2
                strength = min(1.0, (rsi_strength + bb_strength) / 2)

                # Stop-loss above entry
                stop_loss = current_price + (atr * self.atr_stop_multiplier)
                # Take profit at SMA
                take_profit = sma

                reason = f"Overbought (RSI={rsi:.1f}, BB={bb_position:.2f})"
            else:
                reason = f"Overbought but low volume ({volume_ratio:.2f})"

        else:
            reason = f"Neutral (RSI={rsi:.1f}, BB={bb_position:.2f})"

        return MeanReversionSignal(
            symbol=symbol,
            action=action,
            strength=strength,
            rsi=rsi,
            bb_position=bb_position,
            volume_ratio=volume_ratio,
            entry_price=current_price if action != "hold" else None,
            stop_loss=stop_loss,
            take_profit=take_profit,
            reason=reason,
        )

    def generate_signals(
        self, data: dict[str, pd.DataFrame]
    ) -> list[MeanReversionSignal]:
        """
        Generate signals for all symbols in universe.

        Args:
            data: Dict mapping symbol to historical DataFrame

        Returns:
            List of MeanReversionSignal objects
        """
        signals = []
        for symbol in self.etf_universe:
            hist = data.get(symbol)
            if hist is not None:
                signal = self.generate_signal(symbol, hist)
                signals.append(signal)
        return signals

    def select_best_signal(
        self, signals: list[MeanReversionSignal]
    ) -> Optional[MeanReversionSignal]:
        """
        Select the best signal from a list of signals.

        Args:
            signals: List of generated signals

        Returns:
            Best signal or None if no actionable signals
        """
        actionable = [s for s in signals if s.action != "hold" and s.strength > 0.3]

        if not actionable:
            return None

        # Sort by strength (highest first)
        actionable.sort(key=lambda s: s.strength, reverse=True)
        return actionable[0]

    def get_config(self) -> dict[str, Any]:
        """Return strategy configuration for logging/serialization."""
        return {
            "name": self.name,
            "etf_universe": self.etf_universe,
            "daily_allocation": self.daily_allocation,
            "lookback_period": self.lookback_period,
            "bb_std_dev": self.bb_std_dev,
            "rsi_oversold": self.rsi_oversold,
            "rsi_overbought": self.rsi_overbought,
            "volume_threshold": self.volume_threshold,
            "atr_stop_multiplier": self.atr_stop_multiplier,
        }


# Convenience function
def get_default_mean_reversion_strategy() -> MeanReversionStrategy:
    """Get a default mean reversion strategy instance."""
    return MeanReversionStrategy(
        etf_universe=["SPY", "QQQ", "IWM", "DIA", "VOO"],
        daily_allocation=10.0,
        lookback_period=20,
        bb_std_dev=2.0,
        rsi_oversold=30.0,
        rsi_overbought=70.0,
    )
