"""Dataclasses powering the agentic day-trading support system."""

from __future__ import annotations

from dataclasses import dataclass, field, asdict
from datetime import datetime
from typing import Dict, List, Optional

ISO_FMT = "%Y-%m-%dT%H:%M:%S%z"


@dataclass
class SessionTemplate:
    """Template describing a recurring coaching touchpoint."""

    name: str
    cadence: str  # e.g., daily, weekly
    start_time: str  # HH:MM in local timezone
    duration_minutes: int
    format: str  # chatroom, webinar, 1:1, psychology
    focus: List[str]
    day_of_week: Optional[str] = None  # e.g., Monday
    notes: List[str] = field(default_factory=list)


@dataclass
class CoachingProgram:
    """Metadata for a day-trading coaching provider."""

    name: str
    url: str
    timezone: str
    highlights: List[str]
    session_templates: List[SessionTemplate]
    accountability_prompts: List[str] = field(default_factory=list)
    escalation_contacts: List[str] = field(default_factory=list)


@dataclass
class BookLesson:
    """Actionable lesson extracted from a book resource."""

    title: str
    trigger: str
    actions: List[str]


@dataclass
class ReadingSegment:
    """Chunk of a book assigned to a short study block."""

    label: str
    goal: str
    minutes: int
    difficulty: str


@dataclass
class BookResource:
    """Structured metadata for a day-trading book."""

    title: str
    author: str
    difficulty: str
    summary: str
    focus_tags: List[str]
    lessons: List[BookLesson]
    reading_plan: List[ReadingSegment]


@dataclass
class NewsletterResource:
    """Newsletter definition used by the harvester."""

    name: str
    provider: str
    url: str
    feed_url: Optional[str]
    cadence: str
    focus_tags: List[str]
    emphasis: List[str]
    window_hours: int = 24


@dataclass
class CoachSession:
    """Upcoming coaching touchpoint produced by MentorMonitor."""

    program: str
    session_name: str
    scheduled_for: datetime
    format: str
    focus: List[str]
    duration_minutes: int
    accountability_prompt: Optional[str]
    url: str


@dataclass
class ReadingAssignment:
    """Study action item produced by StudyGuideAgent."""

    book: str
    lesson: str
    task: str
    minutes: int
    difficulty: str
    tags: List[str]


@dataclass
class NewsletterInsight:
    """Structured summary generated by MarketPrepAgent."""

    source: str
    headline: str
    summary: str
    tickers: List[str]
    urgency: str
    link: Optional[str]


@dataclass
class DailySupportPlan:
    """Full output of the day-trading support orchestrator."""

    generated_at: datetime
    focus_areas: List[str]
    coaching: List[CoachSession]
    reading: List[ReadingAssignment]
    newsletters: List[NewsletterInsight]

    def to_dict(self) -> Dict:
        """Convert the plan into primitive types for persistence."""

        def _convert(value):
            if isinstance(value, datetime):
                return value.strftime(ISO_FMT)
            if hasattr(value, "to_dict"):
                return value.to_dict()
            if dataclass_isinstance(value):
                return {key: _convert(val) for key, val in asdict(value).items()}
            if isinstance(value, dict):
                return {key: _convert(val) for key, val in value.items()}
            if isinstance(value, list):
                return [_convert(v) for v in value]
            return value

        return {
            "generated_at": self.generated_at.strftime(ISO_FMT),
            "focus_areas": list(self.focus_areas),
            "coaching": [_convert(item) for item in self.coaching],
            "reading": [_convert(item) for item in self.reading],
            "newsletters": [_convert(item) for item in self.newsletters],
        }


def dataclass_isinstance(value: object) -> bool:
    """Best-effort dataclass detection without importing dataclasses.is_dataclass repeatedly."""

    try:
        from dataclasses import is_dataclass

        return is_dataclass(value)
    except Exception:  # pragma: no cover - defensive
        return False
