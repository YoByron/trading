#!/usr/bin/env python3
"""
Capital Scaling Policy Script
------------------------------

Operationalizes capital scaling rules by integrating:
1. Profit target tracking (ProfitTargetTracker)
2. Promotion gate enforcement (enforce_promotion_gate.py)
3. P/L sanity checks (verify_pl_sanity.py)

This script determines whether to scale capital based on:
- Promotion gate passing (win rate, Sharpe, drawdown thresholds)
- No critical P/L alerts (stuck equity, no trades, etc.)
- Conservative scaling limits (max 2x per step, drawdown < 5%)

Usage:
    # Dry-run (report only, no changes):
    python scripts/capital_scaling_policy.py

    # Apply scaling decision to system_state.json:
    python scripts/capital_scaling_policy.py --apply

    # Output as JSON:
    python scripts/capital_scaling_policy.py --json

    # Custom target and thresholds:
    python scripts/capital_scaling_policy.py --target-profit 100 --max-scale 2.0
"""

from __future__ import annotations

import argparse
import json
import logging
import subprocess
import sys
from dataclasses import dataclass
from datetime import datetime, timedelta
from pathlib import Path
from typing import Any

# Paths
PROFIT_TARGET_REPORT = Path("reports/profit_target_report.json")
SYSTEM_STATE_FILE = Path("data/system_state.json")
PROMOTION_GATE_SCRIPT = Path("scripts/enforce_promotion_gate.py")
PL_SANITY_SCRIPT = Path("scripts/verify_pl_sanity.py")

# Scaling policy thresholds
DEFAULT_MAX_SCALE_FACTOR = 2.0  # Max 2x scaling per step
DEFAULT_MAX_DRAWDOWN_PCT = 5.0  # Max 5% drawdown for scaling
DEFAULT_MIN_WIN_RATE = 55.0  # Min win rate for scaling
DEFAULT_MIN_SHARPE = 1.2  # Min Sharpe ratio for scaling
DEFAULT_REVIEW_DAYS = 7  # Review scaling decision every 7 days

# Logging configuration
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
logger = logging.getLogger(__name__)


@dataclass
class ScalingDecision:
    """Container for capital scaling decision and rationale."""

    timestamp: str
    current_daily_budget: float
    recommended_new_budget: float
    scaling_approved: bool
    scaling_factor: float
    reasons: list[str]
    next_review_date: str
    metrics: dict[str, Any]
    gate_status: dict[str, Any]
    sanity_status: dict[str, Any]


class CapitalScalingPolicy:
    """
    Determines whether to scale capital based on comprehensive safety checks.

    This class integrates multiple data sources:
    - Profit target tracker (optimal budget calculation)
    - Promotion gate (min quality thresholds)
    - P/L sanity checks (detect silent failures)
    """

    def __init__(
        self,
        max_scale_factor: float = DEFAULT_MAX_SCALE_FACTOR,
        max_drawdown_pct: float = DEFAULT_MAX_DRAWDOWN_PCT,
        min_win_rate: float = DEFAULT_MIN_WIN_RATE,
        min_sharpe: float = DEFAULT_MIN_SHARPE,
        review_days: int = DEFAULT_REVIEW_DAYS,
        verbose: bool = False,
    ) -> None:
        """
        Initialize capital scaling policy.

        Args:
            max_scale_factor: Maximum scaling multiplier per step (default: 2.0)
            max_drawdown_pct: Maximum drawdown % to allow scaling (default: 5.0)
            min_win_rate: Minimum win rate % required for scaling (default: 55.0)
            min_sharpe: Minimum Sharpe ratio required for scaling (default: 1.2)
            review_days: Days until next scaling review (default: 7)
            verbose: Enable verbose logging
        """
        self.max_scale_factor = max_scale_factor
        self.max_drawdown_pct = max_drawdown_pct
        self.min_win_rate = min_win_rate
        self.min_sharpe = min_sharpe
        self.review_days = review_days
        self.verbose = verbose

        if verbose:
            logger.setLevel(logging.DEBUG)

    def _load_json(self, path: Path) -> dict[str, Any]:
        """Load JSON file with error handling."""
        if not path.exists():
            logger.error(f"File not found: {path}")
            raise FileNotFoundError(f"Required file not found: {path}")

        try:
            with path.open("r", encoding="utf-8") as f:
                return json.load(f)
        except json.JSONDecodeError as e:
            logger.error(f"Invalid JSON in {path}: {e}")
            raise

    def _save_json(self, path: Path, data: dict[str, Any]) -> None:
        """Save JSON file with pretty formatting."""
        path.parent.mkdir(parents=True, exist_ok=True)
        with path.open("w", encoding="utf-8") as f:
            json.dump(data, f, indent=2)
        logger.info(f"Saved: {path}")

    def load_profit_target_report(self) -> dict[str, Any]:
        """
        Load profit target report generated by ProfitTargetTracker.

        Returns:
            Dict containing current/projected/recommended budgets and metrics

        Raises:
            FileNotFoundError: If report doesn't exist
        """
        logger.info(f"Loading profit target report: {PROFIT_TARGET_REPORT}")
        report = self._load_json(PROFIT_TARGET_REPORT)

        logger.debug(f"Current daily budget: ${report.get('current_daily_budget', 0):.2f}")
        logger.debug(f"Recommended budget: ${report.get('recommended_daily_budget', 0)}")
        logger.debug(f"Scaling factor: {report.get('scaling_factor', 0)}")

        return report

    def check_promotion_gate(self) -> dict[str, Any]:
        """
        Check promotion gate status using enforce_promotion_gate.py.

        Returns:
            Dict with status, deficits, metrics, and thresholds

        Raises:
            RuntimeError: If gate check script fails
        """
        logger.info("Checking promotion gate status...")

        if not PROMOTION_GATE_SCRIPT.exists():
            logger.error(f"Promotion gate script not found: {PROMOTION_GATE_SCRIPT}")
            raise FileNotFoundError(f"Script not found: {PROMOTION_GATE_SCRIPT}")

        # Run promotion gate with JSON output
        try:
            result = subprocess.run(
                [sys.executable, str(PROMOTION_GATE_SCRIPT), "--json"],
                capture_output=True,
                text=True,
                check=False,  # Don't raise on non-zero exit (gate can fail)
            )

            if not result.stdout.strip():
                logger.error("Promotion gate returned empty output")
                raise RuntimeError("Empty output from promotion gate")

            gate_data = json.loads(result.stdout)
            logger.debug(f"Gate status: {gate_data.get('status')}")
            logger.debug(f"Deficits: {len(gate_data.get('deficits', []))}")

            return gate_data

        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse promotion gate output: {e}")
            logger.error(f"stdout: {result.stdout}")
            logger.error(f"stderr: {result.stderr}")
            raise RuntimeError("Invalid JSON from promotion gate")

        except Exception as e:
            logger.error(f"Promotion gate check failed: {e}")
            raise

    def check_pl_sanity(self) -> dict[str, Any]:
        """
        Run P/L sanity checks using verify_pl_sanity.py.

        Returns:
            Dict with health status and alerts

        Note:
            P/L sanity script doesn't support JSON output yet,
            so we parse exit code and logs.
        """
        logger.info("Running P/L sanity checks...")

        if not PL_SANITY_SCRIPT.exists():
            logger.warning(f"P/L sanity script not found: {PL_SANITY_SCRIPT}")
            return {
                "healthy": True,
                "alerts": [],
                "note": "P/L sanity script not available (skipped)",
            }

        try:
            result = subprocess.run(
                [sys.executable, str(PL_SANITY_SCRIPT)],
                capture_output=True,
                text=True,
                check=False,
            )

            # Exit code 0 = healthy, 1 = alerts, 2 = error
            is_healthy = result.returncode == 0
            has_critical_alerts = result.returncode == 1

            # Parse output for alerts (look for CRITICAL in output)
            alerts = []
            if has_critical_alerts:
                for line in result.stdout.split("\n"):
                    if "CRITICAL" in line or "üö®" in line:
                        alerts.append(line.strip())

            logger.debug(f"P/L sanity: {'‚úÖ healthy' if is_healthy else '‚ö†Ô∏è alerts detected'}")

            return {
                "healthy": is_healthy,
                "alerts": alerts,
                "exit_code": result.returncode,
            }

        except Exception as e:
            logger.warning(f"P/L sanity check failed: {e}")
            return {
                "healthy": True,  # Default to healthy if check fails
                "alerts": [],
                "note": f"Check failed: {e}",
            }

    def calculate_scaling_decision(
        self,
        profit_report: dict[str, Any],
        gate_status: dict[str, Any],
        sanity_status: dict[str, Any],
    ) -> ScalingDecision:
        """
        Calculate capital scaling decision based on all safety checks.

        Logic:
        1. Promotion gate MUST pass (no deficits, no override)
        2. P/L sanity MUST be healthy (no critical alerts)
        3. Scaling factor MUST be <= max_scale_factor (conservative scaling)
        4. Drawdown MUST be < max_drawdown_pct
        5. If all pass ‚Üí approve scaling to min(current * max_scale, recommended)
        6. Otherwise ‚Üí maintain current budget

        Args:
            profit_report: Output from ProfitTargetTracker
            gate_status: Output from enforce_promotion_gate.py
            sanity_status: Output from verify_pl_sanity.py

        Returns:
            ScalingDecision with approved/denied recommendation
        """
        logger.info("Calculating scaling decision...")

        reasons: list[str] = []
        scaling_approved = True

        # Extract metrics
        current_budget = float(profit_report.get("current_daily_budget", 0))
        recommended_budget = profit_report.get("recommended_daily_budget")
        scaling_factor = profit_report.get("scaling_factor")
        win_rate = float(profit_report.get("win_rate", 0))
        avg_return_pct = float(profit_report.get("avg_return_pct", 0))

        # Gate metrics
        gate_metrics = gate_status.get("metrics", {})
        gate_passed = gate_status.get("status") == "passed"
        gate_override = gate_status.get("override_active", False)
        gate_deficits = gate_status.get("deficits", [])
        drawdown_pct = abs(float(gate_metrics.get("max_drawdown", 0)))

        # Sanity metrics
        sanity_healthy = sanity_status.get("healthy", True)
        sanity_alerts = sanity_status.get("alerts", [])

        logger.debug(f"Current budget: ${current_budget:.2f}")
        logger.debug(f"Recommended budget: ${recommended_budget}")
        logger.debug(f"Scaling factor: {scaling_factor}")
        logger.debug(f"Gate passed: {gate_passed} (override: {gate_override})")
        logger.debug(f"Sanity healthy: {sanity_healthy}")

        # Check 1: Promotion gate must pass WITHOUT override
        if not gate_passed:
            scaling_approved = False
            reasons.append(
                f"‚ùå Promotion gate FAILED with {len(gate_deficits)} deficits:"
            )
            for deficit in gate_deficits[:3]:  # Show first 3
                reasons.append(f"   ‚Ä¢ {deficit.get('description', 'Unknown deficit')}")

        elif gate_override:
            scaling_approved = False
            reasons.append(
                "‚ùå Promotion gate passed with OVERRIDE flag (manual bypass) - "
                "scaling requires clean pass"
            )

        else:
            reasons.append("‚úÖ Promotion gate passed (all quality thresholds met)")

        # Check 2: P/L sanity must be healthy (no critical alerts)
        if not sanity_healthy:
            scaling_approved = False
            reasons.append(
                f"‚ùå P/L sanity check FAILED with {len(sanity_alerts)} critical alerts:"
            )
            for alert in sanity_alerts[:3]:
                reasons.append(f"   ‚Ä¢ {alert}")

        else:
            reasons.append("‚úÖ P/L sanity check passed (no silent failures detected)")

        # Check 3: Recommended budget must exist (profitable strategy)
        if recommended_budget is None or avg_return_pct <= 0:
            scaling_approved = False
            reasons.append(
                f"‚ùå Strategy not profitable yet (avg return: {avg_return_pct:.2f}%) - "
                "cannot calculate recommended budget"
            )
            reasons.append(
                "   Wait for 5+ profitable sessions before scaling"
            )

        else:
            reasons.append(
                f"‚úÖ Strategy profitable (avg return: {avg_return_pct:.2f}%)"
            )

        # Check 4: Scaling factor must be reasonable (conservative scaling)
        if scaling_factor is not None and scaling_factor > self.max_scale_factor:
            scaling_approved = False
            reasons.append(
                f"‚ùå Scaling factor {scaling_factor:.1f}x exceeds "
                f"max {self.max_scale_factor:.1f}x (too aggressive)"
            )
            reasons.append(
                f"   Recommend capping at {self.max_scale_factor:.1f}x incremental scaling"
            )

        elif scaling_factor is not None:
            reasons.append(
                f"‚úÖ Scaling factor {scaling_factor:.1f}x within "
                f"max {self.max_scale_factor:.1f}x limit"
            )

        # Check 5: Drawdown must be acceptable
        if drawdown_pct > self.max_drawdown_pct:
            scaling_approved = False
            reasons.append(
                f"‚ùå Drawdown {drawdown_pct:.2f}% exceeds "
                f"max {self.max_drawdown_pct:.2f}% (too risky to scale)"
            )

        else:
            reasons.append(
                f"‚úÖ Drawdown {drawdown_pct:.2f}% within "
                f"max {self.max_drawdown_pct:.2f}% limit"
            )

        # Check 6: Win rate must meet minimum
        if win_rate < self.min_win_rate:
            scaling_approved = False
            reasons.append(
                f"‚ùå Win rate {win_rate:.1f}% below "
                f"min {self.min_win_rate:.1f}% threshold"
            )

        else:
            reasons.append(
                f"‚úÖ Win rate {win_rate:.1f}% exceeds "
                f"min {self.min_win_rate:.1f}% threshold"
            )

        # Calculate recommended new budget
        if scaling_approved and recommended_budget is not None:
            # Conservative scaling: take minimum of:
            # 1. Current budget * max_scale_factor (e.g., 2x)
            # 2. Recommended budget from profit tracker
            conservative_max = current_budget * self.max_scale_factor
            recommended_new_budget = min(conservative_max, recommended_budget)

            actual_scale_factor = recommended_new_budget / current_budget if current_budget > 0 else 1.0

            reasons.append("")
            reasons.append(
                f"üéØ RECOMMENDATION: Scale from ${current_budget:.2f}/day to "
                f"${recommended_new_budget:.2f}/day ({actual_scale_factor:.2f}x)"
            )
            reasons.append(
                f"   Expected daily profit at this scale: "
                f"${recommended_new_budget * (avg_return_pct / 100):.2f}"
            )

        else:
            recommended_new_budget = current_budget
            actual_scale_factor = 1.0
            reasons.append("")
            reasons.append(
                f"üõë RECOMMENDATION: Maintain current budget ${current_budget:.2f}/day "
                "(resolve deficits before scaling)"
            )

        # Calculate next review date
        next_review_date = (
            datetime.now() + timedelta(days=self.review_days)
        ).date().isoformat()

        return ScalingDecision(
            timestamp=datetime.now().isoformat(),
            current_daily_budget=current_budget,
            recommended_new_budget=recommended_new_budget,
            scaling_approved=scaling_approved,
            scaling_factor=actual_scale_factor,
            reasons=reasons,
            next_review_date=next_review_date,
            metrics={
                "win_rate": win_rate,
                "avg_return_pct": avg_return_pct,
                "drawdown_pct": drawdown_pct,
                "current_sharpe": gate_metrics.get("sharpe_ratio", 0),
            },
            gate_status={
                "passed": gate_passed,
                "override_active": gate_override,
                "deficit_count": len(gate_deficits),
            },
            sanity_status={
                "healthy": sanity_healthy,
                "alert_count": len(sanity_alerts),
            },
        )

    def apply_scaling_to_system_state(
        self, decision: ScalingDecision
    ) -> None:
        """
        Apply scaling decision to system_state.json.

        Updates daily_amount for each active strategy while preserving
        their allocation weights.

        Args:
            decision: Scaling decision to apply

        Raises:
            FileNotFoundError: If system_state.json not found
        """
        if not decision.scaling_approved:
            logger.warning(
                "Scaling NOT approved - skipping system_state.json update"
            )
            return

        logger.info(f"Applying scaling to {SYSTEM_STATE_FILE}...")

        # Load system state
        state = self._load_json(SYSTEM_STATE_FILE)

        # Get current and new budgets
        old_budget = decision.current_daily_budget
        new_budget = decision.recommended_new_budget
        scale_factor = new_budget / old_budget if old_budget > 0 else 1.0

        logger.info(
            f"Scaling budget: ${old_budget:.2f} ‚Üí ${new_budget:.2f} "
            f"({scale_factor:.2f}x)"
        )

        # Update each active strategy's daily_amount
        strategies = state.get("strategies", {})
        updated_count = 0

        for strategy_name, strategy_data in strategies.items():
            status = strategy_data.get("status", "active")

            # Only scale active strategies (not tracking/paused)
            if status not in {"tracking", "paused"}:
                old_amount = float(strategy_data.get("daily_amount", 0))
                new_amount = old_amount * scale_factor

                strategy_data["daily_amount"] = round(new_amount, 2)
                updated_count += 1

                logger.info(
                    f"  {strategy_name}: ${old_amount:.2f} ‚Üí ${new_amount:.2f}"
                )

        # Update metadata
        if "meta" not in state:
            state["meta"] = {}

        state["meta"]["last_updated"] = datetime.now().isoformat()
        state["meta"]["last_scaling_date"] = decision.timestamp
        state["meta"]["scaling_notes"] = (
            f"Scaled {updated_count} strategies by {scale_factor:.2f}x "
            f"(${old_budget:.2f} ‚Üí ${new_budget:.2f})"
        )

        # Save updated state
        self._save_json(SYSTEM_STATE_FILE, state)

        logger.info(
            f"‚úÖ Successfully scaled {updated_count} strategies in system_state.json"
        )

    def generate_report(self, decision: ScalingDecision) -> str:
        """
        Generate human-readable scaling report.

        Args:
            decision: Scaling decision to report

        Returns:
            Formatted multi-line report string
        """
        lines = []
        lines.append("=" * 70)
        lines.append("CAPITAL SCALING POLICY REPORT")
        lines.append("=" * 70)
        lines.append(f"Timestamp: {decision.timestamp}")
        lines.append("")

        # Current state
        lines.append("üìä CURRENT STATE:")
        lines.append(f"   Daily Budget: ${decision.current_daily_budget:.2f}")
        lines.append(f"   Win Rate: {decision.metrics['win_rate']:.1f}%")
        lines.append(f"   Avg Return: {decision.metrics['avg_return_pct']:.2f}%")
        lines.append(f"   Drawdown: {decision.metrics['drawdown_pct']:.2f}%")
        lines.append(f"   Sharpe Ratio: {decision.metrics['current_sharpe']:.2f}")
        lines.append("")

        # Gate status
        lines.append("üö¶ PROMOTION GATE:")
        gate = decision.gate_status
        status_emoji = "‚úÖ" if gate["passed"] else "‚ùå"
        lines.append(f"   Status: {status_emoji} {'PASSED' if gate['passed'] else 'FAILED'}")
        if gate["override_active"]:
            lines.append("   ‚ö†Ô∏è  Override flag active (manual bypass)")
        if gate["deficit_count"] > 0:
            lines.append(f"   Deficits: {gate['deficit_count']}")
        lines.append("")

        # Sanity status
        lines.append("üîç P/L SANITY:")
        sanity = decision.sanity_status
        status_emoji = "‚úÖ" if sanity["healthy"] else "‚ùå"
        lines.append(f"   Status: {status_emoji} {'HEALTHY' if sanity['healthy'] else 'ALERTS'}")
        if sanity["alert_count"] > 0:
            lines.append(f"   Alerts: {sanity['alert_count']}")
        lines.append("")

        # Decision
        lines.append("üéØ SCALING DECISION:")
        if decision.scaling_approved:
            lines.append("   Status: ‚úÖ APPROVED")
            lines.append(
                f"   New Budget: ${decision.recommended_new_budget:.2f}/day "
                f"({decision.scaling_factor:.2f}x)"
            )
        else:
            lines.append("   Status: ‚ùå DENIED")
            lines.append(
                f"   Maintain: ${decision.current_daily_budget:.2f}/day (no change)"
            )

        lines.append(f"   Next Review: {decision.next_review_date}")
        lines.append("")

        # Reasons
        lines.append("üìù RATIONALE:")
        for reason in decision.reasons:
            lines.append(f"   {reason}")
        lines.append("")

        lines.append("=" * 70)

        return "\n".join(lines)

    def run(
        self, apply: bool = False, json_output: bool = False
    ) -> ScalingDecision:
        """
        Execute complete capital scaling policy workflow.

        Steps:
        1. Load profit target report
        2. Check promotion gate status
        3. Run P/L sanity checks
        4. Calculate scaling decision
        5. Optionally apply to system_state.json

        Args:
            apply: If True, update system_state.json with decision
            json_output: If True, output JSON instead of human-readable

        Returns:
            ScalingDecision object
        """
        logger.info("Starting capital scaling policy evaluation...")

        # Step 1: Load profit target report
        profit_report = self.load_profit_target_report()

        # Step 2: Check promotion gate
        gate_status = self.check_promotion_gate()

        # Step 3: Run P/L sanity checks
        sanity_status = self.check_pl_sanity()

        # Step 4: Calculate scaling decision
        decision = self.calculate_scaling_decision(
            profit_report, gate_status, sanity_status
        )

        # Step 5: Apply if requested
        if apply:
            self.apply_scaling_to_system_state(decision)

        # Output results
        if json_output:
            # JSON output mode
            output = {
                "timestamp": decision.timestamp,
                "current_daily_budget": decision.current_daily_budget,
                "recommended_new_budget": decision.recommended_new_budget,
                "scaling_approved": decision.scaling_approved,
                "scaling_factor": decision.scaling_factor,
                "reasons": decision.reasons,
                "next_review_date": decision.next_review_date,
                "metrics": decision.metrics,
                "gate_status": decision.gate_status,
                "sanity_status": decision.sanity_status,
            }
            print(json.dumps(output, indent=2))

        else:
            # Human-readable output mode
            report = self.generate_report(decision)
            print(report)

        logger.info("Capital scaling policy evaluation complete")

        return decision


def parse_args() -> argparse.Namespace:
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(
        description="Capital scaling policy - determine if/how to scale daily budget",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Dry-run (report only, no changes):
  python scripts/capital_scaling_policy.py

  # Apply scaling decision:
  python scripts/capital_scaling_policy.py --apply

  # JSON output:
  python scripts/capital_scaling_policy.py --json

  # Custom thresholds:
  python scripts/capital_scaling_policy.py --max-scale 1.5 --max-drawdown 3.0
        """,
    )

    parser.add_argument(
        "--apply",
        action="store_true",
        help="Apply scaling decision to system_state.json (default: dry-run only)",
    )

    parser.add_argument(
        "--json",
        action="store_true",
        help="Output results as JSON (default: human-readable)",
    )

    parser.add_argument(
        "--max-scale",
        type=float,
        default=DEFAULT_MAX_SCALE_FACTOR,
        help=f"Maximum scaling factor per step (default: {DEFAULT_MAX_SCALE_FACTOR})",
    )

    parser.add_argument(
        "--max-drawdown",
        type=float,
        default=DEFAULT_MAX_DRAWDOWN_PCT,
        help=f"Maximum drawdown %% to allow scaling (default: {DEFAULT_MAX_DRAWDOWN_PCT})",
    )

    parser.add_argument(
        "--min-win-rate",
        type=float,
        default=DEFAULT_MIN_WIN_RATE,
        help=f"Minimum win rate %% required (default: {DEFAULT_MIN_WIN_RATE})",
    )

    parser.add_argument(
        "--min-sharpe",
        type=float,
        default=DEFAULT_MIN_SHARPE,
        help=f"Minimum Sharpe ratio required (default: {DEFAULT_MIN_SHARPE})",
    )

    parser.add_argument(
        "--review-days",
        type=int,
        default=DEFAULT_REVIEW_DAYS,
        help=f"Days until next review (default: {DEFAULT_REVIEW_DAYS})",
    )

    parser.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        help="Enable verbose debug logging",
    )

    return parser.parse_args()


def main() -> None:
    """Main entry point."""
    args = parse_args()

    try:
        # Initialize policy engine
        policy = CapitalScalingPolicy(
            max_scale_factor=args.max_scale,
            max_drawdown_pct=args.max_drawdown,
            min_win_rate=args.min_win_rate,
            min_sharpe=args.min_sharpe,
            review_days=args.review_days,
            verbose=args.verbose,
        )

        # Run policy evaluation
        decision = policy.run(apply=args.apply, json_output=args.json)

        # Exit code: 0 if approved, 1 if denied
        sys.exit(0 if decision.scaling_approved else 1)

    except FileNotFoundError as e:
        logger.error(f"Missing required file: {e}")
        sys.exit(2)

    except Exception as e:
        logger.error(f"Capital scaling policy failed: {e}", exc_info=True)
        sys.exit(2)


if __name__ == "__main__":
    main()
