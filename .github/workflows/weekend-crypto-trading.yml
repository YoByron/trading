name: Weekend Crypto Trading

on:
  schedule:
    # Run on Saturdays and Sundays at 10:00 AM Eastern
    # IMPORTANT: Update cron expression when DST changes (March/November)
    # EST (Nov-Mar): UTC-5 -> 10:00 AM ET = 15:00 UTC
    # EDT (Mar-Nov): UTC-4 -> 10:00 AM ET = 14:00 UTC
    # Run: python3 scripts/get_utc_time.py 10 0 0,6
    - cron: '0 15 * * 0,6'   # 10:00 AM Eastern (EST: Nov-Mar, update to 14:00 UTC in March)
  workflow_dispatch:
    inputs:
      force_trade:
        description: "Force execution even if crypto trading already ran today"
        required: false
        default: "false"

permissions:
  contents: write
  pages: write

# Prevent parallel weekend crypto runs
concurrency:
  group: weekend-crypto-trading
  cancel-in-progress: false

jobs:
  execute-crypto-trading:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    env:
      PYTHONPATH: ${{ github.workspace }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 1

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Validate system_state.json
        run: |
          echo "üîç Validating system_state.json..."

          if [ ! -f "data/system_state.json" ]; then
            echo "‚ö†Ô∏è  WARNING: system_state.json not found (will be created on first run)"
            exit 0
          fi

          # Validate JSON and check staleness
          python -c "
          import json
          import sys
          from datetime import datetime, timedelta

          try:
              with open('data/system_state.json', 'r') as f:
                  data = json.load(f)

              # Check staleness
              last_updated = data.get('meta', {}).get('last_updated', '')
              if last_updated:
                  updated_date = datetime.fromisoformat(last_updated.replace('Z', '+00:00')) if 'T' in last_updated else datetime.strptime(last_updated, '%Y-%m-%d %H:%M:%S')
                  age_hours = (datetime.now() - updated_date.replace(tzinfo=None)).total_seconds() / 3600

                  if age_hours > 48:
                      print(f'‚ö†Ô∏è  WARNING: system_state.json is {age_hours:.1f} hours old')
                      print(f'   Last updated: {last_updated}')
                  else:
                      print(f'‚úÖ System state current (updated {age_hours:.1f} hours ago)')

              print(f'‚úÖ Valid system_state.json')

          except Exception as e:
              print(f'‚ö†Ô∏è  WARNING: Could not validate system_state.json: {e}')
              print('   Crypto trading will proceed (state will be regenerated)')
          "

      - name: Check if today's crypto trade already executed
        id: check_execution
        env:
          FORCE_TRADE: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.force_trade || 'false' }}
        run: |
          echo "üîç Checking last crypto execution date..."
          python3 scripts/check_duplicate_execution.py

          if [ "${{ steps.check_execution.outputs.skip }}" = "true" ]; then
            echo "‚ö†Ô∏è  Crypto trading already executed today. Skipping run."
          fi

      - name: Pre-market health check
        id: health_check
        if: steps.check_execution.outputs.skip != 'true'
        env:
          ALPACA_API_KEY: ${{ secrets.ALPACA_API_KEY }}
          ALPACA_SECRET_KEY: ${{ secrets.ALPACA_SECRET_KEY }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          FINNHUB_API_KEY: ${{ secrets.FINNHUB_API_KEY }}
        run: |
          echo "üè• Running pre-market health check for crypto..."
          python3 scripts/pre_market_health_check.py

          if [ $? -ne 0 ]; then
            echo "‚ùå HEALTH CHECK FAILED - Aborting crypto trading execution"
            echo "health_check_passed=false" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "‚úÖ HEALTH CHECK PASSED - Proceeding with crypto trading"
            echo "health_check_passed=true" >> $GITHUB_OUTPUT
          fi

      - name: Execute weekend crypto trading
        if: steps.check_execution.outputs.skip != 'true' && steps.health_check.outputs.health_check_passed == 'true'
        env:
          ALPACA_API_KEY: ${{ secrets.ALPACA_API_KEY }}
          ALPACA_SECRET_KEY: ${{ secrets.ALPACA_SECRET_KEY }}
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
          HELICONE_API_KEY: ${{ secrets.HELICONE_API_KEY }}
          # LangSmith tracing (observability)
          LANGCHAIN_API_KEY: ${{ secrets.LANGCHAIN_API_KEY }}
          LANGCHAIN_PROJECT: 'ai-trading-system'
          LANGCHAIN_TRACING_V2: 'true'
          ALPHA_VANTAGE_API_KEY: ${{ secrets.ALPHA_VANTAGE_API_KEY }}
          POLYGON_API_KEY: ${{ secrets.POLYGON_API_KEY }}
          FINNHUB_API_KEY: ${{ secrets.FINNHUB_API_KEY }}
          DAILY_INVESTMENT: ${{ secrets.DAILY_INVESTMENT || '10.0' }}
          PAPER_TRADING: 'true'
          ENABLE_CRYPTO_AGENT: 'true'
          CRYPTO_DAILY_AMOUNT: ${{ secrets.CRYPTO_DAILY_AMOUNT || '25.00' }}
          # Relaxed filters for bull market / weekend trading
          CRYPTO_RSI_OVERBOUGHT: '80'  # Allow RSI up to 80 (default was 60)
          CRYPTO_VOLUME_THRESHOLD: '0.05'  # Allow very low weekend volume
          CRYPTO_FORCE_TRADE: 'true'  # Force BTC trade if all filters fail
          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
          LANGCHAIN_ENABLE_MCP: ${{ secrets.LANGCHAIN_ENABLE_MCP || 'true' }}
          LANGCHAIN_MODEL: ${{ secrets.LANGCHAIN_MODEL || 'claude-3-5-sonnet-20241022' }}
        run: |
          echo "üöÄ World-Class Crypto Strategy v4.1 (Trend + Momentum)"
          python3 << 'PYTHON'
          """v4.1: Buy when price > 50-day MA AND RSI > 50 (trend + momentum confirmation)"""
          import os, sys, json, requests, traceback
          from datetime import datetime, timezone
          today = datetime.now(timezone.utc).strftime("%Y-%m-%d")
          result = {"timestamp": datetime.now(timezone.utc).isoformat(), "date": today, "strategy": "WorldClassCrypto", "strategy_version": "4.1"}
          def save():
              os.makedirs("data", exist_ok=True)
              f = f"data/trades_{today}.json"
              t = json.load(open(f)) if os.path.exists(f) else []
              if not isinstance(t, list): t = [t]
              t.append(result)
              json.dump(t, open(f, "w"), indent=2)
              print(f"‚úÖ Saved to {f}")
          api_key, secret = os.environ.get("ALPACA_API_KEY",""), os.environ.get("ALPACA_SECRET_KEY","")
          if not api_key or not secret:
              result["error"], result["status"] = "MISSING_SECRETS", "FAILED"
              save()
              sys.exit(0)
          try:
              from alpaca.trading.client import TradingClient
              from alpaca.trading.requests import MarketOrderRequest
              from alpaca.trading.enums import OrderSide, TimeInForce
              import yfinance as yf
              client = TradingClient(api_key, secret, paper=True)
              acct = client.get_account()
              result["account_value"] = float(acct.equity)
              print(f"‚úÖ Account: ${result['account_value']:,.2f}")

              # STEP 1: TREND + MOMENTUM CHECK (50-day MA + RSI)
              print("\nüìä STEP 1: Trend + Momentum Check")

              def calc_rsi(prices, period=14):
                  """Calculate RSI (Relative Strength Index)"""
                  delta = prices.diff()
                  gain = delta.where(delta > 0, 0).rolling(window=period).mean()
                  loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
                  rs = gain / loss
                  return 100 - (100 / (1 + rs))

              trend_data = {}
              for s in ["BTC-USD","ETH-USD","SOL-USD"]:
                  try:
                      h = yf.Ticker(s).history(period="60d")
                      if len(h) >= 50:
                          price = float(h["Close"].iloc[-1])
                          ma50 = float(h["Close"].rolling(50).mean().iloc[-1])
                          rsi = float(calc_rsi(h["Close"]).iloc[-1])
                          above_ma = price > ma50
                          rsi_bullish = rsi > 50
                          pct = ((price - ma50) / ma50) * 100
                          chg = ((h["Close"].iloc[-1] - h["Close"].iloc[-7]) / h["Close"].iloc[-7]) * 100
                          trend_data[s] = {
                              "price": price, "ma50": ma50, "above_ma": above_ma,
                              "rsi": rsi, "rsi_bullish": rsi_bullish,
                              "pct": pct, "chg7d": chg,
                              "valid": above_ma and rsi_bullish
                          }
                          ma_st = "‚úÖ" if above_ma else "‚ùå"
                          rsi_st = "‚úÖ" if rsi_bullish else "‚ùå"
                          print(f"   {s}: ${price:,.0f} | MA50 {ma_st} ({pct:+.1f}%) | RSI {rsi:.0f} {rsi_st}")
                  except: pass

              valid_cryptos = {k:v for k,v in trend_data.items() if v.get("valid")}
              if not valid_cryptos:
                  above_ma_only = [k for k,v in trend_data.items() if v.get("above_ma")]
                  if not above_ma_only:
                      skip_reason = "All below 50-day MA"
                  elif not [k for k,v in trend_data.items() if v.get("rsi_bullish")]:
                      skip_reason = "All RSI below 50"
                  else:
                      skip_reason = "No trend+momentum alignment"
                  print(f"\n‚õî SKIP: {skip_reason}")
                  result["action"], result["skip_reason"] = "SKIP", skip_reason
                  result["status"] = "WAITING_FOR_SIGNAL"
                  save()
                  sys.exit(0)

              # STEP 2: Fear & Greed (for sizing only)
              mult = 1.0
              try:
                  fng = requests.get("https://api.alternative.me/fng/", timeout=10).json()
                  fv = int(fng["data"][0]["value"])
                  result["fear_greed_index"] = fv
                  print(f"\nüìä Fear & Greed: {fv}")
                  if fv <= 25: mult = 1.5
                  elif fv <= 40: mult = 1.25
                  elif fv >= 75:
                      result["action"], result["skip_reason"] = "SKIP", "Extreme greed"
                      save()
                      sys.exit(0)
              except: pass

              # STEP 3: Select best crypto (trend + momentum confirmed)
              best_item = max(valid_cryptos.items(), key=lambda x: x[1]["chg7d"])
              best, best_data = best_item[0].replace("-USD","USD"), best_item[1]
              price = best_data["price"]
              momentum = best_data["chg7d"]
              print(f"\nüéØ Selected: {best} (MA +{best_data['pct']:.1f}%, RSI {best_data['rsi']:.0f})")

              base = float(os.environ.get("CRYPTO_DAILY_AMOUNT","10.0"))
              amt = min(base * mult, result["account_value"] * 0.02)
              if amt < 1: amt = 1
              print(f"üí∞ BUY ${amt:.2f} {best} (trend confirmed)")
              order = client.submit_order(MarketOrderRequest(symbol=best, notional=amt, side=OrderSide.BUY, time_in_force=TimeInForce.GTC))
              print(f"üì§ Order submitted: {order.id} (status: {order.status})")

              # CRITICAL FIX (LL-034): Wait for fill confirmation
              import time
              fill_timeout = 30
              start = time.time()
              filled_price = None
              while time.time() - start < fill_timeout:
                  order = client.get_order_by_id(order.id)
                  print(f"   Checking: {order.status}")
                  if str(order.status) == "OrderStatus.FILLED":
                      filled_price = float(order.filled_avg_price) if order.filled_avg_price else price
                      print(f"‚úÖ FILLED at ${filled_price:.2f}")
                      break
                  elif str(order.status) in ["OrderStatus.CANCELLED", "OrderStatus.REJECTED", "OrderStatus.EXPIRED"]:
                      print(f"‚ùå Order {order.status}")
                      break
                  time.sleep(2)

              final_status = str(order.status)
              result.update({
                  "symbol": best,
                  "action": "BUY",
                  "notional": amt,
                  "price": price,
                  "filled_price": filled_price,
                  "filled_qty": float(order.filled_qty) if order.filled_qty else 0,
                  "order_id": str(order.id),
                  "status": final_status,
                  "size_multiplier": mult,
                  "verified_fill": final_status == "OrderStatus.FILLED",
                  "rsi": best_data["rsi"],
                  "pct_above_ma": best_data["pct"],
                  "trend_confirmed": True,
                  "momentum_confirmed": True
              })
              print(f"‚úÖ Order: {order.id} - Final: {final_status}")
          except Exception as e:
              print(f"‚ùå {e}")
              traceback.print_exc()
              result["error"], result["status"] = str(e), "FAILED"
          save()
          PYTHON

      - name: Update performance log
        if: steps.check_execution.outputs.skip != 'true' && steps.health_check.outputs.health_check_passed == 'true'
        continue-on-error: true  # Non-fatal
        env:
          ALPACA_API_KEY: ${{ secrets.ALPACA_API_KEY }}
          ALPACA_SECRET_KEY: ${{ secrets.ALPACA_SECRET_KEY }}
          PAPER_TRADING: 'true'
        run: |
          echo "üìä Updating performance log with current account data..."
          python3 scripts/update_performance_log.py

      - name: Record workflow execution
        if: always()
        run: |
          echo "üìä Recording workflow execution for health monitoring..."
          if [ "${{ job.status }}" == "success" ]; then
            python3 scripts/workflow_health_monitor.py --record weekend-crypto-trading --status success
          else
            python3 scripts/workflow_health_monitor.py --record weekend-crypto-trading --status failure
          fi

      - name: Check for state changes
        id: check_state_changes
        if: steps.check_execution.outputs.skip != 'true'
        run: |
          echo "üîç Checking for system_state.json updates..."

          # Check if system_state.json changed during execution
          if git diff --quiet data/system_state.json; then
            echo "state_changed=false" >> $GITHUB_OUTPUT
            echo "üìã No changes to system state"
          else
            echo "state_changed=true" >> $GITHUB_OUTPUT
            echo "‚úÖ System state updated after crypto trading"

            # Show summary of changes
            echo "Changes detected:"
            git diff --stat data/system_state.json
          fi

      - name: Commit system state updates
        if: steps.check_execution.outputs.skip != 'true' && steps.check_state_changes.outputs.state_changed == 'true'
        continue-on-error: true  # Non-blocking - trading execution is the priority
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
        run: |
          echo "üíæ Committing system_state.json updates..."

          # Verify PAT is available
          if [ -z "$GH_PAT" ]; then
            echo "‚ùå ERROR: GH_PAT secret not available"
            exit 1
          fi

          git config user.name "GitHub Actions Bot"
          git config user.email "actions@github.com"

          # Configure git to use PAT for authentication
          git remote set-url origin "https://x-access-token:${GH_PAT}@github.com/${{ github.repository }}.git"

          # Stage all data files first (before any pull/rebase operations)
          git add data/system_state.json
          git add data/trades_*.json 2>/dev/null || true

          # Check if there are changes to commit
          if git diff --cached --quiet; then
            echo "üìã No changes staged for commit"
            exit 0
          fi

          # Create commit with trading execution details
          git commit -m "chore: Update system state after weekend crypto trading [skip ci]"

          # Fetch and rebase before push
          git fetch origin main
          git rebase origin/main || {
            echo "‚ö†Ô∏è  Rebase conflict - resolving by keeping our changes..."
            git checkout --theirs data/system_state.json
            git checkout --theirs data/trades_*.json 2>/dev/null || true
            git add data/
            git rebase --continue || git rebase --abort
          }

          # Push changes with retry
          MAX_RETRIES=3
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if git push origin main; then
              echo "‚úÖ System state changes committed and pushed"
              exit 0
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "‚ö†Ô∏è  Push failed, retrying ($RETRY_COUNT/$MAX_RETRIES)..."
              sleep 2
              git pull --rebase origin main || true
            fi
          done

          echo "‚ùå Failed to push after $MAX_RETRIES attempts"
          exit 1

      - name: Verify Crypto Trade Execution
        # HARD FAILURE if no trade executed - Dec 14, 2025 fix
        env:
          ALPACA_API_KEY: ${{ secrets.ALPACA_API_KEY }}
          ALPACA_SECRET_KEY: ${{ secrets.ALPACA_SECRET_KEY }}
        run: |
          echo "üîç Verifying crypto trade was executed..."
          TODAY=$(date +%Y-%m-%d)
          TRADE_FILE="data/trades_${TODAY}.json"

          if [ ! -f "$TRADE_FILE" ]; then
            echo "‚ùå CRITICAL: No trade file created today ($TRADE_FILE)"
            echo "‚ùå The system MUST execute a trade every day. This is a hard failure."
            exit 1
          fi

          TRADE_COUNT=$(python3 -c "import json; print(len(json.load(open('$TRADE_FILE'))))" 2>/dev/null || echo "0")
          if [ "$TRADE_COUNT" -eq "0" ]; then
            echo "‚ùå CRITICAL: Trade file exists but contains 0 trades"
            exit 1
          fi

          echo "‚úÖ Trade verification passed: $TRADE_COUNT trade(s) in $TRADE_FILE"

      - name: Update Progress Dashboard Wiki
        # Always update dashboard, even if trading was skipped
        # This ensures dashboard shows latest data regardless of trading execution
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üìä Generating progress dashboard..."
          set -e  # Exit on error for critical steps

          python3 scripts/generate_world_class_dashboard_enhanced.py || python3 scripts/generate_world_class_dashboard.py || python3 scripts/generate_progress_dashboard.py

          # Verify dashboard file exists
          if [ ! -f "wiki/Progress-Dashboard.md" ]; then
            echo "‚ùå ERROR: Dashboard file not found at wiki/Progress-Dashboard.md"
            exit 1
          fi

          echo "üìù Updating GitHub Wiki..."

          # Use PAT_TOKEN if available (has wiki write permissions), fallback to GITHUB_TOKEN
          WIKI_TOKEN="${GH_TOKEN:-${GITHUB_TOKEN}}"
          if [ -z "$WIKI_TOKEN" ]; then
            echo "‚ö†Ô∏è  No authentication token available - skipping wiki update"
            echo "üìã Dashboard generated locally at: wiki/Progress-Dashboard.md"
            exit 0
          fi

          # Clone wiki repository with retry logic
          WIKI_DIR="wiki_repo"
          MAX_RETRIES=3
          RETRY_COUNT=0

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if git clone "https://x-access-token:${WIKI_TOKEN}@github.com/IgorGanapolsky/trading.wiki.git" "$WIKI_DIR" 2>/dev/null; then
              echo "‚úÖ Wiki repository exists, updating..."
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "‚ö†Ô∏è  Clone failed, retrying ($RETRY_COUNT/$MAX_RETRIES)..."
                sleep 5
                rm -rf "$WIKI_DIR"
              else
                echo "‚ö†Ô∏è  Wiki repository doesn't exist yet - will create on first push"
                mkdir -p "$WIKI_DIR"
                cd "$WIKI_DIR"
                git init
                git config user.name "GitHub Actions Bot"
                git config user.email "actions@github.com"
                git remote add origin "https://x-access-token:${WIKI_TOKEN}@github.com/IgorGanapolsky/trading.wiki.git"
                cd ..
                break
              fi
            fi
          done

          # Copy generated dashboard and home page to wiki
          cp wiki/Progress-Dashboard.md "$WIKI_DIR/Progress-Dashboard.md"
          if [ -f wiki/Home.md ]; then
            cp wiki/Home.md "$WIKI_DIR/Home.md"
          fi

          # Commit and push to wiki with retry logic
          cd "$WIKI_DIR"
          git config user.name "GitHub Actions Bot"
          git config user.email "actions@github.com"
          git add -A

          if ! git diff --staged --quiet || [ -z "$(git log --oneline 2>/dev/null)" ]; then
            if [ -z "$(git log --oneline 2>/dev/null)" ]; then
              COMMIT_MSG="üéâ Initial wiki setup - Progress Dashboard and Home page"
            else
              COMMIT_MSG="üìä Auto-update progress dashboard (weekend crypto) - $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
            fi

            git commit -m "$COMMIT_MSG" || echo "No changes to commit"

            # Try pushing with retry logic
            RETRY_COUNT=0
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              # Try pushing to master branch first (wiki default), then main
              if git push -u origin master 2>&1; then
                echo "‚úÖ Wiki dashboard updated successfully (master branch)!"
                break
              elif git push -u origin main 2>&1; then
                echo "‚úÖ Wiki dashboard updated successfully (main branch)!"
                break
              else
                RETRY_COUNT=$((RETRY_COUNT + 1))
                if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                  echo "‚ö†Ô∏è  Push failed, retrying ($RETRY_COUNT/$MAX_RETRIES)..."
                  sleep 5
                  git pull --rebase origin master 2>/dev/null || git pull --rebase origin main 2>/dev/null || true
                else
                  echo "‚ö†Ô∏è  Wiki push failed after $MAX_RETRIES attempts"
                  echo "üìã Dashboard file available at: wiki/Progress-Dashboard.md"
                  echo "   Wiki repository may need manual initialization:"
                  echo "   1. Visit: https://github.com/IgorGanapolsky/trading/wiki"
                  echo "   2. Click 'Create the first page'"
                  echo "   3. Name it 'Home' and save"
                  exit 1
                fi
              fi
            done
          else
            echo "üìã No changes to dashboard (already up-to-date)"
          fi

      - name: Upload execution logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: weekend-crypto-logs-${{ github.run_id }}
          path: |
            logs/*.log
            data/system_state.json
            data/trades_*.json
            wiki/Progress-Dashboard.md
          retention-days: 30
