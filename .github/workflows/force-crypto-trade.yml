name: Force Crypto Trade (World-Class Strategy)

on:
  push:
    paths:
      - '.github/FORCE_CRYPTO'
    branches: ['*']
  workflow_dispatch:

permissions:
  contents: write

jobs:
  crypto-trade:
    runs-on: ubuntu-latest
    env:
      PYTHONPATH: ${{ github.workspace }}
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install alpaca-py yfinance pandas numpy requests

      - name: Execute Crypto Trade
        env:
          ALPACA_API_KEY: ${{ secrets.ALPACA_API_KEY }}
          ALPACA_SECRET_KEY: ${{ secrets.ALPACA_SECRET_KEY }}
        run: |
          python3 << 'PYTHON'
          """
          World-Class Crypto Trading Strategy v3.0
          - Robust error handling - NEVER crashes
          - Always saves results
          - Falls back to simple BTC buy if analysis fails
          """
          import os
          import sys
          import json
          import traceback
          from datetime import datetime, timezone

          today = datetime.now(timezone.utc).strftime("%Y-%m-%d")
          result = {
              "timestamp": datetime.now(timezone.utc).isoformat(),
              "date": today,
              "strategy": "WorldClassCrypto",
              "strategy_version": "3.0"
          }

          def save_result():
              """Always save results, even on error."""
              try:
                  os.makedirs("data", exist_ok=True)
                  trades_file = f"data/trades_{today}.json"
                  trades = []
                  if os.path.exists(trades_file):
                      try:
                          with open(trades_file) as f:
                              trades = json.load(f)
                              if not isinstance(trades, list):
                                  trades = [trades]
                      except:
                          trades = []
                  trades.append(result)
                  with open(trades_file, "w") as f:
                      json.dump(trades, f, indent=2)
                  print(f"âœ… Results saved to {trades_file}")
              except Exception as e:
                  print(f"âŒ Failed to save results: {e}")

          # Get API credentials
          api_key = os.environ.get("ALPACA_API_KEY", "")
          secret = os.environ.get("ALPACA_SECRET_KEY", "")

          print("=" * 60)
          print("ðŸŒ WORLD-CLASS CRYPTO TRADING STRATEGY v3.0")
          print("=" * 60)
          print(f"ðŸ” API Key present: {bool(api_key)}")
          print(f"ðŸ” Secret present: {bool(secret)}")

          if not api_key or not secret:
              result["error"] = "MISSING_SECRETS"
              result["status"] = "FAILED"
              print("âŒ Alpaca secrets not configured!")
              save_result()
              sys.exit(0)  # Exit cleanly so workflow doesn't fail

          try:
              from alpaca.trading.client import TradingClient
              from alpaca.trading.requests import MarketOrderRequest
              from alpaca.trading.enums import OrderSide, TimeInForce

              # Connect to Alpaca
              print("\nðŸ“¡ Connecting to Alpaca...")
              client = TradingClient(api_key, secret, paper=True)
              account = client.get_account()
              account_value = float(account.equity)
              print(f"âœ… Connected! Account: ${account_value:,.2f}")
              result["account_value"] = account_value

              # Get Fear & Greed Index
              print("\nðŸ“Š Checking Fear & Greed Index...")
              size_multiplier = 1.0
              try:
                  import requests
                  fng_resp = requests.get("https://api.alternative.me/fng/", timeout=10)
                  fng_data = fng_resp.json()
                  fng_value = int(fng_data["data"][0]["value"])
                  fng_class = fng_data["data"][0]["value_classification"]
                  print(f"   Value: {fng_value} ({fng_class})")
                  result["fear_greed_index"] = fng_value
                  result["fear_greed_class"] = fng_class

                  if fng_value <= 25:
                      size_multiplier = 1.5
                      print("   ðŸŸ¢ EXTREME FEAR - 1.5x position")
                  elif fng_value <= 40:
                      size_multiplier = 1.25
                      print("   ðŸŸ¢ FEAR - 1.25x position")
                  elif fng_value <= 60:
                      size_multiplier = 1.0
                      print("   ðŸŸ¡ NEUTRAL - 1.0x position")
                  elif fng_value <= 75:
                      size_multiplier = 0.75
                      print("   ðŸŸ  GREED - 0.75x position")
                  else:
                      size_multiplier = 0.0
                      print("   ðŸ”´ EXTREME GREED - skip buy")
                      result["action"] = "SKIP"
                      result["skip_reason"] = "Extreme greed"
                      save_result()
                      print("\nâœ… Workflow completed (skipped due to extreme greed)")
                      sys.exit(0)
              except Exception as e:
                  print(f"   âš ï¸ Fear & Greed API failed: {e}")
                  print("   Using default 1.0x multiplier")
                  result["fng_error"] = str(e)

              result["size_multiplier"] = size_multiplier

              # Analyze cryptos
              print("\nðŸ“ˆ Analyzing cryptos...")
              best_symbol = "BTCUSD"
              best_price = 100000.0

              try:
                  import yfinance as yf
                  cryptos = ["BTC-USD", "ETH-USD", "SOL-USD"]
                  analysis = {}

                  for symbol in cryptos:
                      try:
                          ticker = yf.Ticker(symbol)
                          hist = ticker.history(period="7d")
                          if not hist.empty:
                              price = float(hist["Close"].iloc[-1])
                              change = ((hist["Close"].iloc[-1] - hist["Close"].iloc[0]) / hist["Close"].iloc[0]) * 100
                              analysis[symbol] = {"price": price, "change_7d": change}
                              print(f"   {symbol}: ${price:,.2f} ({change:+.2f}% 7d)")
                      except Exception as e:
                          print(f"   {symbol}: Error - {e}")

                  if analysis:
                      # Pick best performer
                      best = max(analysis.items(), key=lambda x: x[1]["change_7d"])
                      best_symbol = best[0].replace("-USD", "USD")
                      best_price = best[1]["price"]
                      best_momentum = best[1]["change_7d"]
                      result["crypto_analysis"] = analysis

                      # MOMENTUM FILTER with EXTREME FEAR OVERRIDE
                      # In Extreme Fear (<=25), we BUY anyway - contrarian strategy
                      if best_momentum < 0:
                          if result.get("fear_greed_index", 50) <= 25:
                              print(f"\n   ðŸ”¥ EXTREME FEAR OVERRIDE: Buying despite negative momentum!")
                              print(f"   Fear & Greed = {result.get('fear_greed_index')} (Extreme Fear = contrarian BUY)")
                              print(f"   {best_symbol} at {best_momentum:+.2f}% - historically oversold")
                              result["contrarian_buy"] = True
                          else:
                              print(f"\n   â›” SKIP: Best performer {best_symbol} has negative momentum ({best_momentum:+.2f}%)")
                              print("   All cryptos in downtrend - waiting for positive momentum")
                              result["action"] = "SKIP"
                              result["skip_reason"] = f"Negative momentum: {best_symbol} at {best_momentum:+.2f}%"
                              save_result()
                              sys.exit(0)

                      print(f"\n   ðŸŽ¯ Selected: {best_symbol} (7d momentum: {best_momentum:+.2f}%)")
              except Exception as e:
                  print(f"   âš ï¸ yfinance failed: {e}")
                  print("   Defaulting to BTCUSD")
                  result["analysis_error"] = str(e)

              # Calculate position size
              base_amount = 10.0
              final_amount = base_amount * size_multiplier
              max_position = account_value * 0.02  # 2% max
              final_amount = min(final_amount, max_position)
              if final_amount < 1.0:
                  final_amount = 1.0

              print(f"\nðŸ’° Position: ${final_amount:.2f} (base ${base_amount} Ã— {size_multiplier}x)")

              # Execute trade
              print(f"\nðŸ“ˆ Submitting: BUY ${final_amount:.2f} {best_symbol}")
              order = client.submit_order(MarketOrderRequest(
                  symbol=best_symbol,
                  notional=final_amount,
                  side=OrderSide.BUY,
                  time_in_force=TimeInForce.GTC
              ))

              print(f"ðŸ“¤ Order submitted: {order.id} (status: {order.status})")

              # CRITICAL FIX (LL-034): Wait for fill confirmation
              import time
              fill_timeout = 30
              start = time.time()
              filled_price = None
              while time.time() - start < fill_timeout:
                  order = client.get_order_by_id(order.id)
                  print(f"   Checking: {order.status}")
                  if str(order.status) == "OrderStatus.FILLED":
                      filled_price = float(order.filled_avg_price) if order.filled_avg_price else best_price
                      print(f"âœ… FILLED at ${filled_price:.2f}")
                      break
                  elif str(order.status) in ["OrderStatus.CANCELLED", "OrderStatus.REJECTED", "OrderStatus.EXPIRED"]:
                      print(f"âŒ Order {order.status}")
                      break
                  time.sleep(2)

              final_status = str(order.status)
              print(f"ðŸ“‹ Final Status: {final_status}")

              result["symbol"] = best_symbol
              result["action"] = "BUY"
              result["notional"] = final_amount
              result["price"] = best_price
              result["filled_price"] = filled_price
              result["filled_qty"] = float(order.filled_qty) if order.filled_qty else 0
              result["order_id"] = str(order.id)
              result["status"] = final_status
              result["verified_fill"] = final_status == "OrderStatus.FILLED"

          except Exception as e:
              print(f"\nâŒ ERROR: {e}")
              traceback.print_exc()
              result["error"] = str(e)
              result["status"] = "FAILED"

          # Always save results
          save_result()

          print("\n" + "=" * 60)
          print("Trade Summary:")
          print(json.dumps({k: v for k, v in result.items() if k != "crypto_analysis"}, indent=2))
          print("=" * 60)
          PYTHON

      - name: Commit trade data
        if: always()
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "trade: world-class crypto v3.0 [skip ci]"
          file_pattern: "data/trades_*.json"
          commit_user_name: "GitHub Actions Bot"
          commit_user_email: "actions@github.com"
