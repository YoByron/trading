name: Close Put Position

# Fixes Bug #2033:
# 1. Use EXACT symbol matching (not partial)
# 2. Detect position side and use correct order side
# 3. Add PDT pre-check

on:
  workflow_dispatch:
    inputs:
      symbol:
        description: "EXACT option symbol to close (e.g., SPY260220P00653000)"
        required: true
      quantity:
        description: "Contracts to close"
        required: true
        default: "1"

permissions:
  contents: write

# CRITICAL: Global trade concurrency - prevents race conditions (LL-281)
concurrency:
  group: global-trade-execution
  cancel-in-progress: false

jobs:
  close-position:
    name: Close Option Position
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install alpaca-py

      - name: Close Position
        id: close
        env:
          ALPACA_API_KEY: ${{ secrets.ALPACA_PAPER_TRADING_5K_API_KEY }}
          ALPACA_SECRET_KEY: ${{ secrets.ALPACA_PAPER_TRADING_5K_API_SECRET }}
          TARGET_SYMBOL: ${{ inputs.symbol }}
          TARGET_QTY: ${{ inputs.quantity }}
        run: |
          python3 << 'PYTHON_SCRIPT'
          import os
          from datetime import datetime, date
          from alpaca.trading.client import TradingClient
          from alpaca.trading.requests import MarketOrderRequest
          from alpaca.trading.enums import OrderSide, TimeInForce

          target_symbol = os.environ['TARGET_SYMBOL'].strip().upper()  # Normalize to match Alpaca format
          target_qty = int(os.environ['TARGET_QTY'])

          print(f"=== CLOSE POSITION ===")
          print(f"Target symbol: {target_symbol}")
          print(f"Target quantity: {target_qty}")

          client = TradingClient(
              os.environ['ALPACA_API_KEY'],
              os.environ['ALPACA_SECRET_KEY'],
              paper=True
          )

          # Get all positions
          positions = client.get_all_positions()
          print(f"Total positions: {len(positions)}")

          # FIX #1: EXACT symbol matching (not partial)
          target_position = None
          for pos in positions:
              if pos.symbol == target_symbol:  # EXACT match only
                  target_position = pos
                  break

          if not target_position:
              print(f"::error::Position {target_symbol} NOT FOUND")
              print("Available positions:")
              for pos in positions:
                  print(f"  - {pos.symbol} (qty: {pos.qty})")
              exit(1)

          print(f"Found position: {target_position.symbol}")
          print(f"  Quantity: {target_position.qty}")
          print(f"  Side: {target_position.side}")
          print(f"  Unrealized P/L: ${target_position.unrealized_pl}")

          # FIX #2: Detect position side and use correct order side
          current_qty = float(target_position.qty)
          
          if current_qty > 0:
              # LONG position -> SELL to close
              order_side = OrderSide.SELL
              print(f"Position is LONG ({current_qty}) -> Using SELL to close")
          else:
              # SHORT position -> BUY to close
              order_side = OrderSide.BUY
              current_qty = abs(current_qty)
              print(f"Position is SHORT ({current_qty}) -> Using BUY to close")

          # Validate quantity
          if target_qty > current_qty:
              print(f"::warning::Requested {target_qty} but only {current_qty} available")
              target_qty = int(current_qty)

          # FIX #3: PDT check (informational)
          account = client.get_account()
          if float(account.equity) < 25000:
              # Check if position was opened today
              print(f"::warning::Account under $25K - PDT rules may apply")
              print("If position was opened today, this close will count as a day trade")

          # Submit close order
          print(f"Submitting {order_side.value} order for {target_qty} {target_symbol}")
          
          order_request = MarketOrderRequest(
              symbol=target_symbol,
              qty=target_qty,
              side=order_side,
              time_in_force=TimeInForce.DAY
          )

          try:
              order = client.submit_order(order_request)
              print(f"âœ… Order submitted: {order.id}")
              print(f"   Status: {order.status}")
              
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write(f"order_id={order.id}\n")
                  f.write(f"status={order.status}\n")
          except Exception as e:
              print(f"::error::Order failed: {e}")
              exit(1)
          PYTHON_SCRIPT

      - name: Update system state
        if: success()
        run: |
          echo "Position close order submitted successfully"
          echo "Run sync-alpaca-status.yml to update system state"
