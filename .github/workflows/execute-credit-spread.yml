name: Execute Credit Spread

on:
  schedule:
    # Run at 9:35 AM ET on weekdays (covers EST/EDT)
    - cron: '35 13,14 * * 1-5'
  workflow_dispatch:
    inputs:
      symbol:
        description: "Underlying symbol (SPY/IWM per $100K success)"
        required: true
        default: "SPY"
        type: choice
        options:
          - SPY
          - IWM
      spread_width:
        description: "Spread width in dollars"
        required: true
        default: "5"
      quantity:
        description: "Number of spreads"
        required: true
        default: "1"

env:
  ALPACA_API_KEY: ${{ secrets.ALPACA_PAPER_TRADING_5K_API_KEY }}
  ALPACA_API_SECRET: ${{ secrets.ALPACA_PAPER_TRADING_5K_API_SECRET }}
  ALPACA_BASE_URL: "https://paper-api.alpaca.markets"

jobs:
  execute-spread:
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          pip install alpaca-py requests

      - name: Execute Bull Put Credit Spread
        env:
          INPUT_SYMBOL: ${{ inputs.symbol || 'SPY' }}
          INPUT_SPREAD_WIDTH: ${{ inputs.spread_width || '5' }}
          INPUT_QUANTITY: ${{ inputs.quantity || '1' }}
        run: |
          python3 << 'PYTHON_SCRIPT'
          import os
          import json
          from datetime import datetime, timedelta
          from alpaca.trading.client import TradingClient
          from alpaca.trading.enums import OrderSide, TimeInForce, OrderType
          from alpaca.data.historical import StockHistoricalDataClient
          from alpaca.data.requests import StockLatestQuoteRequest

          # Config from environment
          symbol = os.environ.get("INPUT_SYMBOL", "SPY")
          spread_width = int(os.environ.get("INPUT_SPREAD_WIDTH", "5"))
          quantity = int(os.environ.get("INPUT_QUANTITY", "1"))

          print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
          print("üìä CREDIT SPREAD EXECUTION")
          print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
          print(f"Symbol: {symbol}")
          print(f"Spread Width: ${spread_width}")
          print(f"Quantity: {quantity}")
          print()

          # Initialize clients
          api_key = os.environ["ALPACA_API_KEY"]
          api_secret = os.environ["ALPACA_API_SECRET"]

          trading_client = TradingClient(api_key, api_secret, paper=True)
          data_client = StockHistoricalDataClient(api_key, api_secret)

          # Get account info
          account = trading_client.get_account()
          print(f"Account Equity: ${float(account.equity):,.2f}")
          print(f"Buying Power: ${float(account.buying_power):,.2f}")
          print()

          # Calculate collateral needed
          collateral_needed = spread_width * 100 * quantity
          print(f"Collateral Needed: ${collateral_needed}")

          if float(account.buying_power) < collateral_needed:
              print(f"‚ùå Insufficient buying power!")
              print(f"   Need: ${collateral_needed}, Have: ${float(account.buying_power):,.2f}")
              exit(1)

          # Step 1: Get current stock price
          print()
          print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
          print("üìà GETTING CURRENT PRICE")
          print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")

          try:
              quote_request = StockLatestQuoteRequest(symbol_or_symbols=symbol)
              quote = data_client.get_stock_latest_quote(quote_request)
              current_price = float(quote[symbol].ask_price)
              print(f"Current {symbol} price: ${current_price:.2f}")
          except Exception as e:
              print(f"Error getting quote: {e}")
              # Fallback prices
              fallback = {"SPY": 590.0, "IWM": 220.0, "F": 10.0, "SOFI": 15.0, "T": 22.0}
              current_price = fallback.get(symbol, 15.0)
              print(f"Using fallback price: ${current_price:.2f}")

          # Step 2: Query available options
          print()
          print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
          print("üîç DISCOVERING AVAILABLE OPTIONS")
          print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")

          from alpaca.trading.requests import GetOptionContractsRequest
          from alpaca.trading.enums import AssetStatus, ContractType

          # BUGFIX Jan 14, 2026: Use 30-45 DTE per CLAUDE.md strategy
          # Also use 30-delta (OTM) not ATM per Phil Town margin of safety
          today = datetime.now()
          min_expiry = (today + timedelta(days=30)).strftime("%Y-%m-%d")
          max_expiry = (today + timedelta(days=45)).strftime("%Y-%m-%d")

          # For SPY/IWM: target 30-delta = roughly 5-7% OTM
          # SPY at 590 -> 30-delta put ~ 555-565
          # IWM at 220 -> 30-delta put ~ 205-210
          target_delta_pct = 0.05  # 5% OTM for ~30 delta

          try:
              # Filter strikes to reduce data - only OTM puts near our target
              min_strike = current_price * 0.90  # 10% below current
              max_strike = current_price * 0.98  # 2% below current (OTM)

              print(f"Filtering strikes: ${min_strike:.0f} to ${max_strike:.0f}")

              req = GetOptionContractsRequest(
                  underlying_symbols=[symbol],
                  status=AssetStatus.ACTIVE,
                  expiration_date_gte=min_expiry,
                  expiration_date_lte=max_expiry,
                  type=ContractType.PUT,
                  strike_price_gte=str(min_strike),
                  strike_price_lte=str(max_strike),
              )
              contracts = trading_client.get_option_contracts(req)

              if not contracts or not contracts.option_contracts:
                  print(f"‚ùå No put options found for {symbol}")
                  print(f"   Date range: {min_expiry} to {max_expiry}")
                  print(f"   Strike range: ${min_strike:.0f} to ${max_strike:.0f}")
                  # Try without strike filter as fallback
                  print("Retrying without strike filter...")
                  req = GetOptionContractsRequest(
                      underlying_symbols=[symbol],
                      status=AssetStatus.ACTIVE,
                      expiration_date_gte=min_expiry,
                      expiration_date_lte=max_expiry,
                      type=ContractType.PUT,
                  )
                  contracts = trading_client.get_option_contracts(req)
                  if not contracts or not contracts.option_contracts:
                      print("‚ùå Still no options found. Exiting.")
                      exit(1)

              puts = contracts.option_contracts
              print(f"Found {len(puts)} put options")

              # Group by expiration
              by_expiry = {}
              for p in puts:
                  exp = str(p.expiration_date)
                  strike = float(p.strike_price)
                  # Only keep OTM puts (strike < current price)
                  if strike >= current_price:
                      continue
                  if exp not in by_expiry:
                      by_expiry[exp] = []
                  by_expiry[exp].append(p)

              if not by_expiry:
                  print("‚ùå No OTM puts found after filtering")
                  exit(1)

              # Pick nearest expiration with enough strikes
              sorted_expiries = sorted(by_expiry.keys())
              target_expiry = None
              for exp in sorted_expiries:
                  if len(by_expiry[exp]) >= 4:
                      target_expiry = exp
                      break

              if not target_expiry:
                  target_expiry = sorted_expiries[0]

              available_puts = by_expiry[target_expiry]
              strikes = sorted(set(float(p.strike_price) for p in available_puts))

              print(f"Using expiration: {target_expiry}")
              print(f"Available OTM strikes ({len(strikes)}): {strikes[:10]}...")

              # Step 3: Find 30-delta short strike (~5% OTM)
              target_short = current_price * (1 - target_delta_pct)
              short_strike = min(strikes, key=lambda x: abs(x - target_short))
              print(f"Target 30-delta strike: ${target_short:.2f}, Selected: ${short_strike}")

              # Step 4: Find long strike (spread_width below short)
              target_long = short_strike - spread_width
              available_longs = [s for s in strikes if s < short_strike]

              if not available_longs:
                  print(f"‚ùå No strikes below short strike ${short_strike}")
                  exit(1)

              long_strike = min(available_longs, key=lambda x: abs(x - target_long))

              actual_width = short_strike - long_strike

              # Get contract symbols
              short_contract = next((p for p in available_puts if float(p.strike_price) == short_strike), None)
              long_contract = next((p for p in available_puts if float(p.strike_price) == long_strike), None)

              if not short_contract or not long_contract:
                  print(f"‚ùå Could not find contracts for strikes {short_strike}/{long_strike}")
                  exit(1)

              short_symbol = short_contract.symbol
              long_symbol = long_contract.symbol

              print()
              print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
              print("üìã SPREAD DETAILS (30-DELTA TARGET)")
              print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
              print(f"Current Price: ${current_price:.2f}")
              print(f"Expiration: {target_expiry}")
              print(f"Short Put (SELL): {short_symbol} @ ${short_strike} ({((current_price - short_strike)/current_price)*100:.1f}% OTM)")
              print(f"Long Put (BUY): {long_symbol} @ ${long_strike}")
              print(f"Spread Width: ${actual_width}")
              print(f"Max Loss: ${actual_width * 100 * quantity}")

          except Exception as e:
              print(f"‚ùå Error discovering options: {e}")
              import traceback
              traceback.print_exc()
              exit(1)

          # Step 5: Execute the spread
          print()
          print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
          print("üöÄ EXECUTING ORDERS")
          print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")

          try:
              # Sell the short put (collect premium)
              print(f"Selling {quantity} x {short_symbol}...")
              from alpaca.trading.requests import MarketOrderRequest
              short_order_request = MarketOrderRequest(
                  symbol=short_symbol,
                  qty=quantity,
                  side=OrderSide.SELL,
                  type=OrderType.MARKET,
                  time_in_force=TimeInForce.DAY
              )
              short_order = trading_client.submit_order(short_order_request)
              print(f"‚úÖ Short put order submitted: {short_order.id}")
              print(f"   Status: {short_order.status}")

              # Buy the long put (protection)
              print(f"Buying {quantity} x {long_symbol}...")
              long_order_request = MarketOrderRequest(
                  symbol=long_symbol,
                  qty=quantity,
                  side=OrderSide.BUY,
                  type=OrderType.MARKET,
                  time_in_force=TimeInForce.DAY
              )
              long_order = trading_client.submit_order(long_order_request)
              print(f"‚úÖ Long put order submitted: {long_order.id}")
              print(f"   Status: {long_order.status}")

              print()
              print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
              print("‚úÖ CREDIT SPREAD EXECUTED SUCCESSFULLY!")
              print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
              print(f"Strategy: Bull Put Spread on {symbol}")
              print(f"Expiration: {target_expiry}")
              print(f"Short: ${short_strike} | Long: ${long_strike}")
              print(f"Width: ${actual_width} | Qty: {quantity}")

          except Exception as e:
              print(f"‚ùå Error executing spread: {e}")
              import traceback
              traceback.print_exc()
              exit(1)

          PYTHON_SCRIPT

      - name: Record trade in system state
        if: success()
        run: |
          echo "Credit spread executed at $(date)"

