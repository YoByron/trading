name: Auto Position Compliance Check

# DISABLED Jan 23, 2026 - CONTRIBUTED TO $22.61 LOSS FROM SHARE CHURNING
# LL-298: Running every 30 min caused excessive trades and bid/ask spread losses
# DO NOT RE-ENABLE without CEO approval

# Original purpose: Automatically monitors and fixes position limit violations
# Was running every 30 minutes during market hours

on:
  # DISABLED - schedule removed to stop losses
  # schedule:
  #   # Every 30 minutes during market hours (9:30 AM - 4 PM ET = 14:30 - 21:00 UTC)
  #   - cron: '0,30 14-20 * * 1-5'  # Mon-Fri, 9:30 AM - 4 PM ET
  workflow_dispatch:  # Manual trigger only now

permissions:
  contents: write

# CRITICAL: Global trade concurrency - prevents race conditions (LL-281)
# All workflows that can execute trades MUST use this same concurrency group
concurrency:
  group: global-trade-execution
  cancel-in-progress: false

jobs:
  check-compliance:
    name: Position Compliance Check
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install alpaca-py requests

      - name: Set PDT Check to Entry Only (Bypass for Closing)
        env:
          ALPACA_API_KEY: ${{ secrets.ALPACA_PAPER_TRADING_5K_API_KEY }}
          ALPACA_SECRET_KEY: ${{ secrets.ALPACA_PAPER_TRADING_5K_API_SECRET }}
        run: |
          python3 << 'EOF'
          import os
          import requests

          base_url = "https://paper-api.alpaca.markets"
          headers = {
              "APCA-API-KEY-ID": os.environ['ALPACA_API_KEY'],
              "APCA-API-SECRET-KEY": os.environ['ALPACA_SECRET_KEY'],
          }

          print("Setting pdt_check to 'entry' (allow closing trades)...")
          resp = requests.patch(
              f"{base_url}/v2/account/configurations",
              headers=headers,
              json={"pdt_check": "entry"}
          )
          print(f"Response: {resp.status_code} - {resp.text[:100] if resp.text else 'OK'}")
          EOF

      - name: Check and Fix Position Compliance
        env:
          ALPACA_API_KEY: ${{ secrets.ALPACA_PAPER_TRADING_5K_API_KEY }}
          ALPACA_SECRET_KEY: ${{ secrets.ALPACA_PAPER_TRADING_5K_API_SECRET }}
        run: |
          python3 << 'EOF'
          import os
          import sys
          from datetime import datetime
          from alpaca.trading.client import TradingClient
          from alpaca.trading.requests import MarketOrderRequest
          from alpaca.trading.enums import OrderSide, TimeInForce

          print("=" * 60)
          print(f"POSITION COMPLIANCE CHECK - {datetime.now()}")
          print("=" * 60)

          client = TradingClient(
              os.environ['ALPACA_API_KEY'],
              os.environ['ALPACA_SECRET_KEY'],
              paper=True
          )

          # Get account
          account = client.get_account()
          equity = float(account.equity)
          print(f"\nAccount Equity: ${equity:,.2f}")

          # Get positions
          positions = client.get_all_positions()
          print(f"Total Positions: {len(positions)}")

          # Analyze SPY puts (options only, not stock)
          puts = {}
          for pos in positions:
              symbol = pos.symbol
              # Option symbols are like SPY260220P00653000 (21+ chars)
              # Stock "SPY" is only 3 chars - must filter it out
              if len(symbol) > 10 and "P" in symbol and symbol.startswith("SPY"):
                  strike = int(symbol[-8:]) / 1000
                  puts[strike] = {
                      "symbol": symbol,
                      "qty": float(pos.qty),
                      "side": "LONG" if float(pos.qty) > 0 else "SHORT",
                      "pl": float(pos.unrealized_pl),
                  }

          print(f"\nSPY Put Positions: {len(puts)}")
          for strike, pos in sorted(puts.items()):
              print(f"  ${strike:.0f}: {pos['side']} | P/L: ${pos['pl']:+.2f}")

          # Find spreads
          spreads = []
          sorted_strikes = sorted(puts.keys())
          used_strikes = set()

          for i, strike in enumerate(sorted_strikes):
              if strike in used_strikes:
                  continue
              pos = puts[strike]
              if pos["side"] == "SHORT":
                  # Look for long leg
                  for j in range(i - 1, -1, -1):
                      lower = sorted_strikes[j]
                      if lower in used_strikes:
                          continue
                      if puts[lower]["side"] == "LONG":
                          spreads.append({
                              "short": strike,
                              "short_symbol": pos["symbol"],
                              "long": lower,
                              "long_symbol": puts[lower]["symbol"],
                              "pl": pos["pl"] + puts[lower]["pl"],
                          })
                          used_strikes.add(strike)
                          used_strikes.add(lower)
                          break

          print(f"\nIdentified Spreads: {len(spreads)}")
          for sp in spreads:
              print(f"  ${sp['short']:.0f}/${sp['long']:.0f} | P/L: ${sp['pl']:+.2f}")

          # Check compliance - COUNT TOTAL CONTRACTS not just spreads
          MAX_CONTRACTS = 4  # CLAUDE.md: 1 iron condor = 4 contracts max
          MAX_RISK_PCT = 15  # CLAUDE.md: 15% max portfolio risk

          # Count ALL contracts
          total_contracts = sum(abs(p["qty"]) for p in puts.values())
          total_risk = total_contracts * 100  # Approximate $100 per contract
          risk_pct = (total_risk / equity * 100) if equity > 0 else 0

          print(f"\n{'=' * 60}")
          print("COMPLIANCE CHECK (FIXED - counts contracts not spreads)")
          print(f"{'=' * 60}")
          print(f"Total Contracts: {total_contracts} (max: {MAX_CONTRACTS})")
          print(f"Spreads identified: {len(spreads)}")
          print(f"Risk: {risk_pct:.1f}% (max: {MAX_RISK_PCT}%)")

          if total_contracts <= MAX_CONTRACTS and risk_pct <= MAX_RISK_PCT:
              print("\n✅ COMPLIANT - No action needed")
              sys.exit(0)

          # NON-COMPLIANT - CLOSE ALL EXCESS
          excess_contracts = int(total_contracts - MAX_CONTRACTS)
          print(f"\n⚠️ NON-COMPLIANT - Have {total_contracts} contracts, max is {MAX_CONTRACTS}")
          print(f"Need to close {excess_contracts} excess contracts")

          # Sort positions by P/L (close worst first - most negative P/L first)
          positions_by_pl = sorted(puts.items(), key=lambda x: x[1]["pl"])

          orders = []
          contracts_closed = 0
          for strike, pos in positions_by_pl:
              if contracts_closed >= excess_contracts:
                  break

              qty_to_close = min(abs(pos["qty"]), excess_contracts - contracts_closed)
              side_to_close = OrderSide.SELL if pos["side"] == "LONG" else OrderSide.BUY

              print(f"\nClosing {qty_to_close}x ${strike:.0f} put ({pos['side']}, P/L: ${pos['pl']:+.2f})")

              try:
                  order = client.submit_order(MarketOrderRequest(
                      symbol=pos["symbol"],
                      qty=int(qty_to_close),
                      side=side_to_close,
                      time_in_force=TimeInForce.DAY,
                  ))
                  print(f"  ✅ {side_to_close.value} {pos['symbol']}: {order.id}")
                  orders.append(order.id)
                  contracts_closed += qty_to_close
              except Exception as e:
                  print(f"  ❌ Failed: {e}")

          print(f"\n{'=' * 60}")
          print(f"SUBMITTED {len(orders)} CLOSE ORDERS")
          print(f"{'=' * 60}")
          EOF

      - name: Reset PDT Check to Both (Safety)
        if: always()
        env:
          ALPACA_API_KEY: ${{ secrets.ALPACA_PAPER_TRADING_5K_API_KEY }}
          ALPACA_SECRET_KEY: ${{ secrets.ALPACA_PAPER_TRADING_5K_API_SECRET }}
        run: |
          python3 << 'EOF'
          import os
          import requests

          base_url = "https://paper-api.alpaca.markets"
          headers = {
              "APCA-API-KEY-ID": os.environ['ALPACA_API_KEY'],
              "APCA-API-SECRET-KEY": os.environ['ALPACA_SECRET_KEY'],
          }

          print("Resetting pdt_check to 'both' for safety...")
          resp = requests.patch(
              f"{base_url}/v2/account/configurations",
              headers=headers,
              json={"pdt_check": "both"}
          )
          print(f"Response: {resp.status_code}")
          EOF

      - name: Trigger State Sync
        if: success()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'sync-system-state.yml',
                ref: 'main'
              });
              console.log('Triggered sync-system-state.yml');
            } catch (error) {
              console.log('Could not trigger sync:', error.message);
            }
