name: Auto Position Compliance Check

# Automatically monitors and fixes position limit violations
# Runs every 30 minutes during market hours

on:
  schedule:
    # Every 30 minutes during market hours (9:30 AM - 4 PM ET = 14:30 - 21:00 UTC)
    - cron: '0,30 14-20 * * 1-5'  # Mon-Fri, 9:30 AM - 4 PM ET
  workflow_dispatch:  # Allow manual trigger

permissions:
  contents: write

jobs:
  check-compliance:
    name: Position Compliance Check
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install alpaca-py

      - name: Check and Fix Position Compliance
        env:
          ALPACA_API_KEY: ${{ secrets.ALPACA_PAPER_TRADING_5K_API_KEY }}
          ALPACA_SECRET_KEY: ${{ secrets.ALPACA_PAPER_TRADING_5K_API_SECRET }}
        run: |
          python3 << 'EOF'
          import os
          import sys
          from datetime import datetime
          from alpaca.trading.client import TradingClient
          from alpaca.trading.requests import MarketOrderRequest
          from alpaca.trading.enums import OrderSide, TimeInForce

          print("=" * 60)
          print(f"POSITION COMPLIANCE CHECK - {datetime.now()}")
          print("=" * 60)

          client = TradingClient(
              os.environ['ALPACA_API_KEY'],
              os.environ['ALPACA_SECRET_KEY'],
              paper=True
          )

          # Get account
          account = client.get_account()
          equity = float(account.equity)
          print(f"\nAccount Equity: ${equity:,.2f}")

          # Get positions
          positions = client.get_all_positions()
          print(f"Total Positions: {len(positions)}")

          # Analyze SPY puts
          puts = {}
          for pos in positions:
              symbol = pos.symbol
              if "P" in symbol and symbol.startswith("SPY"):
                  strike = int(symbol[-8:]) / 1000
                  puts[strike] = {
                      "symbol": symbol,
                      "qty": float(pos.qty),
                      "side": "LONG" if float(pos.qty) > 0 else "SHORT",
                      "pl": float(pos.unrealized_pl),
                  }

          print(f"\nSPY Put Positions: {len(puts)}")
          for strike, pos in sorted(puts.items()):
              print(f"  ${strike:.0f}: {pos['side']} | P/L: ${pos['pl']:+.2f}")

          # Find spreads
          spreads = []
          sorted_strikes = sorted(puts.keys())
          used_strikes = set()

          for i, strike in enumerate(sorted_strikes):
              if strike in used_strikes:
                  continue
              pos = puts[strike]
              if pos["side"] == "SHORT":
                  # Look for long leg
                  for j in range(i - 1, -1, -1):
                      lower = sorted_strikes[j]
                      if lower in used_strikes:
                          continue
                      if puts[lower]["side"] == "LONG":
                          spreads.append({
                              "short": strike,
                              "short_symbol": pos["symbol"],
                              "long": lower,
                              "long_symbol": puts[lower]["symbol"],
                              "pl": pos["pl"] + puts[lower]["pl"],
                          })
                          used_strikes.add(strike)
                          used_strikes.add(lower)
                          break

          print(f"\nIdentified Spreads: {len(spreads)}")
          for sp in spreads:
              print(f"  ${sp['short']:.0f}/${sp['long']:.0f} | P/L: ${sp['pl']:+.2f}")

          # Check compliance
          MAX_SPREADS = 1  # CLAUDE.md: 1 iron condor at a time
          MAX_RISK_PCT = 15  # CLAUDE.md: 15% max portfolio risk

          total_risk = len(spreads) * 500  # $5-wide spreads
          risk_pct = (total_risk / equity * 100) if equity > 0 else 0

          print(f"\n{'=' * 60}")
          print("COMPLIANCE CHECK")
          print(f"{'=' * 60}")
          print(f"Spreads: {len(spreads)} (max: {MAX_SPREADS})")
          print(f"Risk: {risk_pct:.1f}% (max: {MAX_RISK_PCT}%)")

          if len(spreads) <= MAX_SPREADS and risk_pct <= MAX_RISK_PCT:
              print("\n✅ COMPLIANT - No action needed")
              sys.exit(0)

          # NON-COMPLIANT - Close excess
          excess = len(spreads) - MAX_SPREADS
          print(f"\n⚠️ NON-COMPLIANT - Closing {excess} excess spread(s)")

          # Sort by P/L (close worst first)
          spreads_to_close = sorted(spreads, key=lambda x: x["pl"])[:excess]

          orders = []
          for sp in spreads_to_close:
              print(f"\nClosing ${sp['short']:.0f}/${sp['long']:.0f} spread (P/L: ${sp['pl']:+.2f})")

              # Buy to close short
              try:
                  order = client.submit_order(MarketOrderRequest(
                      symbol=sp["short_symbol"],
                      qty=1,
                      side=OrderSide.BUY,
                      time_in_force=TimeInForce.DAY,
                  ))
                  print(f"  ✅ BUY {sp['short_symbol']}: {order.id}")
                  orders.append(order.id)
              except Exception as e:
                  print(f"  ❌ Failed: {e}")

              # Sell to close long
              try:
                  order = client.submit_order(MarketOrderRequest(
                      symbol=sp["long_symbol"],
                      qty=1,
                      side=OrderSide.SELL,
                      time_in_force=TimeInForce.DAY,
                  ))
                  print(f"  ✅ SELL {sp['long_symbol']}: {order.id}")
                  orders.append(order.id)
              except Exception as e:
                  print(f"  ❌ Failed: {e}")

          print(f"\n{'=' * 60}")
          print(f"SUBMITTED {len(orders)} CLOSE ORDERS")
          print(f"{'=' * 60}")
          EOF

      - name: Trigger State Sync
        if: success()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'sync-system-state.yml',
                ref: 'main'
              });
              console.log('Triggered sync-system-state.yml');
            } catch (error) {
              console.log('Could not trigger sync:', error.message);
            }
