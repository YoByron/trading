name: Sync Alpaca Status

# Sync frequency:
# - Every 15 minutes during peak hours (10 AM - 3 PM ET = 15-20 UTC)
# - Every 30 minutes during market open/close (9:30-10 AM, 3-4 PM ET)
# - Once daily on weekends to maintain freshness
# FIX (Jan 16, 2026): Increased frequency to reduce staleness
# FIX (Jan 22, 2026): Consolidated from 3 separate sync workflows (hourly-state-sync, sync-system-state)
on:
  schedule:
    - cron: '*/15 15-19 * * 1-5'  # Every 15 min, 10 AM - 3 PM ET (peak hours)
    - cron: '30,0 14,20 * * 1-5'  # Every 30 min at market open (9:30 AM) and close (4 PM)
    - cron: '0 15 * * 0,6'        # Once daily on weekends at 10 AM ET
  workflow_dispatch:  # Manual trigger
    inputs:
      force_sync:
        description: 'Force sync even if no changes'
        required: false
        default: 'false'
        type: boolean

permissions:
  contents: write

jobs:
  sync:
    name: Sync Paper Account Status
    runs-on: ubuntu-latest
    timeout-minutes: 3

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install alpaca-py

      - name: Sync Alpaca Status
        env:
          ALPACA_API_KEY: ${{ secrets.ALPACA_PAPER_TRADING_30K_API_KEY }}
          ALPACA_SECRET_KEY: ${{ secrets.ALPACA_PAPER_TRADING_30K_API_SECRET }}
        run: |
          python3 << 'EOF'
          import os
          import json
          from datetime import datetime, timezone
          from pathlib import Path
          from alpaca.trading.client import TradingClient

          api_key = os.environ['ALPACA_API_KEY']
          secret_key = os.environ['ALPACA_SECRET_KEY']

          print("=" * 60)
          print("ALPACA PAPER ACCOUNT SYNC")
          print(f"Timestamp: {datetime.now(timezone.utc).isoformat()}")
          print("=" * 60)

          client = TradingClient(api_key, secret_key, paper=True)

          # Get account
          account = client.get_account()
          equity = float(account.equity)
          cash = float(account.cash)
          buying_power = float(account.buying_power)
          last_equity = float(account.last_equity)
          today_pl = equity - last_equity

          print(f"\nAccount Status:")
          print(f"  Equity: ${equity:,.2f}")
          print(f"  Cash: ${cash:,.2f}")
          print(f"  Buying Power: ${buying_power:,.2f}")
          print(f"  Today P/L: ${today_pl:,.2f}")

          # Get positions
          positions = client.get_all_positions()
          print(f"\nPositions ({len(positions)}):")

          position_list = []
          total_unrealized = 0
          for pos in positions:
              unrealized = float(pos.unrealized_pl)
              total_unrealized += unrealized
              print(f"  {pos.symbol}: qty={pos.qty}, P/L=${unrealized:,.2f}")
              position_list.append({
                  "symbol": pos.symbol,
                  "qty": float(pos.qty),
                  "price": float(pos.current_price),
                  "value": float(pos.market_value),
                  "pnl": unrealized,
                  "type": "option" if len(pos.symbol) > 10 else "stock"
              })

          # Calculate total P/L from initial $5000
          initial_equity = 5000.0
          total_pl = equity - initial_equity
          total_pl_pct = (total_pl / initial_equity) * 100

          print(f"\nTotal Unrealized P/L: ${total_unrealized:,.2f}")
          print(f"Total P/L (from $5K): ${total_pl:,.2f} ({total_pl_pct:.2f}%)")

          # LL-237 FIX: Sync trade_history to prevent knowledge loss
          # Fetch ALL closed orders, not just today's
          today_str = datetime.now(timezone.utc).strftime("%Y-%m-%d")
          total_trades_today = 0
          trade_history = []
          try:
              from alpaca.trading.requests import GetOrdersRequest
              from alpaca.trading.enums import QueryOrderStatus

              # Fetch all closed orders (up to 100)
              all_orders_request = GetOrdersRequest(
                  status=QueryOrderStatus.CLOSED,
                  limit=100
              )
              all_orders = client.get_orders(filter=all_orders_request)

              # Build trade_history from filled orders
              trade_history = [
                  {
                      "id": str(o.id),
                      "symbol": o.symbol,
                      "side": str(o.side),
                      "qty": str(o.filled_qty),
                      "price": str(o.filled_avg_price) if o.filled_avg_price else "0",
                      "filled_at": str(o.filled_at) if o.filled_at else None,
                  }
                  for o in all_orders
                  if o.filled_at
              ]
              print(f"ðŸ“œ Trade history: {len(trade_history)} closed orders")

              # Count today's orders specifically
              filled_orders = [o for o in all_orders if str(o.status) == 'filled' and str(o.filled_at).startswith(today_str)]
              total_trades_today = len(filled_orders)
              print(f"Filled orders today: {total_trades_today}")
          except Exception as e:
              print(f"Could not fetch orders: {e}")

          # Update system_state.json with UTC timestamp
          state_file = Path("data/system_state.json")

          # Load existing state to preserve sync_health history
          existing_state = {}
          if state_file.exists():
              try:
                  existing_state = json.loads(state_file.read_text())
              except:
                  pass

          # Track sync health metrics (use UTC for consistency)
          sync_history = existing_state.get("sync_health", {}).get("history", [])
          sync_history.append({
              "timestamp": datetime.now(timezone.utc).isoformat(),
              "equity": equity,
              "success": True
          })
          # Keep last 24 syncs (covers ~6 hours at 15-min intervals)
          sync_history = sync_history[-24:]

          # LL-237: Preserve existing trade_history if we couldn't fetch new data
          final_trade_history = trade_history if trade_history else existing_state.get("trade_history", [])

          state = {
              "last_updated": datetime.now(timezone.utc).isoformat(),
              "sync_health": {
                  "last_successful_sync": datetime.now(timezone.utc).isoformat(),
                  "sync_source": "github_actions",
                  "sync_count_today": len([s for s in sync_history if s["timestamp"].startswith(today_str)]),
                  "history": sync_history
              },
              "portfolio": {
                  "equity": equity,
                  "cash": cash
              },
              "paper_account": {
                  "equity": equity,
                  "cash": cash,
                  "buying_power": buying_power,
                  "total_pl": total_pl,
                  "total_pl_pct": round(total_pl_pct, 2),
                  "positions_count": len(positions),
                  "daily_change": round(today_pl, 2),
                  # FIX: Add win_rate fields expected by Dialogflow webhook
                  # Will be updated by trade completion logic when trades close
                  "win_rate": existing_state.get("paper_account", {}).get("win_rate", 0),
                  "win_rate_sample_size": existing_state.get("paper_account", {}).get("win_rate_sample_size", 0),
                  "starting_balance": 5000.0  # Per CLAUDE.md - $5K paper account
              },
              "positions": position_list,
              # LL-237 FIX: Add trade_history to prevent knowledge loss
              "trade_history": final_trade_history,
              "trades_loaded": len(final_trade_history),
              "trades": {
                  "last_trade_date": today_str,
                  "today_trades": total_trades_today,  # FIX: was "synced" string
                  "total_trades_today": total_trades_today,
                  "last_trade_symbol": positions[0].symbol if positions else "none"
              },
              "risk": {
                  "status": "MONITORING" if total_pl >= 0 else "WARNING - NEGATIVE P/L",
                  "total_pl": total_pl,
                  "unrealized_pl": total_unrealized
              },
              "account": {
                  "current_equity": equity,
                  "total_pl": total_pl,
                  "total_pl_pct": round(total_pl_pct, 2),
                  "positions_count": len(positions)
              },
              "meta": {
                  "last_updated": datetime.now(timezone.utc).isoformat(),
                  "trade_sync": "alpaca_api",
                  "sync_frequency_minutes": 5
              }
          }

          state_file.write_text(json.dumps(state, indent=2))
          print(f"\nâœ… Updated {state_file}")
          print("=" * 60)
          EOF

      - name: Commit and Create PR
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          # Check if there are changes
          git add data/system_state.json
          if git diff --staged --quiet; then
            echo "No changes to commit"
            exit 0
          fi

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create unique branch
          BRANCH="auto/sync-alpaca-$(date +%Y%m%d-%H%M%S)"
          git checkout -b "$BRANCH"
          git commit -m "chore: Sync Alpaca paper account status [auto]"
          git push -u origin "$BRANCH"

          # Create and merge PR using gh CLI
          PR_URL=$(gh pr create --title "chore: Sync Alpaca status [auto]" --body "Automated sync of paper account data (every 5 min)" --head "$BRANCH" --base main)
          echo "Created PR: $PR_URL"

          # Auto-merge
          gh pr merge "$BRANCH" --squash --delete-branch --admin || echo "Auto-merge may require manual approval"
          echo "Sync complete"

      - name: Notify on Failure
        if: failure()
        continue-on-error: true
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          pip install -q requests || true
          python3 scripts/notify_ceo.py --type warning --message "ALPACA SYNC FAILED - Data may become stale. Run: ${{ github.run_id }}. Check: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
