name: Diagnose Workflow Failures

on:
  workflow_dispatch:
  schedule:
    # Run daily at 2 AM UTC to check workflow health
    - cron: '0 2 * * *'

permissions:
  actions: read
  contents: read
  issues: write

jobs:
  diagnose:
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check workflow status and secrets
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { data: workflows } = await github.rest.actions.listWorkflowsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });

            const criticalWorkflows = [
              'daily-trading.yml',
              'youtube-analysis.yml',
              'notify-on-failure.yml',
              'workflow-health-check.yml',
            ];

            const issues = [];
            const disabledWorkflows = [];
            const missingSecrets = [];

            // Check each critical workflow
            for (const workflow of workflows.workflows) {
              const workflowName = workflow.path.replace('.github/workflows/', '');

              if (criticalWorkflows.includes(workflowName)) {
                const { data: workflowData } = await github.rest.actions.getWorkflow({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: workflow.id,
                });

                // Check if disabled
                if (!workflowData.state || workflowData.state === 'disabled') {
                  disabledWorkflows.push({
                    name: workflow.name,
                    path: workflow.path,
                    id: workflow.id,
                  });
                }

                // Get recent runs to check for patterns
                const { data: runs } = await github.rest.actions.listWorkflowRuns({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: workflow.id,
                  per_page: 5,
                });

                const recentFailures = runs.workflow_runs.filter(run => run.conclusion === 'failure');

                if (recentFailures.length > 0) {
                  issues.push({
                    workflow: workflow.name,
                    failures: recentFailures.length,
                    latestFailure: recentFailures[0].html_url,
                  });
                }
              }
            }

            // Generate report
            let report = `# üîç Workflow Failure Diagnosis Report\n\n`;
            report += `**Generated**: ${new Date().toISOString()}\n\n`;

            if (disabledWorkflows.length > 0) {
              report += `## üö® DISABLED WORKFLOWS (${disabledWorkflows.length})\n\n`;
              report += `**CRITICAL**: These workflows are disabled and won't run!\n\n`;
              for (const wf of disabledWorkflows) {
                report += `- **${wf.name}** (\`${wf.path}\`)\n`;
                report += `  - [Enable Workflow](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/workflows/${wf.path.replace('.github/workflows/', '')})\n`;
              }
              report += `\n### Quick Fix:\n`;
              report += `1. Go to each workflow link above\n`;
              report += `2. Click "Enable workflow" button\n`;
              report += `3. Click "Run workflow" to test\n\n`;
            }

            if (issues.length > 0) {
              report += `## ‚ùå RECENT FAILURES\n\n`;
              for (const issue of issues) {
                report += `### ${issue.workflow}\n`;
                report += `- **Failures**: ${issue.failures} recent failure(s)\n`;
                report += `- **Latest**: [View Run](${issue.latestFailure})\n\n`;
              }
            }

            if (disabledWorkflows.length === 0 && issues.length === 0) {
              report += `## ‚úÖ ALL WORKFLOWS HEALTHY\n\n`;
              report += `No disabled workflows or recent failures detected.\n`;
            }

            // Create or update issue
            const issueTitle = `üîç Workflow Health Report - ${new Date().toISOString().split('T')[0]}`;

            const { data: existingIssues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'workflow-health',
            });

            const todayIssue = existingIssues.find(issue =>
              issue.title.includes(new Date().toISOString().split('T')[0])
            );

            if (todayIssue) {
              // Update existing issue
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: todayIssue.number,
                body: report,
              });
              console.log(`Updated issue #${todayIssue.number}`);
            } else {
              // Create new issue
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: issueTitle,
                body: report,
                labels: ['workflow-health', 'automated'],
              });
              console.log('Created new health report issue');
            }

            // Output summary
            core.summary.addHeading('Workflow Health Summary');
            if (disabledWorkflows.length > 0) {
              core.summary.addRaw(`üö® **${disabledWorkflows.length} workflow(s) disabled**`);
              core.summary.addRaw(`\n\nCheck the created issue for details and fix instructions.`);
            } else if (issues.length > 0) {
              core.summary.addRaw(`‚ö†Ô∏è **${issues.length} workflow(s) with recent failures**`);
              core.summary.addRaw(`\n\nCheck the created issue for details.`);
            } else {
              core.summary.addRaw(`‚úÖ **All workflows healthy**`);
            }
            core.summary.write();
